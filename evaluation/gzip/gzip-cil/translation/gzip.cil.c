/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is true */

#include <gprolog.h>

#line 56 "/usr/include/i386-linux-gnu/bits/types.h"
typedef long long __quad_t;
#line 57 "/usr/include/i386-linux-gnu/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/i386-linux-gnu/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/i386-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/i386-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/i386-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/i386-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/i386-linux-gnu/bits/types.h"
typedef unsigned int __nlink_t;
#line 141 "/usr/include/i386-linux-gnu/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/i386-linux-gnu/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/i386-linux-gnu/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/i386-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/i386-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/i386-linux-gnu/bits/types.h"
typedef int __ssize_t;
#line 23 "/usr/include/i386-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 129 "/usr/include/dirent.h"
struct __dirstream;
#line 129 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 212 "/usr/lib/gcc/i686-linux-gnu/4.6/include/stddef.h"
typedef unsigned int size_t;
#line 87 "/usr/include/i386-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 110 "/usr/include/i386-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 39 "/usr/include/i386-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 45
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 172 "/usr/include/libio.h"
struct _IO_FILE;
#line 182 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 188 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 273 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 343 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 38 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 377 "gzip.c"
typedef void *voidp;
#line 390 "gzip.c"
typedef unsigned char uch;
#line 391 "gzip.c"
typedef unsigned short ush;
#line 392 "gzip.c"
typedef unsigned long ulg;
#line 497 "gzip.c"
typedef int file_t;
#line 1003 "gzip.c"
typedef ush Pos;
#line 1004 "gzip.c"
typedef unsigned int IPos;
#line 1089 "gzip.c"
struct config {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
};
#line 1089 "gzip.c"
typedef struct config config;
#line 1837 "gzip.c"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 2003
enum __anonenum_ordering_55 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 4780 "gzip.c"
union __anonunion_v_56 {
   ush n ;
   struct huft *t ;
};
#line 4780 "gzip.c"
struct huft {
   uch e ;
   uch b ;
   union __anonunion_v_56 v ;
};
#line 5802 "gzip.c"
union __anonunion_fc_57 {
   ush freq ;
   ush code ;
};
#line 5802 "gzip.c"
union __anonunion_dl_58 {
   ush dad ;
   ush len ;
};
#line 5802 "gzip.c"
struct ct_data {
   union __anonunion_fc_57 fc ;
   union __anonunion_dl_58 dl ;
};
#line 5802 "gzip.c"
typedef struct ct_data ct_data;
#line 5839 "gzip.c"
struct tree_desc {
   ct_data *dyn_tree ;
   ct_data *static_tree ;
   int *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
   int max_code ;
};
#line 5839 "gzip.c"
typedef struct tree_desc tree_desc;
#line 7125 "gzip.c"
typedef unsigned char char_type;
#line 7126 "gzip.c"
typedef long code_int;
#line 7129 "gzip.c"
typedef unsigned long cmp_code_int;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 126
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 136 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 151
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 164
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 47 "/usr/include/i386-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 119 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 463 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stdout ;
#line 171
extern struct _IO_FILE *stderr ;
#line 243
extern int fflush(FILE *__stream ) ;
#line 357
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 363
extern int printf(char const   * __restrict  __format  , ...) ;
#line 544
extern int getchar(void) ;
#line 843
extern void perror(char const   *__s ) ;
#line 855
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 61 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 76
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 44 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 65
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 68
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 128
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 143
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 146
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 235
static  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *str ,
                                                                                               int chr )  __attribute__((__pure__)) ;
#line 262
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 284
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 288
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 544
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 567
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 885
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rpmatch)(char const   *response ) ;
#line 211 "/usr/include/i386-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 216
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 265
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 299
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 258 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 335 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 354
extern int close(int __fd ) ;
#line 361
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 367
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 479
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 604
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 802
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 849
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 59 "/usr/include/getopt.h"
char *optarg  ;
#line 73
int optind ;
#line 78
int opterr ;
#line 82
int optopt ;
#line 152
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int argc , char * const  *argv ,
                                                                      char const   *optstring ) ;
#line 46 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 407 "gzip.c"
int method ;
#line 463 "gzip.c"
uch inbuf[32832]  ;
#line 464 "gzip.c"
uch outbuf[18432]  ;
#line 465 "gzip.c"
ush d_buf[32768]  ;
#line 466 "gzip.c"
uch window[65536L]  ;
#line 471 "gzip.c"
ush prev[1L << 16]  ;
#line 479 "gzip.c"
unsigned int insize  ;
#line 480 "gzip.c"
unsigned int inptr  ;
#line 481 "gzip.c"
unsigned int outcnt  ;
#line 482
int rsync ;
#line 484 "gzip.c"
off_t bytes_in  ;
#line 485 "gzip.c"
off_t bytes_out  ;
#line 486 "gzip.c"
off_t header_bytes  ;
#line 488 "gzip.c"
int ifd  ;
#line 489 "gzip.c"
int ofd  ;
#line 490 "gzip.c"
char ifname[1024]  ;
#line 491 "gzip.c"
char ofname[1024]  ;
#line 492 "gzip.c"
char *progname  ;
#line 494 "gzip.c"
time_t time_stamp  ;
#line 495 "gzip.c"
off_t ifile_size  ;
#line 539 "gzip.c"
int decrypt  ;
#line 540
int exit_code ;
#line 541
int verbose ;
#line 542
int quiet ;
#line 543
int level ;
#line 544
int test ;
#line 545
int to_stdout ;
#line 546 "gzip.c"
int save_orig_name  ;
#line 608
int zip(int in , int out ) ;
#line 609
int file_read(char *buf , unsigned int size ) ;
#line 612
int unzip(int in , int out ) ;
#line 613
int check_zipfile(int in ) ;
#line 616
int unpack(int in , int out ) ;
#line 619
int unlzh(int in , int out ) ;
#line 622
void abort_gzip_signal(void) ;
#line 625
void lm_init(int pack_level , ush *flags ) ;
#line 626
off_t deflate(void) ;
#line 629
void ct_init(ush *attr , int *methodp ) ;
#line 630
int ct_tally(int dist , int lc ) ;
#line 631
off_t flush_block(char *buf , ulg stored_len , int pad , int eof ) ;
#line 634
void bi_init(file_t zipfile ) ;
#line 635
void send_bits(int value , int length ) ;
#line 636
unsigned int bi_reverse(unsigned int code , int len ) ;
#line 637
void bi_windup(void) ;
#line 638
void copy_block(char *buf , unsigned int len , int header ) ;
#line 639 "gzip.c"
int (*read_buf)(char *buf , unsigned int size )  ;
#line 642
int copy(int in , int out ) ;
#line 643
ulg updcrc(uch *s , unsigned int n ) ;
#line 644
void clear_bufs(void) ;
#line 645
int fill_inbuf(int eof_ok ) ;
#line 646
void flush_outbuf(void) ;
#line 647
void flush_window(void) ;
#line 648
void write_buf(int fd , voidp buf , unsigned int cnt ) ;
#line 649
char *strlwr(char *s ) ;
#line 650
char *base_name(char *fname ) ;
#line 651
int xunlink(char *filename ) ;
#line 652
void make_simple_name(char *name ) ;
#line 653
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) ;
#line 654
void error(char *m ) ;
#line 655
void warning(char *m ) ;
#line 656
void read_error(void) ;
#line 657
void write_error(void) ;
#line 658
void display_ratio(off_t num , off_t den , FILE *file ) ;
#line 659
void fprint_off(FILE *file , off_t offset , int width ) ;
#line 660
voidp xmalloc(unsigned int size ) ;
#line 663
int inflate(void) ;
#line 666
int yesno(void) ;
#line 691 "gzip.c"
static file_t zfile  ;
#line 693 "gzip.c"
static unsigned short bi_buf  ;
#line 703 "gzip.c"
static int bi_valid  ;
#line 718 "gzip.c"
void bi_init(file_t zipfile ) 
{ 


  {
#line 721
  zfile = zipfile;
#line 722
  bi_buf = (unsigned short)0;
#line 723
  bi_valid = 0;
#line 731
  if (zfile != -1) {
#line 732
    read_buf = & file_read;
  } else {

  }

#line 718
  return;
}
}
#line 740 "gzip.c"
void send_bits(int value , int length ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 753
  if (bi_valid > (int )(16U * sizeof(char )) - length) {
#line 754
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 755
    if (outcnt < 16382U) {
#line 755
      tmp = outcnt;
#line 755
      outcnt ++;
#line 755
      outbuf[tmp] = (uch )((int )bi_buf & 255);
#line 755
      tmp___0 = outcnt;
#line 755
      outcnt ++;
#line 755
      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
    } else {
#line 755
      tmp___1 = outcnt;
#line 755
      outcnt ++;
#line 755
      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
#line 755
      if (outcnt == 16384U) {
#line 755
        flush_outbuf();
      } else {

      }
#line 755
      tmp___2 = outcnt;
#line 755
      outcnt ++;
#line 755
      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
#line 755
      if (outcnt == 16384U) {
#line 755
        flush_outbuf();
      } else {

      }
    }
#line 756
    bi_buf = (unsigned short )((int )((ush )value) >> (16U * sizeof(char ) - (unsigned int )bi_valid));
#line 757
    bi_valid = (int )((unsigned int )bi_valid + ((unsigned int )length - 16U * sizeof(char )));
  } else {
#line 759
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 760
    bi_valid += length;
  }

#line 740
  return;
}
}
#line 769 "gzip.c"
unsigned int bi_reverse(unsigned int code , int len ) 
{ 
  register unsigned int res ;
  unsigned int __retres4 ;

  {
#line 773
  res = 0U;
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    res |= code & 1U;
#line 776
    code >>= 1;
#line 776
    res <<= 1;
#line 774
    len --;
#line 774
    if (len > 0) {

    } else {
#line 774
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  __retres4 = res >> 1;
#line 769
  return (__retres4);
}
}
#line 784 "gzip.c"
void bi_windup(void) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 786
  if (bi_valid > 8) {
#line 787
    if (outcnt < 16382U) {
#line 787
      tmp = outcnt;
#line 787
      outcnt ++;
#line 787
      outbuf[tmp] = (uch )((int )bi_buf & 255);
#line 787
      tmp___0 = outcnt;
#line 787
      outcnt ++;
#line 787
      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
    } else {
#line 787
      tmp___1 = outcnt;
#line 787
      outcnt ++;
#line 787
      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
#line 787
      if (outcnt == 16384U) {
#line 787
        flush_outbuf();
      } else {

      }
#line 787
      tmp___2 = outcnt;
#line 787
      outcnt ++;
#line 787
      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
#line 787
      if (outcnt == 16384U) {
#line 787
        flush_outbuf();
      } else {

      }
    }
  } else
#line 788
  if (bi_valid > 0) {
#line 789
    tmp___3 = outcnt;
#line 789
    outcnt ++;
#line 789
    outbuf[tmp___3] = (uch )bi_buf;
#line 789
    if (outcnt == 16384U) {
#line 789
      flush_outbuf();
    } else {

    }
  } else {

  }
#line 791
  bi_buf = (unsigned short)0;
#line 792
  bi_valid = 0;

#line 784
  return;
}
}
#line 802 "gzip.c"
void copy_block(char *buf , unsigned int len , int header ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 807
  bi_windup();
#line 809
  if (header != 0) {
#line 810
    if (outcnt < 16382U) {
#line 810
      tmp = outcnt;
#line 810
      outcnt ++;
#line 810
      outbuf[tmp] = (uch )((int )((ush )len) & 255);
#line 810
      tmp___0 = outcnt;
#line 810
      outcnt ++;
#line 810
      outbuf[tmp___0] = (uch )((int )((ush )len) >> 8);
    } else {
#line 810
      tmp___1 = outcnt;
#line 810
      outcnt ++;
#line 810
      outbuf[tmp___1] = (uch )((int )((ush )len) & 255);
#line 810
      if (outcnt == 16384U) {
#line 810
        flush_outbuf();
      } else {

      }
#line 810
      tmp___2 = outcnt;
#line 810
      outcnt ++;
#line 810
      outbuf[tmp___2] = (uch )((int )((ush )len) >> 8);
#line 810
      if (outcnt == 16384U) {
#line 810
        flush_outbuf();
      } else {

      }
    }
#line 811
    if (outcnt < 16382U) {
#line 811
      tmp___3 = outcnt;
#line 811
      outcnt ++;
#line 811
      outbuf[tmp___3] = (uch )((int )((ush )(~ len)) & 255);
#line 811
      tmp___4 = outcnt;
#line 811
      outcnt ++;
#line 811
      outbuf[tmp___4] = (uch )((int )((ush )(~ len)) >> 8);
    } else {
#line 811
      tmp___5 = outcnt;
#line 811
      outcnt ++;
#line 811
      outbuf[tmp___5] = (uch )((int )((ush )(~ len)) & 255);
#line 811
      if (outcnt == 16384U) {
#line 811
        flush_outbuf();
      } else {

      }
#line 811
      tmp___6 = outcnt;
#line 811
      outcnt ++;
#line 811
      outbuf[tmp___6] = (uch )((int )((ush )(~ len)) >> 8);
#line 811
      if (outcnt == 16384U) {
#line 811
        flush_outbuf();
      } else {

      }
    }
  } else {

  }
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    tmp___9 = len;
#line 819
    len --;
#line 819
    if (tmp___9 != 0) {

    } else {
#line 819
      goto while_break;
    }
#line 824
    tmp___7 = outcnt;
#line 824
    outcnt ++;
#line 824
    tmp___8 = buf;
#line 824
    buf ++;
#line 824
    outbuf[tmp___7] = (uch )*tmp___8;
#line 824
    if (outcnt == 16384U) {
#line 824
      flush_outbuf();
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }

#line 802
  return;
}
}
#line 930
int maxbits ;
#line 931
int block_mode ;
#line 933
int lzw(int in , int out ) ;
#line 934
int unlzw(int in , int out ) ;
#line 1029 "gzip.c"
ulg window_size  =    65536UL;
#line 1034 "gzip.c"
long block_start  ;
#line 1039 "gzip.c"
static unsigned int ins_h  ;
#line 1048 "gzip.c"
unsigned int prev_length  ;
#line 1053 "gzip.c"
unsigned int strstart  ;
#line 1054 "gzip.c"
unsigned int match_start  ;
#line 1055 "gzip.c"
static int eofile  ;
#line 1056 "gzip.c"
static unsigned int lookahead  ;
#line 1058 "gzip.c"
unsigned int max_chain_length  ;
#line 1063 "gzip.c"
static unsigned int max_lazy_match  ;
#line 1074 "gzip.c"
static int compr_level  ;
#line 1077 "gzip.c"
unsigned int good_match  ;
#line 1080 "gzip.c"
static ulg rsync_sum  ;
#line 1081 "gzip.c"
static ulg rsync_chunk_end  ;
#line 1099 "gzip.c"
int nice_match  ;
#line 1102 "gzip.c"
static config configuration_table[10]  = 
#line 1102
  {      {(ush )0, (ush )0, (ush )0, (ush )0}, 
        {(ush )4, (ush )4, (ush )8, (ush )4}, 
        {(ush )4, (ush )5, (ush )16, (ush )8}, 
        {(ush )4, (ush )6, (ush )32, (ush )32}, 
        {(ush )4, (ush )4, (ush )16, (ush )16}, 
        {(ush )8, (ush )16, (ush )32, (ush )32}, 
        {(ush )8, (ush )16, (ush )128, (ush )128}, 
        {(ush )8, (ush )32, (ush )128, (ush )256}, 
        {(ush )32, (ush )128, (ush )258, (ush )1024}, 
        {(ush )32, (ush )258, (ush )258, (ush )4096}};
#line 1127
static void fill_window(void) ;
#line 1128
static off_t deflate_fast(void) ;
#line 1130
int longest_match(IPos cur_match ) ;
#line 1163 "gzip.c"
void lm_init(int pack_level , ush *flags ) 
{ 
  register unsigned int j ;
  unsigned int tmp ;
  int tmp___0 ;
  ush *mem_6 ;

  {
#line 1169
  if (pack_level < 1) {
#line 1169
    error((char *)"bad pack level");
  } else
#line 1169
  if (pack_level > 9) {
#line 1169
    error((char *)"bad pack level");
  } else {

  }
#line 1170
  compr_level = pack_level;
#line 1176
  mem_6 = prev + 32768;
#line 1176
  memset((voidp )((char *)(prev + 32768)), 0, (unsigned int )(1 << 15) * sizeof(*mem_6));
#line 1181
  rsync_chunk_end = 4294967295UL;
#line 1182
  rsync_sum = (ulg )0;
#line 1186
  max_lazy_match = (unsigned int )configuration_table[pack_level].max_lazy;
#line 1187
  good_match = (unsigned int )configuration_table[pack_level].good_length;
#line 1189
  nice_match = (int )configuration_table[pack_level].nice_length;
#line 1191
  max_chain_length = (unsigned int )configuration_table[pack_level].max_chain;
#line 1192
  if (pack_level == 1) {
#line 1193
    *flags = (ush )((int )*flags | 4);
  } else
#line 1194
  if (pack_level == 9) {
#line 1195
    *flags = (ush )((int )*flags | 2);
  } else {

  }
#line 1199
  strstart = 0U;
#line 1200
  block_start = 0L;
#line 1205
  if (sizeof(int ) <= 2U) {
#line 1205
    tmp = 32768U;
  } else {
#line 1205
    tmp = 65536U;
  }
#line 1205
  tmp___0 = (*read_buf)((char *)(window), tmp);
#line 1205
  lookahead = (unsigned int )tmp___0;
#line 1208
  if (lookahead == 0U) {
#line 1209
    eofile = 1;
#line 1209
    lookahead = 0U;

#line 1210
    goto return_label;
  } else
#line 1208
  if (lookahead == 4294967295U) {
#line 1209
    eofile = 1;
#line 1209
    lookahead = 0U;

#line 1210
    goto return_label;
  } else {

  }
#line 1212
  eofile = 0;
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    if (lookahead < 262U) {
#line 1216
      if (eofile == 0) {

      } else {
#line 1216
        goto while_break;
      }
    } else {
#line 1216
      goto while_break;
    }
#line 1216
    fill_window();
  }
  while_break: /* CIL Label */ ;
  }
#line 1218
  ins_h = 0U;
#line 1219
  j = 0U;
  {
#line 1219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1219
    if (j < 2U) {

    } else {
#line 1219
      goto while_break___0;
    }
#line 1219
    ins_h = ((ins_h << 5) ^ (unsigned int )window[j]) & ((unsigned int )(1 << 15) - 1U);
#line 1219
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  return_label: /* CIL Label */ 
#line 1163
  return;
}
}
#line 1238 "gzip.c"
int longest_match(IPos cur_match ) 
{ 
  unsigned int chain_length ;
  register uch *scan ;
  register uch *match ;
  register int len ;
  int best_len ;
  IPos limit ;
  unsigned int tmp ;
  register uch *strend ;
  register uch scan_end1 ;
  register uch scan_end ;
  uch *mem_12 ;
  uch *mem_13 ;
  uch *mem_14 ;
  uch *mem_15 ;
  uch *mem_16 ;
  uch *mem_17 ;
  uch *mem_18 ;

  {
#line 1241
  chain_length = max_chain_length;
#line 1242
  scan = window + strstart;
#line 1245
  best_len = (int )prev_length;
#line 1246
  if (strstart > 32506U) {
#line 1246
    tmp = strstart - 32506U;
  } else {
#line 1246
    tmp = 0U;
  }
#line 1246
  limit = tmp;
#line 1266
  strend = (window + strstart) + 258;
#line 1267
  mem_12 = scan + (best_len - 1);
#line 1267
  scan_end1 = *mem_12;
#line 1268
  mem_13 = scan + best_len;
#line 1268
  scan_end = *mem_13;
#line 1272
  if (prev_length >= good_match) {
#line 1273
    chain_length >>= 2;
  } else {

  }
  {
#line 1277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1279
    match = window + cur_match;
    {
#line 1318
    mem_14 = match + best_len;
#line 1318
    if ((int )*mem_14 != (int )scan_end) {
#line 1321
      goto __Cont;
    } else {
      {
#line 1318
      mem_15 = match + (best_len - 1);
#line 1318
      if ((int )*mem_15 != (int )scan_end1) {
#line 1321
        goto __Cont;
      } else
#line 1318
      if ((int )*match != (int )*scan) {
#line 1321
        goto __Cont;
      } else {
#line 1318
        match ++;
        {
#line 1318
        mem_16 = scan + 1;
#line 1318
        if ((int )*match != (int )*mem_16) {
#line 1321
          goto __Cont;
        } else {

        }
        }
      }
      }
    }
    }
#line 1329
    scan += 2;
#line 1329
    match ++;
    {
#line 1334
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1334
      scan ++;
#line 1334
      match ++;
#line 1334
      if ((int )*scan == (int )*match) {
#line 1334
        scan ++;
#line 1334
        match ++;
#line 1334
        if ((int )*scan == (int )*match) {
#line 1334
          scan ++;
#line 1334
          match ++;
#line 1334
          if ((int )*scan == (int )*match) {
#line 1334
            scan ++;
#line 1334
            match ++;
#line 1334
            if ((int )*scan == (int )*match) {
#line 1334
              scan ++;
#line 1334
              match ++;
#line 1334
              if ((int )*scan == (int )*match) {
#line 1334
                scan ++;
#line 1334
                match ++;
#line 1334
                if ((int )*scan == (int )*match) {
#line 1334
                  scan ++;
#line 1334
                  match ++;
#line 1334
                  if ((int )*scan == (int )*match) {
#line 1334
                    scan ++;
#line 1334
                    match ++;
#line 1334
                    if ((int )*scan == (int )*match) {
#line 1334
                      if ((unsigned int )scan < (unsigned int )strend) {

                      } else {
#line 1334
                        goto while_break___0;
                      }
                    } else {
#line 1334
                      goto while_break___0;
                    }
                  } else {
#line 1334
                    goto while_break___0;
                  }
                } else {
#line 1334
                  goto while_break___0;
                }
              } else {
#line 1334
                goto while_break___0;
              }
            } else {
#line 1334
              goto while_break___0;
            }
          } else {
#line 1334
            goto while_break___0;
          }
        } else {
#line 1334
          goto while_break___0;
        }
      } else {
#line 1334
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1341
    len = 258 - (strend - scan);
#line 1342
    scan = strend - 258;
#line 1346
    if (len > best_len) {
#line 1347
      match_start = cur_match;
#line 1348
      best_len = len;
#line 1349
      if (len >= nice_match) {
#line 1349
        goto while_break;
      } else {

      }
#line 1353
      mem_17 = scan + (best_len - 1);
#line 1353
      scan_end1 = *mem_17;
#line 1354
      mem_18 = scan + best_len;
#line 1354
      scan_end = *mem_18;
    } else {

    }
    __Cont: /* CIL Label */ 
#line 1277
    cur_match = (IPos )prev[cur_match & 32767U];
#line 1277
    if (cur_match > limit) {
#line 1277
      chain_length --;
#line 1277
      if (chain_length != 0U) {

      } else {
#line 1277
        goto while_break;
      }
    } else {
#line 1277
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1360
  return (best_len);
}
}
#line 1397 "gzip.c"
static void fill_window(void) 
{ 
  register unsigned int n ;
  register unsigned int m ;
  unsigned int more ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  ush *mem_7 ;
  ush *mem_8 ;

  {
#line 1400
  more = (unsigned int )((window_size - (ulg )lookahead) - (ulg )strstart);
#line 1406
  if (more == 4294967295U) {
#line 1410
    more --;
  } else
#line 1411
  if (strstart >= 65274U) {
#line 1417
    memcpy((void * __restrict  )((char *)(window)), (void const   * __restrict  )((char *)(window) + 32768),
           32768U);
#line 1418
    match_start -= 32768U;
#line 1419
    strstart -= 32768U;
#line 1420
    if (rsync_chunk_end != 4294967295UL) {
#line 1421
      rsync_chunk_end -= 32768UL;
    } else {

    }
#line 1423
    block_start -= 32768L;
#line 1425
    n = 0U;
    {
#line 1425
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1425
      if (n < (unsigned int )(1 << 15)) {

      } else {
#line 1425
        goto while_break;
      }
#line 1426
      mem_7 = (prev + 32768) + n;
#line 1426
      m = (unsigned int )*mem_7;
#line 1427
      if (m >= 32768U) {
#line 1427
        tmp = m - 32768U;
      } else {
#line 1427
        tmp = 0U;
      }
#line 1427
      mem_8 = (prev + 32768) + n;
#line 1427
      *mem_8 = (Pos )tmp;
#line 1425
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1429
    n = 0U;
    {
#line 1429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1429
      if (n < 32768U) {

      } else {
#line 1429
        goto while_break___0;
      }
#line 1430
      m = (unsigned int )prev[n];
#line 1431
      if (m >= 32768U) {
#line 1431
        tmp___0 = m - 32768U;
      } else {
#line 1431
        tmp___0 = 0U;
      }
#line 1431
      prev[n] = (Pos )tmp___0;
#line 1429
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1436
    more += 32768U;
  } else {

  }
#line 1439
  if (eofile == 0) {
#line 1440
    tmp___1 = (*read_buf)(((char *)(window) + strstart) + lookahead, more);
#line 1440
    n = (unsigned int )tmp___1;
#line 1441
    if (n == 0U) {
#line 1442
      eofile = 1;
    } else
#line 1441
    if (n == 4294967295U) {
#line 1442
      eofile = 1;
    } else {
#line 1444
      lookahead += n;
    }
  } else {

  }

#line 1397
  return;
}
}
#line 1449 "gzip.c"
static void rsync_roll(unsigned int start , unsigned int num ) 
{ 
  unsigned int i ;

  {
#line 1455
  if (start < 4096U) {
#line 1457
    i = start;
    {
#line 1457
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1457
      if (i < 4096U) {

      } else {
#line 1457
        goto while_break;
      }
#line 1458
      if (i == start + num) {

#line 1458
        goto return_label;
      } else {

      }
#line 1459
      rsync_sum += (ulg )window[i];
#line 1457
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1461
    num -= 4096U - start;
#line 1462
    start = 4096U;
  } else {

  }
#line 1466
  i = start;
  {
#line 1466
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1466
    if (i < start + num) {

    } else {
#line 1466
      goto while_break___0;
    }
#line 1468
    rsync_sum += (ulg )window[i];
#line 1470
    rsync_sum -= (ulg )window[i - 4096U];
#line 1471
    if (rsync_chunk_end == 4294967295UL) {
#line 1471
      if (rsync_sum % 4096UL == 0UL) {
#line 1472
        rsync_chunk_end = (ulg )i;
      } else {

      }
    } else {

    }
#line 1466
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }

  return_label: /* CIL Label */ 
#line 1449
  return;
}
}
#line 1496 "gzip.c"
static off_t deflate_fast(void) 
{ 
  IPos hash_head ;
  int flush ;
  unsigned int match_length ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  off_t tmp___2 ;
  ush *mem_8 ;
  ush *mem_9 ;
  ush *mem_10 ;
  ush *mem_11 ;

  {
#line 1500
  match_length = 0U;
#line 1502
  prev_length = 2U;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (lookahead != 0U) {

    } else {
#line 1503
      goto while_break;
    }
#line 1507
    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 1507
    mem_8 = (prev + 32768) + ins_h;
#line 1507
    hash_head = (IPos )*mem_8;
#line 1507
    prev[strstart & 32767U] = (ush )hash_head;
#line 1507
    mem_9 = (prev + 32768) + ins_h;
#line 1507
    *mem_9 = (ush )strstart;
#line 1512
    if (hash_head != 0U) {
#line 1512
      if (strstart - hash_head <= 32506U) {
#line 1512
        if ((ulg )strstart <= window_size - 262UL) {
#line 1518
          tmp = longest_match(hash_head);
#line 1518
          match_length = (unsigned int )tmp;
#line 1520
          if (match_length > lookahead) {
#line 1520
            match_length = lookahead;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 1522
    if (match_length >= 3U) {
#line 1525
      flush = ct_tally((int )(strstart - match_start), (int )(match_length - 3U));
#line 1527
      lookahead -= match_length;
      {
#line 1529
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1529
        if (rsync != 0) {
#line 1529
          rsync_roll(strstart, match_length);
        } else {

        }
#line 1529
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1533
      if (match_length <= max_lazy_match) {
#line 1534
        match_length --;
        {
#line 1535
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1536
          strstart ++;
#line 1537
          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 1537
          mem_10 = (prev + 32768) + ins_h;
#line 1537
          hash_head = (IPos )*mem_10;
#line 1537
          prev[strstart & 32767U] = (ush )hash_head;
#line 1537
          mem_11 = (prev + 32768) + ins_h;
#line 1537
          *mem_11 = (ush )strstart;
#line 1535
          match_length --;
#line 1535
          if (match_length != 0U) {

          } else {
#line 1535
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1544
        strstart ++;
      } else {
#line 1546
        strstart += match_length;
#line 1547
        match_length = 0U;
#line 1548
        ins_h = (unsigned int )window[strstart];
#line 1549
        ins_h = ((ins_h << 5) ^ (unsigned int )window[strstart + 1U]) & ((unsigned int )(1 << 15) - 1U);
      }
    } else {
#line 1557
      flush = ct_tally(0, (int )window[strstart]);
      {
#line 1558
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1558
        if (rsync != 0) {
#line 1558
          rsync_roll(strstart, 1U);
        } else {

        }
#line 1558
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1559
      lookahead --;
#line 1560
      strstart ++;
    }
#line 1562
    if (rsync != 0) {
#line 1562
      if ((ulg )strstart > rsync_chunk_end) {
#line 1563
        rsync_chunk_end = 4294967295UL;
#line 1564
        flush = 2;
      } else {

      }
    } else {

    }
#line 1566
    if (flush != 0) {
#line 1566
      if (block_start >= 0L) {
#line 1566
        tmp___0 = (char *)(& window[(unsigned int )block_start]);
      } else {
#line 1566
        tmp___0 = (char *)((void *)0);
      }
#line 1566
      flush_block(tmp___0, (ulg )((long )strstart - block_start), flush - 1, 0);
#line 1566
      block_start = (long )strstart;
    } else {

    }
    {
#line 1573
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1573
      if (lookahead < 262U) {
#line 1573
        if (eofile == 0) {

        } else {
#line 1573
          goto while_break___3;
        }
      } else {
#line 1573
        goto while_break___3;
      }
#line 1573
      fill_window();
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1576
  if (block_start >= 0L) {
#line 1576
    tmp___1 = (char *)(& window[(unsigned int )block_start]);
  } else {
#line 1576
    tmp___1 = (char *)((void *)0);
  }
#line 1576
  tmp___2 = flush_block(tmp___1, (ulg )((long )strstart - block_start), flush - 1,
                        1);
#line 1576
  return (tmp___2);
}
}
#line 1584 "gzip.c"
off_t deflate(void) 
{ 
  IPos hash_head ;
  IPos prev_match ;
  int flush ;
  int match_available ;
  register unsigned int match_length ;
  off_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  off_t tmp___5 ;
  ush *mem_13 ;
  ush *mem_14 ;
  ush *mem_15 ;
  ush *mem_16 ;
  off_t __retres17 ;

  {
#line 1589
  match_available = 0;
#line 1590
  match_length = 2U;
#line 1592
  if (compr_level <= 3) {
#line 1592
    tmp = deflate_fast();
#line 1592
    __retres17 = tmp;
#line 1592
    goto return_label;
  } else {

  }
  {
#line 1595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1595
    if (lookahead != 0U) {

    } else {
#line 1595
      goto while_break;
    }
#line 1599
    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 1599
    mem_13 = (prev + 32768) + ins_h;
#line 1599
    hash_head = (IPos )*mem_13;
#line 1599
    prev[strstart & 32767U] = (ush )hash_head;
#line 1599
    mem_14 = (prev + 32768) + ins_h;
#line 1599
    *mem_14 = (ush )strstart;
#line 1603
    prev_length = match_length;
#line 1603
    prev_match = match_start;
#line 1604
    match_length = 2U;
#line 1606
    if (hash_head != 0U) {
#line 1606
      if (prev_length < max_lazy_match) {
#line 1606
        if (strstart - hash_head <= 32506U) {
#line 1606
          if ((ulg )strstart <= window_size - 262UL) {
#line 1613
            tmp___0 = longest_match(hash_head);
#line 1613
            match_length = (unsigned int )tmp___0;
#line 1615
            if (match_length > lookahead) {
#line 1615
              match_length = lookahead;
            } else {

            }
#line 1618
            if (match_length == 3U) {
#line 1618
              if (strstart - match_start > 4096U) {
#line 1622
                match_length --;
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 1628
    if (prev_length >= 3U) {
#line 1628
      if (match_length <= prev_length) {
#line 1632
        flush = ct_tally((int )((strstart - 1U) - prev_match), (int )(prev_length - 3U));
#line 1637
        lookahead -= prev_length - 1U;
#line 1638
        prev_length -= 2U;
        {
#line 1639
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1639
          if (rsync != 0) {
#line 1639
            rsync_roll(strstart, prev_length + 1U);
          } else {

          }
#line 1639
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1640
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1641
          strstart ++;
#line 1642
          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 1642
          mem_15 = (prev + 32768) + ins_h;
#line 1642
          hash_head = (IPos )*mem_15;
#line 1642
          prev[strstart & 32767U] = (ush )hash_head;
#line 1642
          mem_16 = (prev + 32768) + ins_h;
#line 1642
          *mem_16 = (ush )strstart;
#line 1640
          prev_length --;
#line 1640
          if (prev_length != 0U) {

          } else {
#line 1640
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1649
        match_available = 0;
#line 1650
        match_length = 2U;
#line 1651
        strstart ++;
#line 1653
        if (rsync != 0) {
#line 1653
          if ((ulg )strstart > rsync_chunk_end) {
#line 1654
            rsync_chunk_end = 4294967295UL;
#line 1655
            flush = 2;
          } else {

          }
        } else {

        }
#line 1657
        if (flush != 0) {
#line 1657
          if (block_start >= 0L) {
#line 1657
            tmp___1 = (char *)(& window[(unsigned int )block_start]);
          } else {
#line 1657
            tmp___1 = (char *)((void *)0);
          }
#line 1657
          flush_block(tmp___1, (ulg )((long )strstart - block_start), flush - 1, 0);
#line 1657
          block_start = (long )strstart;
        } else {

        }
      } else {
#line 1628
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1658
    if (match_available != 0) {
#line 1664
      flush = ct_tally(0, (int )window[strstart - 1U]);
#line 1665
      if (rsync != 0) {
#line 1665
        if ((ulg )strstart > rsync_chunk_end) {
#line 1666
          rsync_chunk_end = 4294967295UL;
#line 1667
          flush = 2;
        } else {

        }
      } else {

      }
#line 1669
      if (flush != 0) {
#line 1669
        if (block_start >= 0L) {
#line 1669
          tmp___2 = (char *)(& window[(unsigned int )block_start]);
        } else {
#line 1669
          tmp___2 = (char *)((void *)0);
        }
#line 1669
        flush_block(tmp___2, (ulg )((long )strstart - block_start), flush - 1, 0);
#line 1669
        block_start = (long )strstart;
      } else {

      }
      {
#line 1670
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1670
        if (rsync != 0) {
#line 1670
          rsync_roll(strstart, 1U);
        } else {

        }
#line 1670
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1671
      strstart ++;
#line 1672
      lookahead --;
    } else {
#line 1677
      if (rsync != 0) {
#line 1677
        if ((ulg )strstart > rsync_chunk_end) {
#line 1679
          rsync_chunk_end = 4294967295UL;
#line 1680
          flush = 2;
#line 1681
          if (block_start >= 0L) {
#line 1681
            tmp___3 = (char *)(& window[(unsigned int )block_start]);
          } else {
#line 1681
            tmp___3 = (char *)((void *)0);
          }
#line 1681
          flush_block(tmp___3, (ulg )((long )strstart - block_start), flush - 1, 0);
#line 1681
          block_start = (long )strstart;
        } else {

        }
      } else {

      }
#line 1683
      match_available = 1;
      {
#line 1684
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1684
        if (rsync != 0) {
#line 1684
          rsync_roll(strstart, 1U);
        } else {

        }
#line 1684
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1685
      strstart ++;
#line 1686
      lookahead --;
    }
    {
#line 1695
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1695
      if (lookahead < 262U) {
#line 1695
        if (eofile == 0) {

        } else {
#line 1695
          goto while_break___4;
        }
      } else {
#line 1695
        goto while_break___4;
      }
#line 1695
      fill_window();
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1697
  if (match_available != 0) {
#line 1697
    ct_tally(0, (int )window[strstart - 1U]);
  } else {

  }
#line 1699
  if (block_start >= 0L) {
#line 1699
    tmp___4 = (char *)(& window[(unsigned int )block_start]);
  } else {
#line 1699
    tmp___4 = (char *)((void *)0);
  }
#line 1699
  tmp___5 = flush_block(tmp___4, (ulg )((long )strstart - block_start), flush - 1,
                        1);
#line 1699
  __retres17 = tmp___5;
  return_label: /* CIL Label */ 
#line 1584
  return (__retres17);
}
}
#line 1893
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) ;
#line 1895
int getopt_long_only(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                     int *opt_index ) ;
#line 1900
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) ;
#line 1946 "gzip.c"
int optind  =    1;
#line 1952 "gzip.c"
int __getopt_initialized  ;
#line 1961 "gzip.c"
static char *nextchar  ;
#line 1966 "gzip.c"
int opterr  =    1;
#line 1972 "gzip.c"
int optopt  =    '?';
#line 2003 "gzip.c"
static enum __anonenum_ordering_55 ordering  ;
#line 2009 "gzip.c"
static char *posixly_correct  ;
#line 2020
static  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *str ,
                                                                                               int chr )  __attribute__((__pure__)) ;
#line 2020 "gzip.c"
static char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *str ,
                                                                 int chr ) 
{ 
  char *__retres3 ;

  {
  {
#line 2025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2025
    if (*str != 0) {

    } else {
#line 2025
      goto while_break;
    }
#line 2027
    if ((int const   )*str == (int const   )chr) {
#line 2028
      __retres3 = (char *)str;
#line 2028
      goto return_label;
    } else {

    }
#line 2029
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2031
  __retres3 = (char *)0;
  return_label: /* CIL Label */ 
#line 2020
  return (__retres3);
}
}
#line 2053 "gzip.c"
static int first_nonopt  ;
#line 2054 "gzip.c"
static int last_nonopt  ;
#line 2112
static void exchange(char **argv ) ;
#line 2115 "gzip.c"
static void exchange(char **argv ) 
{ 
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;
  char **mem_10 ;
  char **mem_11 ;
  char **mem_12 ;
  char **mem_13 ;
  char **mem_14 ;
  char **mem_15 ;
  char **mem_16 ;
  char **mem_17 ;

  {
#line 2119
  bottom = first_nonopt;
#line 2120
  middle = last_nonopt;
#line 2121
  top = optind;
  {
#line 2151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2151
    if (top > middle) {
#line 2151
      if (middle > bottom) {

      } else {
#line 2151
        goto while_break;
      }
    } else {
#line 2151
      goto while_break;
    }
#line 2153
    if (top - middle > middle - bottom) {
#line 2156
      len = middle - bottom;
#line 2160
      i = 0;
      {
#line 2160
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2160
        if (i < len) {

        } else {
#line 2160
          goto while_break___0;
        }
#line 2162
        mem_10 = argv + (bottom + i);
#line 2162
        tem = *mem_10;
#line 2163
        mem_11 = argv + (bottom + i);
#line 2163
        mem_12 = argv + ((top - (middle - bottom)) + i);
#line 2163
        *mem_11 = *mem_12;
#line 2164
        mem_13 = argv + ((top - (middle - bottom)) + i);
#line 2164
        *mem_13 = tem;
#line 2160
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2168
      top -= len;
    } else {
#line 2173
      len___0 = top - middle;
#line 2177
      i___0 = 0;
      {
#line 2177
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2177
        if (i___0 < len___0) {

        } else {
#line 2177
          goto while_break___1;
        }
#line 2179
        mem_14 = argv + (bottom + i___0);
#line 2179
        tem = *mem_14;
#line 2180
        mem_15 = argv + (bottom + i___0);
#line 2180
        mem_16 = argv + (middle + i___0);
#line 2180
        *mem_15 = *mem_16;
#line 2181
        mem_17 = argv + (middle + i___0);
#line 2181
        *mem_17 = tem;
#line 2177
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2185
      bottom += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2191
  first_nonopt += optind - last_nonopt;
#line 2192
  last_nonopt = optind;

#line 2115
  return;
}
}
#line 2198
static char const   *_getopt_initialize(int argc , char * const  *argv , char const   *optstring ) ;
#line 2200 "gzip.c"
static char const   *_getopt_initialize(int argc , char * const  *argv , char const   *optstring ) 
{ 
  char const   *mem_4 ;
  char const   *mem_5 ;

  {
#line 2210
  last_nonopt = optind;
#line 2210
  first_nonopt = last_nonopt;
#line 2212
  nextchar = (char *)((void *)0);
#line 2214
  posixly_correct = getenv("POSIXLY_CORRECT");
  {
#line 2218
  mem_4 = optstring + 0;
#line 2218
  if ((int const   )*mem_4 == 45) {
#line 2220
    ordering = (enum __anonenum_ordering_55 )2;
#line 2221
    optstring ++;
  } else {
    {
#line 2223
    mem_5 = optstring + 0;
#line 2223
    if ((int const   )*mem_5 == 43) {
#line 2225
      ordering = (enum __anonenum_ordering_55 )0;
#line 2226
      optstring ++;
    } else
#line 2228
    if ((unsigned int )posixly_correct != (unsigned int )((void *)0)) {
#line 2229
      ordering = (enum __anonenum_ordering_55 )0;
    } else {
#line 2231
      ordering = (enum __anonenum_ordering_55 )1;
    }
    }
  }
  }
#line 2263
  return (optstring);
}
}
#line 2322 "gzip.c"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) 
{ 
  int print_errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *nameend ;
  struct option  const  *p ;
  struct option  const  *pfound ;
  int exact ;
  int ambig ;
  int indfound ;
  int option_index ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char c ;
  char *tmp___12 ;
  char *temp ;
  char *tmp___13 ;
  char *nameend___0 ;
  struct option  const  *p___0 ;
  struct option  const  *pfound___0 ;
  int exact___0 ;
  int ambig___0 ;
  int indfound___0 ;
  int option_index___0 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  char const   *mem_49 ;
  char * const  *mem_50 ;
  char *mem_51 ;
  char * const  *mem_52 ;
  char *mem_53 ;
  char * const  *mem_54 ;
  char * const  *mem_55 ;
  char *mem_56 ;
  char * const  *mem_57 ;
  char *mem_58 ;
  char * const  *mem_59 ;
  char * const  *mem_60 ;
  char *mem_61 ;
  char * const  *mem_62 ;
  char * const  *mem_63 ;
  char *mem_64 ;
  char * const  *mem_65 ;
  char *mem_66 ;
  char * const  *mem_67 ;
  char *mem_68 ;
  char * const  *mem_69 ;
  char * const  *mem_70 ;
  char * const  *mem_71 ;
  char *mem_72 ;
  char * const  *mem_73 ;
  char * const  *mem_74 ;
  char * const  *mem_75 ;
  char *mem_76 ;
  char * const  *mem_77 ;
  char * const  *mem_78 ;
  char * const  *mem_79 ;
  char const   *mem_80 ;
  int *mem_81 ;
  char * const  *mem_82 ;
  char *mem_83 ;
  char * const  *mem_84 ;
  char *mem_85 ;
  char * const  *mem_86 ;
  char * const  *mem_87 ;
  char * const  *mem_88 ;
  char *mem_89 ;
  char * const  *mem_90 ;
  char * const  *mem_91 ;
  char *mem_92 ;
  char *mem_93 ;
  char * const  *mem_94 ;
  char const   *mem_95 ;
  char * const  *mem_96 ;
  char * const  *mem_97 ;
  char * const  *mem_98 ;
  char * const  *mem_99 ;
  char * const  *mem_100 ;
  char * const  *mem_101 ;
  char * const  *mem_102 ;
  char const   *mem_103 ;
  int *mem_104 ;
  char *mem_105 ;
  char *mem_106 ;
  char * const  *mem_107 ;
  char const   *mem_108 ;
  char * const  *mem_109 ;
  int __retres110 ;

  {
#line 2331
  print_errors = opterr;
  {
#line 2332
  mem_49 = optstring + 0;
#line 2332
  if ((int const   )*mem_49 == 58) {
#line 2333
    print_errors = 0;
  } else {

  }
  }
#line 2335
  if (argc < 1) {
#line 2336
    __retres110 = -1;
#line 2336
    goto return_label;
  } else {

  }
#line 2338
  optarg = (char *)((void *)0);
#line 2340
  if (optind == 0) {
#line 2340
    goto _L;
  } else
#line 2340
  if (__getopt_initialized == 0) {
    _L: /* CIL Label */ 
#line 2342
    if (optind == 0) {
#line 2343
      optind = 1;
    } else {

    }
#line 2344
    optstring = _getopt_initialize(argc, argv, optstring);
#line 2345
    __getopt_initialized = 1;
  } else {

  }
#line 2360
  if ((unsigned int )nextchar == (unsigned int )((void *)0)) {
#line 2360
    goto _L___3;
  } else
#line 2360
  if ((int )*nextchar == 0) {
    _L___3: /* CIL Label */ 
#line 2366
    if (last_nonopt > optind) {
#line 2367
      last_nonopt = optind;
    } else {

    }
#line 2368
    if (first_nonopt > optind) {
#line 2369
      first_nonopt = optind;
    } else {

    }
#line 2371
    if ((unsigned int )ordering == 1U) {
#line 2376
      if (first_nonopt != last_nonopt) {
#line 2376
        if (last_nonopt != optind) {
#line 2377
          exchange((char **)argv);
        } else {
#line 2376
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2378
      if (last_nonopt != optind) {
#line 2379
        first_nonopt = optind;
      } else {

      }
      {
#line 2384
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2384
        if (optind < argc) {
          {
#line 2384
          mem_50 = argv + optind;
#line 2384
          mem_51 = *mem_50 + 0;
#line 2384
          if ((int )*mem_51 != 45) {

          } else {
            {
#line 2384
            mem_52 = argv + optind;
#line 2384
            mem_53 = *mem_52 + 1;
#line 2384
            if ((int )*mem_53 == 0) {

            } else {
#line 2384
              goto while_break;
            }
            }
          }
          }
        } else {
#line 2384
          goto while_break;
        }
#line 2385
        optind ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2386
      last_nonopt = optind;
    } else {

    }
#line 2394
    if (optind != argc) {
#line 2394
      mem_54 = argv + optind;
#line 2394
      tmp = strcmp((char const   *)*mem_54, "--");
#line 2394
      if (tmp != 0) {

      } else {
#line 2396
        optind ++;
#line 2398
        if (first_nonopt != last_nonopt) {
#line 2398
          if (last_nonopt != optind) {
#line 2399
            exchange((char **)argv);
          } else {
#line 2398
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 2400
        if (first_nonopt == last_nonopt) {
#line 2401
          first_nonopt = optind;
        } else {

        }
#line 2402
        last_nonopt = argc;
#line 2404
        optind = argc;
      }
    } else {

    }
#line 2410
    if (optind == argc) {
#line 2414
      if (first_nonopt != last_nonopt) {
#line 2415
        optind = first_nonopt;
      } else {

      }
#line 2416
      __retres110 = -1;
#line 2416
      goto return_label;
    } else {

    }
    {
#line 2422
    mem_55 = argv + optind;
#line 2422
    mem_56 = *mem_55 + 0;
#line 2422
    if ((int )*mem_56 != 45) {
#line 2422
      goto _L___2;
    } else {
      {
#line 2422
      mem_57 = argv + optind;
#line 2422
      mem_58 = *mem_57 + 1;
#line 2422
      if ((int )*mem_58 == 0) {
        _L___2: /* CIL Label */ 
#line 2424
        if ((unsigned int )ordering == 0U) {
#line 2425
          __retres110 = -1;
#line 2425
          goto return_label;
        } else {

        }
#line 2426
        tmp___0 = optind;
#line 2426
        optind ++;
#line 2426
        mem_59 = argv + tmp___0;
#line 2426
        optarg = (char *)*mem_59;
#line 2427
        __retres110 = 1;
#line 2427
        goto return_label;
      } else {

      }
      }
    }
    }
#line 2433
    if ((unsigned int )longopts != (unsigned int )((void *)0)) {
      {
#line 2433
      mem_60 = argv + optind;
#line 2433
      mem_61 = *mem_60 + 1;
#line 2433
      if ((int )*mem_61 == 45) {
#line 2433
        tmp___1 = 1;
      } else {
#line 2433
        tmp___1 = 0;
      }
      }
    } else {
#line 2433
      tmp___1 = 0;
    }
#line 2433
    mem_62 = argv + optind;
#line 2433
    nextchar = (char *)((*mem_62 + 1) + tmp___1);
  } else {

  }
#line 2452
  if ((unsigned int )longopts != (unsigned int )((void *)0)) {
    {
#line 2452
    mem_63 = argv + optind;
#line 2452
    mem_64 = *mem_63 + 1;
#line 2452
    if ((int )*mem_64 == 45) {
#line 2452
      goto _L___6;
    } else
#line 2452
    if (long_only != 0) {
      {
#line 2452
      mem_65 = argv + optind;
#line 2452
      mem_66 = *mem_65 + 2;
#line 2452
      if (*mem_66 != 0) {
#line 2452
        goto _L___6;
      } else {
#line 2452
        mem_67 = argv + optind;
#line 2452
        mem_68 = *mem_67 + 1;
#line 2452
        tmp___11 = strchr(optstring, (int )*mem_68);
#line 2452
        if (tmp___11 != 0) {

        } else {
          _L___6: /* CIL Label */ 
#line 2458
          pfound = (struct option  const  *)((void *)0);
#line 2459
          exact = 0;
#line 2460
          ambig = 0;
#line 2461
          indfound = -1;
#line 2464
          nameend = nextchar;
          {
#line 2464
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 2464
            if (*nameend != 0) {
#line 2464
              if ((int )*nameend != 61) {

              } else {
#line 2464
                goto while_break___0;
              }
            } else {
#line 2464
              goto while_break___0;
            }
#line 2464
            nameend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 2469
          p = longopts;
#line 2469
          option_index = 0;
          {
#line 2469
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2469
            if (p->name != 0) {

            } else {
#line 2469
              goto while_break___1;
            }
#line 2470
            tmp___3 = strncmp((char const   *)p->name, (char const   *)nextchar, (size_t )(nameend - nextchar));
#line 2470
            if (tmp___3 != 0) {

            } else {
#line 2472
              tmp___2 = strlen((char const   *)p->name);
#line 2472
              if ((unsigned int )(nameend - nextchar) == tmp___2) {
#line 2476
                pfound = p;
#line 2477
                indfound = option_index;
#line 2478
                exact = 1;
#line 2479
                goto while_break___1;
              } else
#line 2481
              if ((unsigned int )pfound == (unsigned int )((void *)0)) {
#line 2484
                pfound = p;
#line 2485
                indfound = option_index;
              } else
#line 2487
              if (long_only != 0) {
#line 2492
                ambig = 1;
              } else
#line 2487
              if (pfound->has_arg != p->has_arg) {
#line 2492
                ambig = 1;
              } else
#line 2487
              if ((unsigned int )pfound->flag != (unsigned int )p->flag) {
#line 2492
                ambig = 1;
              } else
#line 2487
              if (pfound->val != p->val) {
#line 2492
                ambig = 1;
              } else {

              }
            }
#line 2469
            p ++;
#line 2469
            option_index ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2495
          if (ambig != 0) {
#line 2495
            if (exact == 0) {
#line 2497
              if (print_errors != 0) {
#line 2498
                mem_69 = argv + 0;
#line 2498
                mem_70 = argv + optind;
#line 2498
                fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option `%s\' is ambiguous\n",
                        *mem_69, *mem_70);
              } else {

              }
#line 2500
              tmp___4 = strlen((char const   *)nextchar);
#line 2500
              nextchar += tmp___4;
#line 2501
              optind ++;
#line 2502
              optopt = 0;
#line 2503
              __retres110 = '?';
#line 2503
              goto return_label;
            } else {

            }
          } else {

          }
#line 2506
          if ((unsigned int )pfound != (unsigned int )((void *)0)) {
#line 2508
            option_index = indfound;
#line 2509
            optind ++;
#line 2510
            if (*nameend != 0) {
#line 2514
              if (pfound->has_arg != 0) {
#line 2515
                optarg = nameend + 1;
              } else {
#line 2518
                if (print_errors != 0) {
                  {
#line 2520
                  mem_71 = argv + (optind - 1);
#line 2520
                  mem_72 = *mem_71 + 1;
#line 2520
                  if ((int )*mem_72 == 45) {
#line 2522
                    mem_73 = argv + 0;
#line 2522
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option `--%s\' doesn\'t allow an argument\n",
                            *mem_73, pfound->name);
                  } else {
#line 2527
                    mem_74 = argv + 0;
#line 2527
                    mem_75 = argv + (optind - 1);
#line 2527
                    mem_76 = *mem_75 + 0;
#line 2527
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option `%c%s\' doesn\'t allow an argument\n",
                            *mem_74, (int )*mem_76, pfound->name);
                  }
                  }
                } else {

                }
#line 2532
                tmp___5 = strlen((char const   *)nextchar);
#line 2532
                nextchar += tmp___5;
#line 2534
                optopt = (int )pfound->val;
#line 2535
                __retres110 = '?';
#line 2535
                goto return_label;
              }
            } else
#line 2538
            if (pfound->has_arg == 1) {
#line 2540
              if (optind < argc) {
#line 2541
                tmp___6 = optind;
#line 2541
                optind ++;
#line 2541
                mem_77 = argv + tmp___6;
#line 2541
                optarg = (char *)*mem_77;
              } else {
#line 2544
                if (print_errors != 0) {
#line 2545
                  mem_78 = argv + 0;
#line 2545
                  mem_79 = argv + (optind - 1);
#line 2545
                  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option `%s\' requires an argument\n",
                          *mem_78, *mem_79);
                } else {

                }
#line 2548
                tmp___7 = strlen((char const   *)nextchar);
#line 2548
                nextchar += tmp___7;
#line 2549
                optopt = (int )pfound->val;
                {
#line 2550
                mem_80 = optstring + 0;
#line 2550
                if ((int const   )*mem_80 == 58) {
#line 2550
                  tmp___8 = ':';
                } else {
#line 2550
                  tmp___8 = '?';
                }
                }
#line 2550
                __retres110 = tmp___8;
#line 2550
                goto return_label;
              }
            } else {

            }
#line 2553
            tmp___9 = strlen((char const   *)nextchar);
#line 2553
            nextchar += tmp___9;
#line 2554
            if ((unsigned int )longind != (unsigned int )((void *)0)) {
#line 2555
              *longind = option_index;
            } else {

            }
#line 2556
            if (pfound->flag != 0) {
#line 2558
              mem_81 = pfound->flag;
#line 2558
              *mem_81 = (int )pfound->val;
#line 2559
              __retres110 = 0;
#line 2559
              goto return_label;
            } else {

            }
#line 2561
            __retres110 = (int )pfound->val;
#line 2561
            goto return_label;
          } else {

          }
#line 2568
          if (long_only == 0) {
#line 2568
            goto _L___4;
          } else {
            {
#line 2568
            mem_82 = argv + optind;
#line 2568
            mem_83 = *mem_82 + 1;
#line 2568
            if ((int )*mem_83 == 45) {
#line 2568
              goto _L___4;
            } else {
#line 2568
              tmp___10 = strchr(optstring, (int )*nextchar);
#line 2568
              if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
                _L___4: /* CIL Label */ 
#line 2571
                if (print_errors != 0) {
                  {
#line 2573
                  mem_84 = argv + optind;
#line 2573
                  mem_85 = *mem_84 + 1;
#line 2573
                  if ((int )*mem_85 == 45) {
#line 2575
                    mem_86 = argv + 0;
#line 2575
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: unrecognized option `--%s\'\n",
                            *mem_86, nextchar);
                  } else {
#line 2579
                    mem_87 = argv + 0;
#line 2579
                    mem_88 = argv + optind;
#line 2579
                    mem_89 = *mem_88 + 0;
#line 2579
                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: unrecognized option `%c%s\'\n",
                            *mem_87, (int )*mem_89, nextchar);
                  }
                  }
                } else {

                }
#line 2582
                nextchar = (char *)"";
#line 2583
                optind ++;
#line 2584
                optopt = 0;
#line 2585
                __retres110 = '?';
#line 2585
                goto return_label;
              } else {

              }
            }
            }
          }
        }
      }
      }
    } else {

    }
    }
  } else {

  }
#line 2592
  tmp___12 = nextchar;
#line 2592
  nextchar ++;
#line 2592
  c = *tmp___12;
#line 2593
  tmp___13 = strchr(optstring, (int )c);
#line 2593
  temp = tmp___13;
#line 2596
  if ((int )*nextchar == 0) {
#line 2597
    optind ++;
  } else {

  }
#line 2599
  if ((unsigned int )temp == (unsigned int )((void *)0)) {
#line 2599
    goto _L___7;
  } else
#line 2599
  if ((int )c == 58) {
    _L___7: /* CIL Label */ 
#line 2601
    if (print_errors != 0) {
#line 2603
      if (posixly_correct != 0) {
#line 2605
        mem_90 = argv + 0;
#line 2605
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: illegal option -- %c\n",
                *mem_90, (int )c);
      } else {
#line 2608
        mem_91 = argv + 0;
#line 2608
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: invalid option -- %c\n",
                *mem_91, (int )c);
      }
    } else {

    }
#line 2611
    optopt = (int )c;
#line 2612
    __retres110 = '?';
#line 2612
    goto return_label;
  } else {

  }
  {
#line 2615
  mem_92 = temp + 0;
#line 2615
  if ((int )*mem_92 == 87) {
    {
#line 2615
    mem_93 = temp + 1;
#line 2615
    if ((int )*mem_93 == 59) {
#line 2619
      pfound___0 = (struct option  const  *)((void *)0);
#line 2620
      exact___0 = 0;
#line 2621
      ambig___0 = 0;
#line 2622
      indfound___0 = 0;
#line 2626
      if ((int )*nextchar != 0) {
#line 2628
        optarg = nextchar;
#line 2631
        optind ++;
      } else
#line 2633
      if (optind == argc) {
#line 2635
        if (print_errors != 0) {
#line 2638
          mem_94 = argv + 0;
#line 2638
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option requires an argument -- %c\n",
                  *mem_94, (int )c);
        } else {

        }
#line 2641
        optopt = (int )c;
        {
#line 2642
        mem_95 = optstring + 0;
#line 2642
        if ((int const   )*mem_95 == 58) {
#line 2643
          c = (char )':';
        } else {
#line 2645
          c = (char )'?';
        }
        }
#line 2646
        __retres110 = (int )c;
#line 2646
        goto return_label;
      } else {
#line 2651
        tmp___14 = optind;
#line 2651
        optind ++;
#line 2651
        mem_96 = argv + tmp___14;
#line 2651
        optarg = (char *)*mem_96;
      }
#line 2656
      nameend___0 = optarg;
#line 2656
      nextchar = nameend___0;
      {
#line 2656
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2656
        if (*nameend___0 != 0) {
#line 2656
          if ((int )*nameend___0 != 61) {

          } else {
#line 2656
            goto while_break___2;
          }
        } else {
#line 2656
          goto while_break___2;
        }
#line 2656
        nameend___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2661
      p___0 = longopts;
#line 2661
      option_index___0 = 0;
      {
#line 2661
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2661
        if (p___0->name != 0) {

        } else {
#line 2661
          goto while_break___3;
        }
#line 2662
        tmp___16 = strncmp((char const   *)p___0->name, (char const   *)nextchar,
                           (size_t )(nameend___0 - nextchar));
#line 2662
        if (tmp___16 != 0) {

        } else {
#line 2664
          tmp___15 = strlen((char const   *)p___0->name);
#line 2664
          if ((unsigned int )(nameend___0 - nextchar) == tmp___15) {
#line 2667
            pfound___0 = p___0;
#line 2668
            indfound___0 = option_index___0;
#line 2669
            exact___0 = 1;
#line 2670
            goto while_break___3;
          } else
#line 2672
          if ((unsigned int )pfound___0 == (unsigned int )((void *)0)) {
#line 2675
            pfound___0 = p___0;
#line 2676
            indfound___0 = option_index___0;
          } else {
#line 2680
            ambig___0 = 1;
          }
        }
#line 2661
        p___0 ++;
#line 2661
        option_index___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2682
      if (ambig___0 != 0) {
#line 2682
        if (exact___0 == 0) {
#line 2684
          if (print_errors != 0) {
#line 2685
            mem_97 = argv + 0;
#line 2685
            mem_98 = argv + optind;
#line 2685
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option `-W %s\' is ambiguous\n",
                    *mem_97, *mem_98);
          } else {

          }
#line 2687
          tmp___17 = strlen((char const   *)nextchar);
#line 2687
          nextchar += tmp___17;
#line 2688
          optind ++;
#line 2689
          __retres110 = '?';
#line 2689
          goto return_label;
        } else {

        }
      } else {

      }
#line 2691
      if ((unsigned int )pfound___0 != (unsigned int )((void *)0)) {
#line 2693
        option_index___0 = indfound___0;
#line 2694
        if (*nameend___0 != 0) {
#line 2698
          if (pfound___0->has_arg != 0) {
#line 2699
            optarg = nameend___0 + 1;
          } else {
#line 2702
            if (print_errors != 0) {
#line 2703
              mem_99 = argv + 0;
#line 2703
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option `-W %s\' doesn\'t allow an argument\n",
                      *mem_99, pfound___0->name);
            } else {

            }
#line 2707
            tmp___18 = strlen((char const   *)nextchar);
#line 2707
            nextchar += tmp___18;
#line 2708
            __retres110 = '?';
#line 2708
            goto return_label;
          }
        } else
#line 2711
        if (pfound___0->has_arg == 1) {
#line 2713
          if (optind < argc) {
#line 2714
            tmp___19 = optind;
#line 2714
            optind ++;
#line 2714
            mem_100 = argv + tmp___19;
#line 2714
            optarg = (char *)*mem_100;
          } else {
#line 2717
            if (print_errors != 0) {
#line 2718
              mem_101 = argv + 0;
#line 2718
              mem_102 = argv + (optind - 1);
#line 2718
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option `%s\' requires an argument\n",
                      *mem_101, *mem_102);
            } else {

            }
#line 2721
            tmp___20 = strlen((char const   *)nextchar);
#line 2721
            nextchar += tmp___20;
            {
#line 2722
            mem_103 = optstring + 0;
#line 2722
            if ((int const   )*mem_103 == 58) {
#line 2722
              tmp___21 = ':';
            } else {
#line 2722
              tmp___21 = '?';
            }
            }
#line 2722
            __retres110 = tmp___21;
#line 2722
            goto return_label;
          }
        } else {

        }
#line 2725
        tmp___22 = strlen((char const   *)nextchar);
#line 2725
        nextchar += tmp___22;
#line 2726
        if ((unsigned int )longind != (unsigned int )((void *)0)) {
#line 2727
          *longind = option_index___0;
        } else {

        }
#line 2728
        if (pfound___0->flag != 0) {
#line 2730
          mem_104 = pfound___0->flag;
#line 2730
          *mem_104 = (int )pfound___0->val;
#line 2731
          __retres110 = 0;
#line 2731
          goto return_label;
        } else {

        }
#line 2733
        __retres110 = (int )pfound___0->val;
#line 2733
        goto return_label;
      } else {

      }
#line 2735
      nextchar = (char *)((void *)0);
#line 2736
      __retres110 = 'W';
#line 2736
      goto return_label;
    } else {

    }
    }
  } else {

  }
  }
  {
#line 2738
  mem_105 = temp + 1;
#line 2738
  if ((int )*mem_105 == 58) {
    {
#line 2740
    mem_106 = temp + 2;
#line 2740
    if ((int )*mem_106 == 58) {
#line 2743
      if ((int )*nextchar != 0) {
#line 2745
        optarg = nextchar;
#line 2746
        optind ++;
      } else {
#line 2749
        optarg = (char *)((void *)0);
      }
#line 2750
      nextchar = (char *)((void *)0);
    } else {
#line 2755
      if ((int )*nextchar != 0) {
#line 2757
        optarg = nextchar;
#line 2760
        optind ++;
      } else
#line 2762
      if (optind == argc) {
#line 2764
        if (print_errors != 0) {
#line 2767
          mem_107 = argv + 0;
#line 2767
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option requires an argument -- %c\n",
                  *mem_107, (int )c);
        } else {

        }
#line 2771
        optopt = (int )c;
        {
#line 2772
        mem_108 = optstring + 0;
#line 2772
        if ((int const   )*mem_108 == 58) {
#line 2773
          c = (char )':';
        } else {
#line 2775
          c = (char )'?';
        }
        }
      } else {
#line 2780
        tmp___23 = optind;
#line 2780
        optind ++;
#line 2780
        mem_109 = argv + tmp___23;
#line 2780
        optarg = (char *)*mem_109;
      }
#line 2781
      nextchar = (char *)((void *)0);
    }
    }
  } else {

  }
  }
#line 2784
  __retres110 = (int )c;
  return_label: /* CIL Label */ 
#line 2322
  return (__retres110);
}
}
#line 2788
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int argc , char * const  *argv ,
                                                                      char const   *optstring ) ;
#line 2788 "gzip.c"
int ( __attribute__((__leaf__)) getopt)(int argc , char * const  *argv , char const   *optstring ) 
{ 
  int tmp ;

  {
#line 2794
  tmp = _getopt_internal(argc, argv, optstring, (struct option  const  *)0, (int *)0,
                         0);
#line 2794
  return (tmp);
}
}
#line 2849 "gzip.c"
static char *license_msg[7]  = {      (char *)"Copyright 2002 Free Software Foundation",      (char *)"Copyright 1992-1993 Jean-loup Gailly",      (char *)"This program comes with ABSOLUTELY NO WARRANTY.",      (char *)"You may redistribute copies of this program", 
        (char *)"under the terms of the GNU General Public License.",      (char *)"For more information about these matters, see the file named COPYING.",      (char *)0};
#line 2986 "gzip.c"
int ascii  =    0;
#line 2987 "gzip.c"
int to_stdout  =    0;
#line 2988 "gzip.c"
int decompress  =    0;
#line 2989 "gzip.c"
int force  =    0;
#line 2990 "gzip.c"
int no_name  =    -1;
#line 2991 "gzip.c"
int no_time  =    -1;
#line 2992 "gzip.c"
int recursive  =    0;
#line 2993 "gzip.c"
int list  =    0;
#line 2994 "gzip.c"
int verbose  =    0;
#line 2995 "gzip.c"
int quiet  =    0;
#line 2996 "gzip.c"
int do_lzw  =    0;
#line 2997 "gzip.c"
int test  =    0;
#line 2998 "gzip.c"
int foreground  ;
#line 3000 "gzip.c"
int maxbits  =    16;
#line 3001 "gzip.c"
int method  =    8;
#line 3002 "gzip.c"
int level  =    6;
#line 3003 "gzip.c"
int exit_code  =    0;
#line 3005 "gzip.c"
int last_member  ;
#line 3006 "gzip.c"
int part_nb  ;
#line 3009 "gzip.c"
char *env  ;
#line 3010 "gzip.c"
char **args  =    (char **)((void *)0);
#line 3011 "gzip.c"
char *z_suffix  ;
#line 3012 "gzip.c"
size_t z_len  ;
#line 3016 "gzip.c"
off_t total_in  ;
#line 3017 "gzip.c"
off_t total_out  ;
#line 3020 "gzip.c"
int remove_ofname  =    0;
#line 3021 "gzip.c"
struct stat istat  ;
#line 3027 "gzip.c"
int rsync  =    0;
#line 3029 "gzip.c"
struct option longopts[25]  = 
#line 3029
  {      {"ascii", 0, (int *)0, 'a'}, 
        {"to-stdout", 0, (int *)0, 'c'}, 
        {"stdout", 0, (int *)0, 'c'}, 
        {"decompress", 0, (int *)0, 'd'}, 
        {"uncompress", 0, (int *)0, 'd'}, 
        {"force", 0, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"list", 0, (int *)0, 'l'}, 
        {"license", 0, (int *)0, 'L'}, 
        {"no-name", 0, (int *)0, 'n'}, 
        {"name", 0, (int *)0, 'N'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"recursive", 0, (int *)0, 'r'}, 
        {"suffix", 1, (int *)0, 'S'}, 
        {"test", 0, (int *)0, 't'}, 
        {"no-time", 0, (int *)0, 'T'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"fast", 0, (int *)0, '1'}, 
        {"best", 0, (int *)0, '9'}, 
        {"lzw", 0, (int *)0, 'Z'}, 
        {"bits", 1, (int *)0, 'b'}, 
        {"rsyncable", 0, (int *)0, 'R'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 3063
static void usage(void) ;
#line 3064
static void help(void) ;
#line 3065
static void license(void) ;
#line 3066
static void version(void) ;
#line 3067
static int input_eof(void) ;
#line 3068
static void treat_stdin(void) ;
#line 3069
static void treat_file(char *iname ) ;
#line 3070
static int create_outfile(void) ;
#line 3071
static int do_stat(char *name , struct stat *sbuf ) ;
#line 3072
static char *get_suffix(char *name ) ;
#line 3073
static int get_istat(char *iname , struct stat *sbuf ) ;
#line 3074
static int make_ofname(void) ;
#line 3075
static int same_file(struct stat *stat1 , struct stat *stat2 ) ;
#line 3076
static int name_too_long(char *name , struct stat *statb ) ;
#line 3077
static void shorten_name(char *name ) ;
#line 3078
static int get_method(int in ) ;
#line 3079
static void do_list(int ifd___0 , int method___0 ) ;
#line 3080
static int check_ofname(void) ;
#line 3081
static void copy_stat(struct stat *ifstat ) ;
#line 3082
static void do_exit(int exitcode ) ;
#line 3083
int main(int argc , char **argv ) ;
#line 3084 "gzip.c"
int (*work)(int infile , int outfile )  =    & zip;
#line 3087
static void treat_dir(char *dir ) ;
#line 3090
static void reset_times(char *name , struct stat *statb ) ;
#line 3096 "gzip.c"
static void usage(void) 
{ 


  {
#line 3098
  printf((char const   * __restrict  )"usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
         progname, "", "r");

#line 3096
  return;
}
}
#line 3106
static void help(void) ;
#line 3106 "gzip.c"
static char *help_msg[20]  = 
#line 3106
  {      (char *)" -c --stdout      write on standard output, keep original files unchanged",      (char *)" -d --decompress  decompress",      (char *)" -f --force       force overwrite of output file and compress links",      (char *)" -h --help        give this help", 
        (char *)" -l --list        list compressed file contents",      (char *)" -L --license     display software license",      (char *)" -n --no-name     do not save or restore the original name and time stamp",      (char *)" -N --name        save or restore the original name and time stamp", 
        (char *)" -q --quiet       suppress all warnings",      (char *)" -r --recursive   operate recursively on directories",      (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",      (char *)" -t --test        test compressed file integrity", 
        (char *)" -v --verbose     verbose mode",      (char *)" -V --version     display version number",      (char *)" -1 --fast        compress faster",      (char *)" -9 --best        compress better", 
        (char *)"    --rsyncable   Make rsync-friendly archive",      (char *)" file...          files to (de)compress. If none given, use standard input.",      (char *)"Report bugs to <bug-gzip@gnu.org>.",      (char *)0};
#line 3104 "gzip.c"
static void help(void) 
{ 
  char **p ;
  char **tmp ;

  {
#line 3142
  p = help_msg;
#line 3144
  printf((char const   * __restrict  )"%s %s\n(%s)\n", progname, "1.3.5", "2002-09-30");
#line 3145
  usage();
  {
#line 3146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3146
    if (*p != 0) {

    } else {
#line 3146
      goto while_break;
    }
#line 3146
    tmp = p;
#line 3146
    p ++;
#line 3146
    printf((char const   * __restrict  )"%s\n", *tmp);
  }
  while_break: /* CIL Label */ ;
  }

#line 3104
  return;
}
}
#line 3150 "gzip.c"
static void license(void) 
{ 
  char **p ;
  char **tmp ;

  {
#line 3152
  p = license_msg;
#line 3154
  printf((char const   * __restrict  )"%s %s\n(%s)\n", progname, "1.3.5", "2002-09-30");
  {
#line 3155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3155
    if (*p != 0) {

    } else {
#line 3155
      goto while_break;
    }
#line 3155
    tmp = p;
#line 3155
    p ++;
#line 3155
    printf((char const   * __restrict  )"%s\n", *tmp);
  }
  while_break: /* CIL Label */ ;
  }

#line 3150
  return;
}
}
#line 3159 "gzip.c"
static void version(void) 
{ 


  {
#line 3161
  license();
#line 3162
  printf((char const   * __restrict  )"Compilation options:\n%s %s ", "DIRENT", "UTIME");
#line 3164
  printf((char const   * __restrict  )"STDC_HEADERS ");
#line 3167
  printf((char const   * __restrict  )"HAVE_UNISTD_H ");
#line 3170
  printf((char const   * __restrict  )"HAVE_MEMORY_H ");
#line 3173
  printf((char const   * __restrict  )"HAVE_STRING_H ");
#line 3176
  printf((char const   * __restrict  )"HAVE_LSTAT ");
#line 3199
  printf((char const   * __restrict  )"\n");
#line 3200
  printf((char const   * __restrict  )"Written by Jean-loup Gailly.\n");

#line 3159
  return;
}
}
#line 3203 "gzip.c"
static void progerror(char *string ) 
{ 
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 3206
  tmp = __errno_location();
#line 3206
  e = *tmp;
#line 3207
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", progname);
#line 3208
  tmp___0 = __errno_location();
#line 3208
  *tmp___0 = e;
#line 3209
  perror((char const   *)string);
#line 3210
  exit_code = 1;

#line 3203
  return;
}
}
#line 3214 "gzip.c"
int main(int argc , char **argv ) 
{
  Pl_Start_Prolog(argc, argv); 
  int file_count ;
  int proglen ;
  int optc ;
  size_t tmp ;
  int tmp___0 ;
  __sighandler_t tmp___1 ;
  __sighandler_t tmp___2 ;
  __sighandler_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  __sighandler_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char **mem_18 ;
  char *mem_19 ;
  char **mem_20 ;

  {
#line 3224
  mem_18 = argv + 0;
#line 3224
  progname = base_name(*mem_18);
#line 3225
  tmp = strlen((char const   *)progname);
#line 3225
  proglen = (int )tmp;
#line 3228
  if (proglen > 4) {
#line 3228
    tmp___0 = strcmp((char const   *)((progname + proglen) - 4), ".exe");
#line 3228
    if (tmp___0 == 0) {
#line 3229
      mem_19 = progname + (proglen - 4);
#line 3229
      *mem_19 = (char )'\000';
    } else {

    }
  } else {

  }
#line 3233
  env = add_envopt(& argc, & argv, (char *)"GZIP");
#line 3234
  if ((unsigned int )env != (unsigned int )((void *)0)) {
#line 3234
    args = argv;
  } else {

  }
#line 3236
  tmp___1 = signal(2, (void (*)(int  ))1);
#line 3236
  foreground = (unsigned int )tmp___1 != (unsigned int )((void (*)(int  ))1);
#line 3237
  if (foreground != 0) {
#line 3238
    signal(2, (void (*)(int  ))(& abort_gzip_signal));
  } else {

  }
#line 3241
  tmp___2 = signal(15, (void (*)(int  ))1);
#line 3241
  if ((unsigned int )tmp___2 != (unsigned int )((void (*)(int  ))1)) {
#line 3242
    signal(15, (void (*)(int  ))(& abort_gzip_signal));
  } else {

  }
#line 3246
  tmp___3 = signal(1, (void (*)(int  ))1);
#line 3246
  if ((unsigned int )tmp___3 != (unsigned int )((void (*)(int  ))1)) {
#line 3247
    signal(1, (void (*)(int  ))(& abort_gzip_signal));
  } else {

  }
#line 3259
  tmp___6 = strncmp((char const   *)progname, "un", (size_t )2);
#line 3259
  if (tmp___6 == 0) {
#line 3261
    decompress = 1;
  } else {
#line 3259
    tmp___7 = strncmp((char const   *)progname, "gun", (size_t )3);
#line 3259
    if (tmp___7 == 0) {
#line 3261
      decompress = 1;
    } else {
#line 3262
      tmp___4 = strcmp((char const   *)(progname + 1), "cat");
#line 3262
      if (tmp___4 == 0) {
#line 3264
        to_stdout = 1;
#line 3264
        decompress = to_stdout;
      } else {
#line 3262
        tmp___5 = strcmp((char const   *)progname, "gzcat");
#line 3262
        if (tmp___5 == 0) {
#line 3264
          to_stdout = 1;
#line 3264
          decompress = to_stdout;
        } else {

        }
      }
    }
  }
#line 3268
  z_suffix = (char *)".gz";
#line 3269
  z_len = strlen((char const   *)z_suffix);
  {
#line 3271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3271
    optc = getopt_long(argc, (char * const  *)argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
                       (struct option  const  *)(longopts), (int *)0);
#line 3271
    if (optc != -1) {

    } else {
#line 3271
      goto while_break;
    }
    {
#line 3274
    if (optc == 97) {
#line 3274
      goto case_97;
    } else {

    }
#line 3276
    if (optc == 98) {
#line 3276
      goto case_98;
    } else {

    }
#line 3287
    if (optc == 99) {
#line 3287
      goto case_99;
    } else {

    }
#line 3289
    if (optc == 100) {
#line 3289
      goto case_100;
    } else {

    }
#line 3291
    if (optc == 102) {
#line 3291
      goto case_102;
    } else {

    }
#line 3293
    if (optc == 63) {
#line 3293
      goto case_63;
    } else {

    }
#line 3293
    if (optc == 72) {
#line 3293
      goto case_63;
    } else {

    }
#line 3293
    if (optc == 104) {
#line 3293
      goto case_63;
    } else {

    }
#line 3295
    if (optc == 108) {
#line 3295
      goto case_108;
    } else {

    }
#line 3297
    if (optc == 76) {
#line 3297
      goto case_76;
    } else {

    }
#line 3299
    if (optc == 109) {
#line 3299
      goto case_109;
    } else {

    }
#line 3301
    if (optc == 77) {
#line 3301
      goto case_77;
    } else {

    }
#line 3303
    if (optc == 110) {
#line 3303
      goto case_110;
    } else {

    }
#line 3305
    if (optc == 78) {
#line 3305
      goto case_78;
    } else {

    }
#line 3307
    if (optc == 113) {
#line 3307
      goto case_113;
    } else {

    }
#line 3309
    if (optc == 114) {
#line 3309
      goto case_114;
    } else {

    }
#line 3317
    if (optc == 82) {
#line 3317
      goto case_82;
    } else {

    }
#line 3320
    if (optc == 83) {
#line 3320
      goto case_83;
    } else {

    }
#line 3327
    if (optc == 116) {
#line 3327
      goto case_116;
    } else {

    }
#line 3330
    if (optc == 118) {
#line 3330
      goto case_118;
    } else {

    }
#line 3332
    if (optc == 86) {
#line 3332
      goto case_86;
    } else {

    }
#line 3334
    if (optc == 90) {
#line 3334
      goto case_90;
    } else {

    }
#line 3344
    if (optc == 57) {
#line 3344
      goto case_57;
    } else {

    }
#line 3344
    if (optc == 56) {
#line 3344
      goto case_57;
    } else {

    }
#line 3344
    if (optc == 55) {
#line 3344
      goto case_57;
    } else {

    }
#line 3344
    if (optc == 54) {
#line 3344
      goto case_57;
    } else {

    }
#line 3344
    if (optc == 53) {
#line 3344
      goto case_57;
    } else {

    }
#line 3343
    if (optc == 52) {
#line 3343
      goto case_57;
    } else {

    }
#line 3343
    if (optc == 51) {
#line 3343
      goto case_57;
    } else {

    }
#line 3343
    if (optc == 50) {
#line 3343
      goto case_57;
    } else {

    }
#line 3343
    if (optc == 49) {
#line 3343
      goto case_57;
    } else {

    }
#line 3347
    goto switch_default;
    case_97: /* CIL Label */ 
#line 3275
    ascii = 1;
#line 3275
    goto switch_break;
    case_98: /* CIL Label */ 
#line 3277
    maxbits = atoi((char const   *)optarg);
    {
#line 3278
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3278
      if (*optarg != 0) {

      } else {
#line 3278
        goto while_break___0;
      }
#line 3279
      if (48 <= (int )*optarg) {
#line 3279
        if ((int )*optarg <= 57) {

        } else {
#line 3281
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: -b operand is not an integer\n",
                  progname);
#line 3283
          usage();
#line 3284
          do_exit(1);
        }
      } else {
#line 3281
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: -b operand is not an integer\n",
                progname);
#line 3283
        usage();
#line 3284
        do_exit(1);
      }
#line 3278
      optarg ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3286
    goto switch_break;
    case_99: /* CIL Label */ 
#line 3288
    to_stdout = 1;
#line 3288
    goto switch_break;
    case_100: /* CIL Label */ 
#line 3290
    decompress = 1;
#line 3290
    goto switch_break;
    case_102: /* CIL Label */ 
#line 3292
    force ++;
#line 3292
    goto switch_break;
    case_63: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
#line 3294
    help();
#line 3294
    do_exit(0);
#line 3294
    goto switch_break;
    case_108: /* CIL Label */ 
#line 3296
    to_stdout = 1;
#line 3296
    decompress = to_stdout;
#line 3296
    list = decompress;
#line 3296
    goto switch_break;
    case_76: /* CIL Label */ 
#line 3298
    license();
#line 3298
    do_exit(0);
#line 3298
    goto switch_break;
    case_109: /* CIL Label */ 
#line 3300
    no_time = 1;
#line 3300
    goto switch_break;
    case_77: /* CIL Label */ 
#line 3302
    no_time = 0;
#line 3302
    goto switch_break;
    case_110: /* CIL Label */ 
#line 3304
    no_time = 1;
#line 3304
    no_name = no_time;
#line 3304
    goto switch_break;
    case_78: /* CIL Label */ 
#line 3306
    no_time = 0;
#line 3306
    no_name = no_time;
#line 3306
    goto switch_break;
    case_113: /* CIL Label */ 
#line 3308
    quiet = 1;
#line 3308
    verbose = 0;
#line 3308
    goto switch_break;
    case_114: /* CIL Label */ 
#line 3315
    recursive = 1;
#line 3315
    goto switch_break;
    case_82: /* CIL Label */ 
#line 3318
    rsync = 1;
#line 3318
    goto switch_break;
    case_83: /* CIL Label */ 
#line 3324
    z_len = strlen((char const   *)optarg);
#line 3325
    z_suffix = optarg;
#line 3326
    goto switch_break;
    case_116: /* CIL Label */ 
#line 3328
    to_stdout = 1;
#line 3328
    decompress = to_stdout;
#line 3328
    test = decompress;
#line 3329
    goto switch_break;
    case_118: /* CIL Label */ 
#line 3331
    verbose ++;
#line 3331
    quiet = 0;
#line 3331
    goto switch_break;
    case_86: /* CIL Label */ 
#line 3333
    version();
#line 3333
    do_exit(0);
#line 3333
    goto switch_break;
    case_90: /* CIL Label */ 
#line 3338
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: -Z not supported in this version\n",
            progname);
#line 3340
    usage();
#line 3341
    do_exit(1);
#line 3341
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 3345
    level = optc - 48;
#line 3346
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3349
    usage();
#line 3350
    do_exit(1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3356
  if (quiet != 0) {
#line 3356
    tmp___8 = signal(13, (void (*)(int  ))1);
#line 3356
    if ((unsigned int )tmp___8 != (unsigned int )((void (*)(int  ))1)) {
#line 3357
      signal(13, (void (*)(int  ))(& abort_gzip_signal));
    } else {

    }
  } else {

  }
#line 3363
  if (no_time < 0) {
#line 3363
    no_time = decompress;
  } else {

  }
#line 3364
  if (no_name < 0) {
#line 3364
    no_name = decompress;
  } else {

  }
#line 3366
  file_count = argc - optind;
#line 3370
  if (ascii != 0) {
#line 3370
    if (quiet == 0) {
#line 3371
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: option --ascii ignored on this system\n",
              progname);
    } else {

    }
  } else {

  }
#line 3375
  if (z_len == 0U) {
#line 3375
    if (decompress == 0) {
#line 3376
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: incorrect suffix \'%s\'\n",
              progname, z_suffix);
#line 3378
      do_exit(1);
    } else {
#line 3375
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3375
  if (z_len > 30U) {
#line 3376
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: incorrect suffix \'%s\'\n",
            progname, z_suffix);
#line 3378
    do_exit(1);
  } else {

  }
#line 3380
  if (do_lzw != 0) {
#line 3380
    if (decompress == 0) {
#line 3380
      work = & lzw;
    } else {

    }
  } else {

  }
#line 3395
  if (file_count != 0) {
#line 3396
    if (to_stdout != 0) {
#line 3396
      if (test == 0) {
#line 3396
        if (list == 0) {
#line 3396
          if (decompress == 0) {
#line 3396
            tmp___9 = 1;
          } else
#line 3396
          if (ascii == 0) {
#line 3396
            tmp___9 = 1;
          } else {
#line 3396
            tmp___9 = 0;
          }
        } else {
#line 3396
          tmp___9 = 0;
        }
      } else {
#line 3396
        tmp___9 = 0;
      }
    } else {
#line 3396
      tmp___9 = 0;
    }
    {
#line 3399
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3399
      if (optind < argc) {

      } else {
#line 3399
        goto while_break___1;
      }
#line 3400
      tmp___10 = optind;
#line 3400
      optind ++;
#line 3400
      mem_20 = argv + tmp___10;
#line 3400
      treat_file(*mem_20);
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 3403
    treat_stdin();
  }
#line 3405
  if (list != 0) {
#line 3405
    if (quiet == 0) {
#line 3405
      if (file_count > 1) {
#line 3406
        do_list(-1, -1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 3408
  do_exit(exit_code);
  Pl_Stop_Prolog();
#line 3409
  return (exit_code);
}
}
#line 3413 "gzip.c"
static int input_eof(void) 
{ 
  int tmp ;
  int __retres2 ;

  {
#line 3416
  if (decompress == 0) {
#line 3417
    __retres2 = 1;
#line 3417
    goto return_label;
  } else
#line 3416
  if (last_member != 0) {
#line 3417
    __retres2 = 1;
#line 3417
    goto return_label;
  } else {

  }
#line 3419
  if (inptr == insize) {
#line 3421
    if (insize != 32768U) {
#line 3422
      __retres2 = 1;
#line 3422
      goto return_label;
    } else {
#line 3421
      tmp = fill_inbuf(1);
#line 3421
      if (tmp == -1) {
#line 3422
        __retres2 = 1;
#line 3422
        goto return_label;
      } else {

      }
    }
#line 3425
    inptr = 0U;
  } else {

  }
#line 3428
  __retres2 = 0;
  return_label: /* CIL Label */ 
#line 3413
  return (__retres2);
}
}
#line 3434 "gzip.c"
static void treat_stdin(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  struct _IO_FILE *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 3436
  if (force == 0) {
#line 3436
    if (list == 0) {
#line 3436
      if (decompress != 0) {
#line 3436
        tmp___1 = stdin;
      } else {
#line 3436
        tmp___1 = stdout;
      }
#line 3436
      tmp___2 = fileno(tmp___1);
#line 3436
      tmp___3 = isatty(tmp___2);
#line 3436
      if (tmp___3 != 0) {
#line 3450
        if (decompress != 0) {
#line 3450
          tmp = "de";
        } else {
#line 3450
          tmp = "";
        }
#line 3450
        if (decompress != 0) {
#line 3450
          tmp___0 = "read from";
        } else {
#line 3450
          tmp___0 = "written to";
        }
#line 3450
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
                progname, tmp___0, tmp);
#line 3454
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"For help, type: %s -h\n",
                progname);
#line 3455
        do_exit(1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 3458
  if (decompress != 0) {
#line 3458
    tmp___4 = 1;
  } else
#line 3458
  if (ascii == 0) {
#line 3458
    tmp___4 = 1;
  } else {
#line 3458
    tmp___4 = 0;
  }
#line 3461
  if (test == 0) {
#line 3461
    if (list == 0) {
#line 3461
      if (decompress == 0) {
#line 3461
        tmp___5 = 1;
      } else
#line 3461
      if (ascii == 0) {
#line 3461
        tmp___5 = 1;
      } else {
#line 3461
        tmp___5 = 0;
      }
    } else {
#line 3461
      tmp___5 = 0;
    }
  } else {
#line 3461
    tmp___5 = 0;
  }
#line 3464
  strcpy((char * __restrict  )(ifname), (char const   * __restrict  )"stdin");
#line 3465
  strcpy((char * __restrict  )(ofname), (char const   * __restrict  )"stdout");
#line 3468
  time_stamp = (time_t )0;
#line 3471
  if (list != 0) {
#line 3471
    goto _L;
  } else
#line 3471
  if (no_time == 0) {
    _L: /* CIL Label */ 
#line 3472
    tmp___6 = fileno(stdin);
#line 3472
    tmp___7 = fstat(tmp___6, & istat);
#line 3472
    if (tmp___7 != 0) {
#line 3473
      progerror((char *)"standard input");
#line 3474
      do_exit(1);
    } else {

    }
#line 3479
    time_stamp = istat.st_mtim.tv_sec;
  } else {

  }
#line 3482
  ifile_size = -1L;
#line 3484
  clear_bufs();
#line 3485
  to_stdout = 1;
#line 3486
  part_nb = 0;
#line 3488
  if (decompress != 0) {
#line 3489
    method = get_method(ifd);
#line 3490
    if (method < 0) {
#line 3491
      do_exit(exit_code);
    } else {

    }
  } else {

  }
#line 3494
  if (list != 0) {
#line 3495
    do_list(ifd, method);

#line 3496
    goto return_label;
  } else {

  }
  {
#line 3501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3502
    tmp___8 = fileno(stdout);
#line 3502
    tmp___9 = fileno(stdin);
#line 3502
    tmp___10 = (*work)(tmp___9, tmp___8);
#line 3502
    if (tmp___10 != 0) {

#line 3502
      goto return_label;
    } else {

    }
#line 3504
    tmp___11 = input_eof();
#line 3504
    if (tmp___11 != 0) {
#line 3505
      goto while_break;
    } else {

    }
#line 3507
    method = get_method(ifd);
#line 3508
    if (method < 0) {

#line 3508
      goto return_label;
    } else {

    }
#line 3509
    bytes_out = (off_t )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 3512
  if (verbose != 0) {
#line 3513
    if (test != 0) {
#line 3514
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" OK\n");
    } else
#line 3516
    if (decompress == 0) {
#line 3517
      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
#line 3518
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    } else {

    }
  } else {

  }

  return_label: /* CIL Label */ 
#line 3434
  return;
}
}
#line 3531 "gzip.c"
static void treat_file(char *iname ) 
{ 
  int cflag ;
  int tmp ;
  int tmp___0 ;
  struct stat st ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 3535
  tmp = strcmp((char const   *)iname, "-");
#line 3535
  if (tmp == 0) {
#line 3536
    cflag = to_stdout;
#line 3537
    treat_stdin();
#line 3538
    to_stdout = cflag;

#line 3539
    goto return_label;
  } else {

  }
#line 3543
  tmp___0 = get_istat(iname, & istat);
#line 3543
  if (tmp___0 != 0) {

#line 3543
    goto return_label;
  } else {

  }
#line 3546
  if ((istat.st_mode & 61440U) == 16384U) {
#line 3548
    if (recursive != 0) {
#line 3550
      st = istat;
#line 3551
      treat_dir(iname);
#line 3554
      reset_times(iname, & st);
    } else {
#line 3558
      if (quiet == 0) {
#line 3558
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is a directory -- ignored\n",
                progname, ifname);
      } else {

      }
#line 3558
      if (exit_code == 0) {
#line 3558
        exit_code = 2;
      } else {

      }
    }

#line 3559
    goto return_label;
  } else {

  }
#line 3561
  if ((istat.st_mode & 61440U) != 32768U) {
#line 3562
    if (quiet == 0) {
#line 3562
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is not a directory or a regular file - ignored\n",
              progname, ifname);
    } else {

    }
#line 3562
    if (exit_code == 0) {
#line 3562
      exit_code = 2;
    } else {

    }

#line 3565
    goto return_label;
  } else {

  }
#line 3567
  if (istat.st_nlink > 1U) {
#line 3567
    if (to_stdout == 0) {
#line 3567
      if (force == 0) {
#line 3568
        if (quiet == 0) {
#line 3568
          if (istat.st_nlink > 2U) {
#line 3568
            tmp___1 = 's';
          } else {
#line 3568
            tmp___1 = ' ';
          }
#line 3568
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s has %lu other link%c -- unchanged\n",
                  progname, ifname, (unsigned long )istat.st_nlink - 1UL, tmp___1);
        } else {

        }
#line 3568
        if (exit_code == 0) {
#line 3568
          exit_code = 2;
        } else {

        }

#line 3571
        goto return_label;
      } else {

      }
    } else {

    }
  } else {

  }
#line 3574
  ifile_size = istat.st_size;
#line 3575
  if (no_time != 0) {
#line 3575
    if (list == 0) {
#line 3575
      time_stamp = (time_t )0;
    } else {
#line 3575
      time_stamp = istat.st_mtim.tv_sec;
    }
  } else {
#line 3575
    time_stamp = istat.st_mtim.tv_sec;
  }
#line 3580
  if (to_stdout != 0) {
#line 3580
    if (list == 0) {
#line 3580
      if (test == 0) {
#line 3581
        strcpy((char * __restrict  )(ofname), (char const   * __restrict  )"stdout");
      } else {
#line 3580
        goto _L___0;
      }
    } else {
#line 3580
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 3583
    tmp___2 = make_ofname();
#line 3583
    if (tmp___2 != 0) {

#line 3584
      goto return_label;
    } else {

    }
  }
#line 3591
  if (ascii != 0) {
#line 3591
    if (decompress == 0) {
#line 3591
      tmp___3 = 0;
    } else {
#line 3591
      tmp___3 = 0;
    }
  } else {
#line 3591
    tmp___3 = 0;
  }
#line 3591
  ifd = open((char const   *)(ifname), tmp___3, 384);
#line 3593
  if (ifd == -1) {
#line 3594
    progerror(ifname);

#line 3595
    goto return_label;
  } else {

  }
#line 3597
  clear_bufs();
#line 3598
  part_nb = 0;
#line 3600
  if (decompress != 0) {
#line 3601
    method = get_method(ifd);
#line 3602
    if (method < 0) {
#line 3603
      close(ifd);

#line 3604
      goto return_label;
    } else {

    }
  } else {

  }
#line 3607
  if (list != 0) {
#line 3608
    do_list(ifd, method);
#line 3609
    close(ifd);

#line 3610
    goto return_label;
  } else {

  }
#line 3617
  if (to_stdout != 0) {
#line 3618
    ofd = fileno(stdout);
  } else {
#line 3621
    tmp___4 = create_outfile();
#line 3621
    if (tmp___4 != 0) {

#line 3621
      goto return_label;
    } else {

    }
#line 3623
    if (decompress == 0) {
#line 3623
      if (save_orig_name != 0) {
#line 3623
        if (verbose == 0) {
#line 3623
          if (quiet == 0) {
#line 3624
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s compressed to %s\n",
                    progname, ifname, ofname);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  }
#line 3629
  if (save_orig_name == 0) {
#line 3629
    save_orig_name = ! no_name;
  } else {

  }
#line 3631
  if (verbose != 0) {
#line 3632
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:\t", ifname);
  } else {

  }
  {
#line 3637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3638
    tmp___5 = (*work)(ifd, ofd);
#line 3638
    if (tmp___5 != 0) {
#line 3639
      method = -1;
#line 3640
      goto while_break;
    } else {

    }
#line 3643
    tmp___6 = input_eof();
#line 3643
    if (tmp___6 != 0) {
#line 3644
      goto while_break;
    } else {

    }
#line 3646
    method = get_method(ifd);
#line 3647
    if (method < 0) {
#line 3647
      goto while_break;
    } else {

    }
#line 3648
    bytes_out = (off_t )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 3651
  close(ifd);
#line 3652
  if (to_stdout == 0) {
#line 3654
    copy_stat(& istat);
#line 3655
    tmp___7 = close(ofd);
#line 3655
    if (tmp___7 != 0) {
#line 3656
      write_error();
    } else {

    }
  } else {

  }
#line 3658
  if (method == -1) {
#line 3659
    if (to_stdout == 0) {
#line 3659
      xunlink(ofname);
    } else {

    }

#line 3660
    goto return_label;
  } else {

  }
#line 3663
  if (verbose != 0) {
#line 3664
    if (test != 0) {
#line 3665
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" OK");
    } else
#line 3666
    if (decompress != 0) {
#line 3667
      display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stderr);
    } else {
#line 3669
      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
    }
#line 3671
    if (test == 0) {
#line 3671
      if (to_stdout == 0) {
#line 3672
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" -- replaced with %s",
                ofname);
      } else {

      }
    } else {

    }
#line 3674
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  } else {

  }

  return_label: /* CIL Label */ 
#line 3531
  return;
}
}
#line 3687 "gzip.c"
static int create_outfile(void) 
{ 
  struct stat ostat ;
  int flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __retres6 ;

  {
#line 3690
  flags = 193;
#line 3692
  if (ascii != 0) {
#line 3692
    if (decompress != 0) {
#line 3693
      flags &= -1;
    } else {

    }
  } else {

  }
  {
#line 3695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3697
    tmp = check_ofname();
#line 3697
    if (tmp != 0) {
#line 3698
      close(ifd);
#line 3699
      __retres6 = 1;
#line 3699
      goto return_label;
    } else {

    }
#line 3702
    remove_ofname = 1;
#line 3703
    ofd = open((char const   *)(ofname), flags, 384);
#line 3704
    if (ofd == -1) {
#line 3705
      progerror(ofname);
#line 3706
      close(ifd);
#line 3707
      __retres6 = 1;
#line 3707
      goto return_label;
    } else {

    }
#line 3714
    tmp___0 = fstat(ofd, & ostat);
#line 3714
    if (tmp___0 != 0) {
#line 3716
      progerror(ofname);
#line 3717
      close(ifd);
#line 3717
      close(ofd);
#line 3718
      xunlink(ofname);
#line 3719
      __retres6 = 1;
#line 3719
      goto return_label;
    } else {

    }
#line 3721
    tmp___1 = name_too_long(ofname, & ostat);
#line 3721
    if (tmp___1 != 0) {

    } else {
#line 3721
      __retres6 = 0;
#line 3721
      goto return_label;
    }
#line 3723
    if (decompress != 0) {
#line 3725
      if (quiet == 0) {
#line 3725
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: warning, name truncated\n",
                progname, ofname);
      } else {

      }
#line 3725
      if (exit_code == 0) {
#line 3725
        exit_code = 2;
      } else {

      }
#line 3727
      __retres6 = 0;
#line 3727
      goto return_label;
    } else {

    }
#line 3729
    close(ofd);
#line 3730
    xunlink(ofname);
#line 3736
    shorten_name(ofname);
  }
  while_break: /* CIL Label */ ;
  }
  return_label: /* CIL Label */ 
#line 3687
  return (__retres6);
}
}
#line 3744 "gzip.c"
static int do_stat(char *name , struct stat *sbuf ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __retres6 ;

  {
#line 3748
  tmp = __errno_location();
#line 3748
  *tmp = 0;
#line 3749
  if (to_stdout == 0) {
#line 3749
    if (force == 0) {
#line 3750
      tmp___0 = lstat((char const   * __restrict  )name, (struct stat * __restrict  )sbuf);
#line 3750
      __retres6 = tmp___0;
#line 3750
      goto return_label;
    } else {

    }
  } else {

  }
#line 3752
  tmp___1 = stat((char const   * __restrict  )name, (struct stat * __restrict  )sbuf);
#line 3752
  __retres6 = tmp___1;
  return_label: /* CIL Label */ 
#line 3744
  return (__retres6);
}
}
#line 3772
static char *get_suffix(char *name ) ;
#line 3772 "gzip.c"
static char *known_suffixes[9]  = 
#line 3772
  {      (char *)((void *)0),      (char *)".gz",      (char *)".z",      (char *)".taz", 
        (char *)".tgz",      (char *)"-gz",      (char *)"-z",      (char *)"_z", 
        (char *)((void *)0)};
#line 3767 "gzip.c"
static char *get_suffix(char *name ) 
{ 
  int nlen ;
  int slen ;
  char suffix[33] ;
  char **suf ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int s ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__retres12 ;

  {
#line 3778
  suf = known_suffixes;
#line 3780
  *suf = z_suffix;
#line 3781
  tmp = strcmp((char const   *)z_suffix, "z");
#line 3781
  if (tmp == 0) {
#line 3781
    suf ++;
  } else {

  }
#line 3790
  tmp___0 = strlen((char const   *)name);
#line 3790
  nlen = (int )tmp___0;
#line 3791
  if (nlen <= 32) {
#line 3792
    strcpy((char * __restrict  )(suffix), (char const   * __restrict  )name);
  } else {
#line 3794
    strcpy((char * __restrict  )(suffix), (char const   * __restrict  )(((name + nlen) - 30) - 2));
  }
#line 3796
  strlwr(suffix);
#line 3797
  tmp___1 = strlen((char const   *)(suffix));
#line 3797
  slen = (int )tmp___1;
  {
#line 3798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3799
    tmp___2 = strlen((char const   *)*suf);
#line 3799
    s = (int )tmp___2;
#line 3800
    if (slen > s) {
#line 3800
      if ((int )suffix[(slen - s) - 1] != 47) {
#line 3800
        tmp___3 = strcmp((char const   *)((suffix + slen) - s), (char const   *)*suf);
#line 3800
        if (tmp___3 == 0) {
#line 3802
          __retres12 = (name + nlen) - s;
#line 3802
          goto return_label;
        } else {

        }
      } else {

      }
    } else {

    }
#line 3798
    suf ++;
#line 3798
    if ((unsigned int )*suf != (unsigned int )((void *)0)) {

    } else {
#line 3798
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3806
  __retres12 = (char *)((void *)0);
  return_label: /* CIL Label */ 
#line 3767
  return (__retres12);
}
}
#line 3823
static int get_istat(char *iname , struct stat *sbuf ) ;
#line 3823 "gzip.c"
static char *suffixes[6]  = {      (char *)((void *)0),      (char *)".gz",      (char *)".z",      (char *)"-z", 
        (char *)".Z",      (char *)((void *)0)};
#line 3817 "gzip.c"
static int get_istat(char *iname , struct stat *sbuf ) 
{ 
  int ilen ;
  int z_suffix_errno ;
  char **suf ;
  char *s ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *s0 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int __retres18 ;

  {
#line 3822
  z_suffix_errno = 0;
#line 3824
  suf = suffixes;
#line 3830
  *suf = z_suffix;
#line 3832
  tmp = strlen((char const   *)iname);
#line 3832
  if (sizeof(ifname) - 1U <= tmp) {
#line 3833
    goto name_too_long;
  } else {

  }
#line 3835
  strcpy((char * __restrict  )(ifname), (char const   * __restrict  )iname);
#line 3838
  tmp___0 = do_stat(ifname, sbuf);
#line 3838
  if (tmp___0 == 0) {
#line 3838
    __retres18 = 0;
#line 3838
    goto return_label;
  } else {

  }
#line 3840
  if (decompress == 0) {
#line 3841
    progerror(ifname);
#line 3842
    __retres18 = 1;
#line 3842
    goto return_label;
  } else {
#line 3840
    tmp___1 = __errno_location();
#line 3840
    if (*tmp___1 != 2) {
#line 3841
      progerror(ifname);
#line 3842
      __retres18 = 1;
#line 3842
      goto return_label;
    } else {

    }
  }
#line 3847
  s = get_suffix(ifname);
#line 3848
  if ((unsigned int )s != (unsigned int )((void *)0)) {
#line 3849
    progerror(ifname);
#line 3850
    __retres18 = 1;
#line 3850
    goto return_label;
  } else {

  }
#line 3859
  tmp___2 = strlen((char const   *)(ifname));
#line 3859
  ilen = (int )tmp___2;
#line 3860
  tmp___3 = strcmp((char const   *)z_suffix, ".gz");
#line 3860
  if (tmp___3 == 0) {
#line 3860
    suf ++;
  } else {

  }
  {
#line 3863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3864
    s = *suf;
#line 3864
    s0 = s;
#line 3865
    strcpy((char * __restrict  )(ifname), (char const   * __restrict  )iname);
#line 3874
    tmp___4 = strlen((char const   *)s);
#line 3874
    if (sizeof(ifname) <= (size_t )ilen + tmp___4) {
#line 3875
      goto name_too_long;
    } else {

    }
#line 3876
    strcat((char * __restrict  )(ifname), (char const   * __restrict  )s);
#line 3877
    tmp___5 = do_stat(ifname, sbuf);
#line 3877
    if (tmp___5 == 0) {
#line 3877
      __retres18 = 0;
#line 3877
      goto return_label;
    } else {

    }
#line 3878
    tmp___7 = strcmp((char const   *)s0, (char const   *)z_suffix);
#line 3878
    if (tmp___7 == 0) {
#line 3879
      tmp___6 = __errno_location();
#line 3879
      z_suffix_errno = *tmp___6;
    } else {

    }
#line 3863
    suf ++;
#line 3863
    if ((unsigned int )*suf != (unsigned int )((void *)0)) {

    } else {
#line 3863
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3883
  strcpy((char * __restrict  )(ifname), (char const   * __restrict  )iname);
#line 3891
  strcat((char * __restrict  )(ifname), (char const   * __restrict  )z_suffix);
#line 3892
  tmp___8 = __errno_location();
#line 3892
  *tmp___8 = z_suffix_errno;
#line 3893
  progerror(ifname);
#line 3894
  __retres18 = 1;
#line 3894
  goto return_label;
  name_too_long: 
#line 3897
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: file name too long\n",
          progname, iname);
#line 3898
  exit_code = 1;
#line 3899
  __retres18 = 1;
  return_label: /* CIL Label */ 
#line 3817
  return (__retres18);
}
}
#line 3906 "gzip.c"
static int make_ofname(void) 
{ 
  char *suff ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int __retres5 ;

  {
#line 3910
  strcpy((char * __restrict  )(ofname), (char const   * __restrict  )(ifname));
#line 3912
  suff = get_suffix(ofname);
#line 3914
  if (decompress != 0) {
#line 3915
    if ((unsigned int )suff == (unsigned int )((void *)0)) {
#line 3919
      if (recursive == 0) {
#line 3919
        if (list != 0) {
#line 3919
          __retres5 = 0;
#line 3919
          goto return_label;
        } else
#line 3919
        if (test != 0) {
#line 3919
          __retres5 = 0;
#line 3919
          goto return_label;
        } else {

        }
      } else {

      }
#line 3922
      if (verbose != 0) {
#line 3922
        goto _L;
      } else
#line 3922
      if (recursive == 0) {
#line 3922
        if (quiet == 0) {
          _L: /* CIL Label */ 
#line 3923
          if (quiet == 0) {
#line 3923
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: unknown suffix -- ignored\n",
                    progname, ifname);
          } else {

          }
#line 3923
          if (exit_code == 0) {
#line 3923
            exit_code = 2;
          } else {

          }
        } else {

        }
      } else {

      }
#line 3926
      __retres5 = 2;
#line 3926
      goto return_label;
    } else {

    }
#line 3929
    strlwr(suff);
#line 3930
    tmp = strcmp((char const   *)suff, ".tgz");
#line 3930
    if (tmp == 0) {
#line 3931
      strcpy((char * __restrict  )suff, (char const   * __restrict  )".tar");
    } else {
#line 3930
      tmp___0 = strcmp((char const   *)suff, ".taz");
#line 3930
      if (tmp___0 == 0) {
#line 3931
        strcpy((char * __restrict  )suff, (char const   * __restrict  )".tar");
      } else {
#line 3933
        *suff = (char )'\000';
      }
    }
  } else
#line 3937
  if ((unsigned int )suff != (unsigned int )((void *)0)) {
#line 3939
    if (verbose != 0) {
#line 3941
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s already has %s suffix -- unchanged\n",
              progname, ifname, suff);
    } else
#line 3939
    if (recursive == 0) {
#line 3939
      if (quiet == 0) {
#line 3941
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s already has %s suffix -- unchanged\n",
                progname, ifname, suff);
      } else {

      }
    } else {

    }
#line 3944
    __retres5 = 2;
#line 3944
    goto return_label;
  } else {
#line 3946
    save_orig_name = 0;
#line 3971
    tmp___1 = strlen((char const   *)(ofname));
#line 3971
    if (sizeof(ofname) <= tmp___1 + z_len) {
#line 3972
      goto name_too_long;
    } else {

    }
#line 3973
    strcat((char * __restrict  )(ofname), (char const   * __restrict  )z_suffix);
  }
#line 3976
  __retres5 = 0;
#line 3976
  goto return_label;
  name_too_long: 
#line 3979
  if (quiet == 0) {
#line 3979
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: file name too long\n",
            progname, ifname);
  } else {

  }
#line 3979
  if (exit_code == 0) {
#line 3979
    exit_code = 2;
  } else {

  }
#line 3980
  __retres5 = 2;
  return_label: /* CIL Label */ 
#line 3906
  return (__retres5);
}
}
#line 3995 "gzip.c"
static int get_method(int in ) 
{ 
  uch flags ;
  char magic[2] ;
  int imagic1 ;
  ulg stamp ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  unsigned int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int part ;
  unsigned int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  unsigned int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  unsigned int len ;
  unsigned int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  unsigned int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  char c ;
  unsigned int tmp___44 ;
  int tmp___45 ;
  char *p ;
  char *tmp___46 ;
  char *base ;
  char *base2 ;
  unsigned int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  unsigned int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int inbyte ;
  unsigned int tmp___62 ;
  int tmp___63 ;
  int __retres78 ;

  {
#line 4006
  if (force != 0) {
#line 4006
    if (to_stdout != 0) {
#line 4007
      if (inptr < insize) {
#line 4007
        tmp = inptr;
#line 4007
        inptr ++;
#line 4007
        tmp___1 = (int )inbuf[tmp];
      } else {
#line 4007
        tmp___0 = fill_inbuf(1);
#line 4007
        tmp___1 = tmp___0;
      }
#line 4007
      magic[0] = (char )tmp___1;
#line 4008
      if (inptr < insize) {
#line 4008
        tmp___2 = inptr;
#line 4008
        inptr ++;
#line 4008
        imagic1 = (int )inbuf[tmp___2];
      } else {
#line 4008
        tmp___3 = fill_inbuf(1);
#line 4008
        imagic1 = tmp___3;
      }
#line 4009
      magic[1] = (char )imagic1;
    } else {
#line 4006
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 4012
    if (inptr < insize) {
#line 4012
      tmp___4 = inptr;
#line 4012
      inptr ++;
#line 4012
      tmp___6 = (int )inbuf[tmp___4];
    } else {
#line 4012
      tmp___5 = fill_inbuf(0);
#line 4012
      tmp___6 = tmp___5;
    }
#line 4012
    magic[0] = (char )tmp___6;
#line 4013
    if (inptr < insize) {
#line 4013
      tmp___7 = inptr;
#line 4013
      inptr ++;
#line 4013
      tmp___9 = (int )inbuf[tmp___7];
    } else {
#line 4013
      tmp___8 = fill_inbuf(0);
#line 4013
      tmp___9 = tmp___8;
    }
#line 4013
    magic[1] = (char )tmp___9;
#line 4014
    imagic1 = 0;
  }
#line 4016
  method = -1;
#line 4017
  part_nb ++;
#line 4018
  header_bytes = (off_t )0;
#line 4019
  last_member = 0;
#line 4022
  tmp___60 = memcmp((void const   *)(magic), (void const   *)"\037\213", (size_t )2);
#line 4022
  if (tmp___60 == 0) {
#line 4022
    goto _L___4;
  } else {
#line 4022
    tmp___61 = memcmp((void const   *)(magic), (void const   *)"\037\236", (size_t )2);
#line 4022
    if (tmp___61 == 0) {
      _L___4: /* CIL Label */ 
#line 4025
      if (inptr < insize) {
#line 4025
        tmp___10 = inptr;
#line 4025
        inptr ++;
#line 4025
        tmp___12 = (int )inbuf[tmp___10];
      } else {
#line 4025
        tmp___11 = fill_inbuf(0);
#line 4025
        tmp___12 = tmp___11;
      }
#line 4025
      method = tmp___12;
#line 4026
      if (method != 8) {
#line 4027
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: unknown method %d -- not supported\n",
                progname, ifname, method);
#line 4030
        exit_code = 1;
#line 4031
        __retres78 = -1;
#line 4031
        goto return_label;
      } else {

      }
#line 4033
      work = & unzip;
#line 4034
      if (inptr < insize) {
#line 4034
        tmp___13 = inptr;
#line 4034
        inptr ++;
#line 4034
        tmp___15 = (int )inbuf[tmp___13];
      } else {
#line 4034
        tmp___14 = fill_inbuf(0);
#line 4034
        tmp___15 = tmp___14;
      }
#line 4034
      flags = (uch )tmp___15;
#line 4036
      if (((int )flags & 32) != 0) {
#line 4037
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is encrypted -- not supported\n",
                progname, ifname);
#line 4040
        exit_code = 1;
#line 4041
        __retres78 = -1;
#line 4041
        goto return_label;
      } else {

      }
#line 4043
      if (((int )flags & 2) != 0) {
#line 4044
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s is a a multi-part gzip file -- not supported\n",
                progname, ifname);
#line 4047
        exit_code = 1;
#line 4048
        if (force <= 1) {
#line 4048
          __retres78 = -1;
#line 4048
          goto return_label;
        } else {

        }
      } else {

      }
#line 4050
      if (((int )flags & 192) != 0) {
#line 4051
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s has flags 0x%x -- not supported\n",
                progname, ifname, (int )flags);
#line 4054
        exit_code = 1;
#line 4055
        if (force <= 1) {
#line 4055
          __retres78 = -1;
#line 4055
          goto return_label;
        } else {

        }
      } else {

      }
#line 4057
      if (inptr < insize) {
#line 4057
        tmp___16 = inptr;
#line 4057
        inptr ++;
#line 4057
        tmp___18 = (int )inbuf[tmp___16];
      } else {
#line 4057
        tmp___17 = fill_inbuf(0);
#line 4057
        tmp___18 = tmp___17;
      }
#line 4057
      stamp = (ulg )tmp___18;
#line 4058
      if (inptr < insize) {
#line 4058
        tmp___19 = inptr;
#line 4058
        inptr ++;
#line 4058
        tmp___21 = (int )inbuf[tmp___19];
      } else {
#line 4058
        tmp___20 = fill_inbuf(0);
#line 4058
        tmp___21 = tmp___20;
      }
#line 4058
      stamp |= (ulg )tmp___21 << 8;
#line 4059
      if (inptr < insize) {
#line 4059
        tmp___22 = inptr;
#line 4059
        inptr ++;
#line 4059
        tmp___24 = (int )inbuf[tmp___22];
      } else {
#line 4059
        tmp___23 = fill_inbuf(0);
#line 4059
        tmp___24 = tmp___23;
      }
#line 4059
      stamp |= (ulg )tmp___24 << 16;
#line 4060
      if (inptr < insize) {
#line 4060
        tmp___25 = inptr;
#line 4060
        inptr ++;
#line 4060
        tmp___27 = (int )inbuf[tmp___25];
      } else {
#line 4060
        tmp___26 = fill_inbuf(0);
#line 4060
        tmp___27 = tmp___26;
      }
#line 4060
      stamp |= (ulg )tmp___27 << 24;
#line 4061
      if (stamp != 0UL) {
#line 4061
        if (no_time == 0) {
#line 4061
          time_stamp = (time_t )stamp;
        } else {

        }
      } else {

      }
#line 4063
      if (inptr < insize) {
#line 4063
        tmp___28 = inptr;
#line 4063
        inptr ++;
      } else {
#line 4063
        fill_inbuf(0);
      }
#line 4064
      if (inptr < insize) {
#line 4064
        tmp___29 = inptr;
#line 4064
        inptr ++;
      } else {
#line 4064
        fill_inbuf(0);
      }
#line 4066
      if (((int )flags & 2) != 0) {
#line 4067
        if (inptr < insize) {
#line 4067
          tmp___30 = inptr;
#line 4067
          inptr ++;
#line 4067
          tmp___32 = (int )inbuf[tmp___30];
        } else {
#line 4067
          tmp___31 = fill_inbuf(0);
#line 4067
          tmp___32 = tmp___31;
        }
#line 4067
        part = (unsigned int )tmp___32;
#line 4068
        if (inptr < insize) {
#line 4068
          tmp___33 = inptr;
#line 4068
          inptr ++;
#line 4068
          tmp___35 = (int )inbuf[tmp___33];
        } else {
#line 4068
          tmp___34 = fill_inbuf(0);
#line 4068
          tmp___35 = tmp___34;
        }
#line 4068
        part |= (unsigned int )tmp___35 << 8;
#line 4069
        if (verbose != 0) {
#line 4070
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: part number %u\n",
                  progname, ifname, part);
        } else {

        }
      } else {

      }
#line 4074
      if (((int )flags & 4) != 0) {
#line 4075
        if (inptr < insize) {
#line 4075
          tmp___36 = inptr;
#line 4075
          inptr ++;
#line 4075
          tmp___38 = (int )inbuf[tmp___36];
        } else {
#line 4075
          tmp___37 = fill_inbuf(0);
#line 4075
          tmp___38 = tmp___37;
        }
#line 4075
        len = (unsigned int )tmp___38;
#line 4076
        if (inptr < insize) {
#line 4076
          tmp___39 = inptr;
#line 4076
          inptr ++;
#line 4076
          tmp___41 = (int )inbuf[tmp___39];
        } else {
#line 4076
          tmp___40 = fill_inbuf(0);
#line 4076
          tmp___41 = tmp___40;
        }
#line 4076
        len |= (unsigned int )tmp___41 << 8;
#line 4077
        if (verbose != 0) {
#line 4078
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: extra field of %u bytes ignored\n",
                  progname, ifname, len);
        } else {

        }
        {
#line 4081
        while (1) {
          while_continue: /* CIL Label */ ;
#line 4081
          tmp___43 = len;
#line 4081
          len --;
#line 4081
          if (tmp___43 != 0) {

          } else {
#line 4081
            goto while_break;
          }
#line 4081
          if (inptr < insize) {
#line 4081
            tmp___42 = inptr;
#line 4081
            inptr ++;
          } else {
#line 4081
            fill_inbuf(0);
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {

      }
#line 4085
      if (((int )flags & 8) != 0) {
#line 4086
        if (no_name != 0) {
#line 4086
          goto _L___0;
        } else
#line 4086
        if (to_stdout != 0) {
#line 4086
          if (list == 0) {
#line 4086
            goto _L___0;
          } else {
#line 4086
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 4086
        if (part_nb > 1) {
          _L___0: /* CIL Label */ 
          {
#line 4089
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 4089
            if (inptr < insize) {
#line 4089
              tmp___44 = inptr;
#line 4089
              inptr ++;
#line 4089
              c = (char )inbuf[tmp___44];
            } else {
#line 4089
              tmp___45 = fill_inbuf(0);
#line 4089
              c = (char )tmp___45;
            }
#line 4089
            if ((int )c != 0) {

            } else {
#line 4089
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 4092
          tmp___46 = base_name(ofname);
#line 4092
          p = tmp___46;
#line 4093
          base = p;
          {
#line 4095
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 4096
            if (inptr < insize) {
#line 4096
              tmp___47 = inptr;
#line 4096
              inptr ++;
#line 4096
              tmp___49 = (int )inbuf[tmp___47];
            } else {
#line 4096
              tmp___48 = fill_inbuf(0);
#line 4096
              tmp___49 = tmp___48;
            }
#line 4096
            *p = (char )tmp___49;
#line 4097
            tmp___50 = p;
#line 4097
            p ++;
#line 4097
            if ((int )*tmp___50 == 0) {
#line 4097
              goto while_break___1;
            } else {

            }
#line 4098
            if ((unsigned int )p >= (unsigned int )(ofname + sizeof(ofname))) {
#line 4099
              error((char *)"corrupted input -- file name too large");
            } else {

            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 4102
          base2 = base_name(base);
#line 4103
          strcpy((char * __restrict  )base, (char const   * __restrict  )base2);
#line 4105
          if (list == 0) {
#line 4107
            if (base != 0) {
#line 4107
              list = 0;
            } else {

            }
          } else {

          }
        }
      } else {

      }
#line 4113
      if (((int )flags & 16) != 0) {
        {
#line 4114
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 4114
          if (inptr < insize) {
#line 4114
            tmp___51 = inptr;
#line 4114
            inptr ++;
#line 4114
            tmp___53 = (int )inbuf[tmp___51];
          } else {
#line 4114
            tmp___52 = fill_inbuf(0);
#line 4114
            tmp___53 = tmp___52;
          }
#line 4114
          if (tmp___53 != 0) {

          } else {
#line 4114
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {

      }
#line 4116
      if (part_nb == 1) {
#line 4117
        header_bytes = (off_t )(inptr + 2U * sizeof(long ));
      } else {

      }
    } else {
#line 4120
      tmp___58 = memcmp((void const   *)(magic), (void const   *)"PK\003\004", (size_t )2);
#line 4120
      if (tmp___58 == 0) {
#line 4120
        if (inptr == 2U) {
#line 4120
          tmp___59 = memcmp((void const   *)((char *)(inbuf)), (void const   *)"PK\003\004",
                            (size_t )4);
#line 4120
          if (tmp___59 == 0) {
#line 4125
            inptr = 0U;
#line 4126
            work = & unzip;
#line 4127
            tmp___54 = check_zipfile(in);
#line 4127
            if (tmp___54 != 0) {
#line 4127
              __retres78 = -1;
#line 4127
              goto return_label;
            } else {

            }
#line 4129
            last_member = 1;
          } else {
#line 4120
            goto _L___3;
          }
        } else {
#line 4120
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 4131
        tmp___57 = memcmp((void const   *)(magic), (void const   *)"\037\036", (size_t )2);
#line 4131
        if (tmp___57 == 0) {
#line 4132
          work = & unpack;
#line 4133
          method = 2;
        } else {
#line 4135
          tmp___56 = memcmp((void const   *)(magic), (void const   *)"\037\235", (size_t )2);
#line 4135
          if (tmp___56 == 0) {
#line 4136
            work = & unlzw;
#line 4137
            method = 1;
#line 4138
            last_member = 1;
          } else {
#line 4140
            tmp___55 = memcmp((void const   *)(magic), (void const   *)"\037\240",
                              (size_t )2);
#line 4140
            if (tmp___55 == 0) {
#line 4141
              work = & unlzh;
#line 4142
              method = 3;
#line 4143
              last_member = 1;
            } else
#line 4145
            if (force != 0) {
#line 4145
              if (to_stdout != 0) {
#line 4145
                if (list == 0) {
#line 4146
                  method = 0;
#line 4147
                  work = & copy;
#line 4148
                  inptr = 0U;
#line 4149
                  last_member = 1;
                } else {

                }
              } else {

              }
            } else {

            }
          }
        }
      }
    }
  }
#line 4151
  if (method >= 0) {
#line 4151
    __retres78 = method;
#line 4151
    goto return_label;
  } else {

  }
#line 4153
  if (part_nb == 1) {
#line 4154
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: not in gzip format\n",
            progname, ifname);
#line 4155
    exit_code = 1;
#line 4156
    __retres78 = -1;
#line 4156
    goto return_label;
  } else {
#line 4158
    if ((int )magic[0] == 0) {
#line 4161
      inbyte = imagic1;
      {
#line 4161
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4161
        if (inbyte == 0) {

        } else {
#line 4161
          goto while_break___3;
        }
#line 4162
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 4161
        if (inptr < insize) {
#line 4161
          tmp___62 = inptr;
#line 4161
          inptr ++;
#line 4161
          inbyte = (int )inbuf[tmp___62];
        } else {
#line 4161
          tmp___63 = fill_inbuf(1);
#line 4161
          inbyte = tmp___63;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 4163
      if (inbyte == -1) {
#line 4165
        if (verbose != 0) {
#line 4166
          if (quiet == 0) {
#line 4166
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: decompression OK, trailing zero bytes ignored\n",
                    progname, ifname);
          } else {

          }
#line 4166
          if (exit_code == 0) {
#line 4166
            exit_code = 2;
          } else {

          }
        } else {

        }
#line 4168
        __retres78 = -3;
#line 4168
        goto return_label;
      } else {

      }
    } else {

    }
#line 4172
    if (quiet == 0) {
#line 4172
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: decompression OK, trailing garbage ignored\n",
              progname, ifname);
    } else {

    }
#line 4172
    if (exit_code == 0) {
#line 4172
      exit_code = 2;
    } else {

    }
#line 4174
    __retres78 = -2;
#line 4174
    goto return_label;
  }
  return_label: /* CIL Label */ 
#line 3995
  return (__retres78);
}
}
#line 4188
static void do_list(int ifd___0 , int method___0 ) ;
#line 4188 "gzip.c"
static int first_time  =    1;
#line 4189
static void do_list(int ifd___0 , int method___0 ) ;
#line 4189 "gzip.c"
static char *methods[9]  = 
#line 4189
  {      (char *)"store",      (char *)"compr",      (char *)"pack ",      (char *)"lzh  ", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"defla"};
#line 4183 "gzip.c"
static void do_list(int ifd___0 , int method___0 ) 
{ 
  ulg crc ;
  char *date ;
  int positive_off_t_width ;
  off_t o ;
  uch buf[8] ;
  ssize_t tmp ;
  char *tmp___0 ;
  uch *mem_10 ;
  uch *mem_11 ;
  uch *mem_12 ;
  uch *mem_13 ;
  uch *mem_14 ;
  uch *mem_15 ;
  char *mem_16 ;

  {
#line 4197
  positive_off_t_width = 1;
#line 4200
  o = -1L - (-1L << (sizeof(off_t ) * 8U - 1U));
  {
#line 4200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4200
    if (9L < o) {

    } else {
#line 4200
      goto while_break;
    }
#line 4201
    positive_off_t_width ++;
#line 4200
    o /= 10L;
  }
  while_break: /* CIL Label */ ;
  }
#line 4204
  if (first_time != 0) {
#line 4204
    if (method___0 >= 0) {
#line 4205
      first_time = 0;
#line 4206
      if (verbose != 0) {
#line 4207
        printf((char const   * __restrict  )"method  crc     date  time  ");
      } else {

      }
#line 4209
      if (quiet == 0) {
#line 4210
        printf((char const   * __restrict  )"%*.*s %*.*s  ratio uncompressed_name\n",
               positive_off_t_width, positive_off_t_width, "compressed", positive_off_t_width,
               positive_off_t_width, "uncompressed");
      } else {

      }
    } else {
#line 4204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4214
  if (method___0 < 0) {
#line 4215
    if (total_in <= 0L) {

#line 4215
      goto return_label;
    } else
#line 4215
    if (total_out <= 0L) {

#line 4215
      goto return_label;
    } else {

    }
#line 4216
    if (verbose != 0) {
#line 4217
      printf((char const   * __restrict  )"                            ");
    } else {

    }
#line 4219
    if (verbose != 0) {
#line 4220
      fprint_off(stdout, total_in, positive_off_t_width);
#line 4221
      printf((char const   * __restrict  )" ");
#line 4222
      fprint_off(stdout, total_out, positive_off_t_width);
#line 4223
      printf((char const   * __restrict  )" ");
    } else
#line 4219
    if (quiet == 0) {
#line 4220
      fprint_off(stdout, total_in, positive_off_t_width);
#line 4221
      printf((char const   * __restrict  )" ");
#line 4222
      fprint_off(stdout, total_out, positive_off_t_width);
#line 4223
      printf((char const   * __restrict  )" ");
    } else {

    }
#line 4225
    display_ratio(total_out - (total_in - header_bytes), total_out, stdout);
#line 4229
    printf((char const   * __restrict  )" (totals)\n");

#line 4230
    goto return_label;
  } else {

  }
#line 4232
  crc = (ulg )(~ 0);
#line 4233
  bytes_out = -1L;
#line 4234
  bytes_in = ifile_size;
#line 4237
  if (method___0 == 8) {
#line 4237
    if (last_member == 0) {
#line 4244
      bytes_in = lseek(ifd___0, (off_t )-8, 2);
#line 4245
      if (bytes_in != -1L) {
#line 4247
        bytes_in += 8L;
#line 4248
        tmp = read(ifd___0, (void *)((char *)(buf)), sizeof(buf));
#line 4248
        if ((unsigned int )tmp != sizeof(buf)) {
#line 4249
          read_error();
        } else {

        }
#line 4251
        mem_10 = (buf + 2) + 0;
#line 4251
        mem_11 = (buf + 2) + 1;
#line 4251
        crc = (ulg )((int )((ush )buf[0]) | ((int )((ush )buf[1]) << 8)) | ((ulg )((int )((ush )*mem_10) | ((int )((ush )*mem_11) << 8)) << 16);
#line 4252
        mem_12 = (buf + 4) + 0;
#line 4252
        mem_13 = (buf + 4) + 1;
#line 4252
        mem_14 = ((buf + 4) + 2) + 0;
#line 4252
        mem_15 = ((buf + 4) + 2) + 1;
#line 4252
        bytes_out = (off_t )((ulg )((int )((ush )*mem_12) | ((int )((ush )*mem_13) << 8)) | ((ulg )((int )((ush )*mem_14) | ((int )((ush )*mem_15) << 8)) << 16));
      } else {

      }
    } else {

    }
  } else {

  }
#line 4256
  tmp___0 = ctime((time_t const   *)(& time_stamp));
#line 4256
  date = tmp___0 + 4;
#line 4257
  mem_16 = date + 12;
#line 4257
  *mem_16 = (char )'\000';
#line 4258
  if (verbose != 0) {
#line 4259
    printf((char const   * __restrict  )"%5s %08lx %11s ", methods[method___0], crc,
           date);
  } else {

  }
#line 4261
  fprint_off(stdout, bytes_in, positive_off_t_width);
#line 4262
  printf((char const   * __restrict  )" ");
#line 4263
  fprint_off(stdout, bytes_out, positive_off_t_width);
#line 4264
  printf((char const   * __restrict  )" ");
#line 4265
  if (bytes_in == -1L) {
#line 4266
    total_in = -1L;
#line 4267
    header_bytes = (off_t )0;
#line 4267
    bytes_out = header_bytes;
#line 4267
    bytes_in = bytes_out;
  } else
#line 4268
  if (total_in >= 0L) {
#line 4269
    total_in += bytes_in;
  } else {

  }
#line 4271
  if (bytes_out == -1L) {
#line 4272
    total_out = -1L;
#line 4273
    header_bytes = (off_t )0;
#line 4273
    bytes_out = header_bytes;
#line 4273
    bytes_in = bytes_out;
  } else
#line 4274
  if (total_out >= 0L) {
#line 4275
    total_out += bytes_out;
  } else {

  }
#line 4277
  display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stdout);
#line 4278
  printf((char const   * __restrict  )" %s\n", ofname);

  return_label: /* CIL Label */ 
#line 4183
  return;
}
}
#line 4284 "gzip.c"
static int same_file(struct stat *stat1 , struct stat *stat2 ) 
{ 
  int tmp ;

  {
#line 4288
  if (stat1->st_ino == stat2->st_ino) {
#line 4288
    if (stat1->st_dev == stat2->st_dev) {
#line 4288
      tmp = 1;
    } else {
#line 4288
      tmp = 0;
    }
  } else {
#line 4288
    tmp = 0;
  }
#line 4288
  return (tmp);
}
}
#line 4307 "gzip.c"
static int name_too_long(char *name , struct stat *statb ) 
{ 
  int s ;
  size_t tmp ;
  char c ;
  struct stat tstat ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *mem_11 ;
  char *mem_12 ;
  char *mem_13 ;

  {
#line 4311
  tmp = strlen((char const   *)name);
#line 4311
  s = (int )tmp;
#line 4312
  mem_11 = name + (s - 1);
#line 4312
  c = *mem_11;
#line 4316
  tstat = *statb;
#line 4317
  mem_12 = name + (s - 1);
#line 4317
  *mem_12 = (char )'\000';
#line 4318
  tmp___0 = lstat((char const   * __restrict  )name, (struct stat * __restrict  )(& tstat));
#line 4318
  if (tmp___0 == 0) {
#line 4318
    tmp___1 = same_file(statb, & tstat);
#line 4318
    if (tmp___1 != 0) {
#line 4318
      tmp___2 = 1;
    } else {
#line 4318
      tmp___2 = 0;
    }
  } else {
#line 4318
    tmp___2 = 0;
  }
#line 4318
  res = tmp___2;
#line 4319
  mem_13 = name + (s - 1);
#line 4319
  *mem_13 = c;
#line 4321
  return (res);
}
}
#line 4333 "gzip.c"
static void shorten_name(char *name ) 
{ 
  int len ;
  char *trunc ;
  int plen ;
  int min_part ;
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *mem_11 ;
  char *mem_12 ;
  char *mem_13 ;
  char const   *mem_14 ;
  char *mem_15 ;

  {
#line 4337
  trunc = (char *)((void *)0);
#line 4339
  min_part = 3;
#line 4342
  tmp = strlen((char const   *)name);
#line 4342
  len = (int )tmp;
#line 4343
  if (decompress != 0) {
#line 4344
    if (len <= 1) {
#line 4344
      error((char *)"name too short");
    } else {

    }
#line 4345
    mem_11 = name + (len - 1);
#line 4345
    *mem_11 = (char )'\000';

#line 4346
    goto return_label;
  } else {

  }
#line 4348
  p = get_suffix(name);
#line 4349
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 4349
    error((char *)"can\'t recover suffix\n");
  } else {

  }
#line 4350
  *p = (char )'\000';
#line 4351
  save_orig_name = 1;
#line 4354
  if (len > 4) {
#line 4354
    tmp___0 = strcmp((char const   *)(p - 4), ".tar");
#line 4354
    if (tmp___0 == 0) {
#line 4355
      strcpy((char * __restrict  )(p - 4), (char const   * __restrict  )".tgz");

#line 4356
      goto return_label;
    } else {

    }
  } else {

  }
  {
#line 4361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4362
    p = strrchr((char const   *)name, '/');
#line 4363
    if (p != 0) {
#line 4363
      p ++;
    } else {
#line 4363
      p = name;
    }
    {
#line 4364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4364
      if (*p != 0) {

      } else {
#line 4364
        goto while_break___0;
      }
#line 4365
      tmp___1 = strcspn((char const   *)p, ".");
#line 4365
      plen = (int )tmp___1;
#line 4366
      p += plen;
#line 4367
      if (plen > min_part) {
#line 4367
        trunc = p - 1;
      } else {

      }
#line 4368
      if (*p != 0) {
#line 4368
        p ++;
      } else {

      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4361
    if ((unsigned int )trunc == (unsigned int )((void *)0)) {
#line 4361
      min_part --;
#line 4361
      if (min_part != 0) {

      } else {
#line 4361
        goto while_break;
      }
    } else {
#line 4361
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4372
  if ((unsigned int )trunc != (unsigned int )((void *)0)) {
    {
#line 4373
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4374
      mem_12 = trunc + 0;
#line 4374
      mem_13 = trunc + 1;
#line 4374
      *mem_12 = *mem_13;
#line 4373
      tmp___2 = trunc;
#line 4373
      trunc ++;
#line 4373
      if (*tmp___2 != 0) {

      } else {
#line 4373
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4376
    trunc --;
  } else {
#line 4378
    mem_14 = "." + 0;
#line 4378
    trunc = strrchr((char const   *)name, (int )*mem_14);
#line 4379
    if ((unsigned int )trunc == (unsigned int )((void *)0)) {
#line 4379
      error((char *)"internal error in shorten_name");
    } else {

    }
    {
#line 4380
    mem_15 = trunc + 1;
#line 4380
    if ((int )*mem_15 == 0) {
#line 4380
      trunc --;
    } else {

    }
    }
  }
#line 4382
  strcpy((char * __restrict  )trunc, (char const   * __restrict  )z_suffix);

  return_label: /* CIL Label */ 
#line 4333
  return;
}
}
#line 4399 "gzip.c"
static int check_ofname(void) 
{ 
  struct stat ostat ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int ok ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int __retres14 ;

  {
#line 4407
  tmp = __errno_location();
#line 4407
  *tmp = 0;
  {
#line 4408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4408
    tmp___1 = lstat((char const   * __restrict  )(ofname), (struct stat * __restrict  )(& ostat));
#line 4408
    if (tmp___1 != 0) {

    } else {
#line 4408
      goto while_break;
    }
#line 4409
    tmp___0 = __errno_location();
#line 4409
    if (*tmp___0 != 36) {
#line 4409
      __retres14 = 0;
#line 4409
      goto return_label;
    } else {

    }
#line 4410
    shorten_name(ofname);
  }
  while_break: /* CIL Label */ ;
  }
#line 4419
  if (decompress == 0) {
#line 4419
    tmp___3 = name_too_long(ofname, & ostat);
#line 4419
    if (tmp___3 != 0) {
#line 4420
      shorten_name(ofname);
#line 4421
      tmp___2 = lstat((char const   * __restrict  )(ofname), (struct stat * __restrict  )(& ostat));
#line 4421
      if (tmp___2 != 0) {
#line 4421
        __retres14 = 0;
#line 4421
        goto return_label;
      } else {

      }
    } else {

    }
  } else {

  }
#line 4427
  tmp___6 = same_file(& istat, & ostat);
#line 4427
  if (tmp___6 != 0) {
#line 4428
    tmp___5 = strcmp((char const   *)(ifname), (char const   *)(ofname));
#line 4428
    if (tmp___5 == 0) {
#line 4429
      if (decompress != 0) {
#line 4429
        tmp___4 = "de";
      } else {
#line 4429
        tmp___4 = "";
      }
#line 4429
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: cannot %scompress onto itself\n",
              progname, ifname, tmp___4);
    } else {
#line 4432
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s and %s are the same file\n",
              progname, ifname, ofname);
    }
#line 4435
    exit_code = 1;
#line 4436
    __retres14 = 1;
#line 4436
    goto return_label;
  } else {

  }
#line 4439
  if (force == 0) {
#line 4440
    ok = 0;
#line 4441
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s already exists;",
            progname, ofname);
#line 4442
    if (foreground != 0) {
#line 4442
      tmp___7 = fileno(stdin);
#line 4442
      tmp___8 = isatty(tmp___7);
#line 4442
      if (tmp___8 != 0) {
#line 4443
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" do you wish to overwrite (y or n)? ");
#line 4444
        fflush(stderr);
#line 4445
        ok = yesno();
      } else {

      }
    } else {

    }
#line 4447
    if (ok == 0) {
#line 4448
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tnot overwritten\n");
#line 4449
      if (exit_code == 0) {
#line 4449
        exit_code = 2;
      } else {

      }
#line 4450
      __retres14 = 1;
#line 4450
      goto return_label;
    } else {

    }
  } else {

  }
#line 4453
  tmp___9 = xunlink(ofname);
#line 4453
  if (tmp___9 != 0) {
#line 4454
    progerror(ofname);
#line 4455
    __retres14 = 1;
#line 4455
    goto return_label;
  } else {

  }
#line 4457
  __retres14 = 0;
  return_label: /* CIL Label */ 
#line 4399
  return (__retres14);
}
}
#line 4465 "gzip.c"
static void reset_times(char *name , struct stat *statb ) 
{ 
  struct utimbuf timep ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 4472
  timep.actime = statb->st_atim.tv_sec;
#line 4473
  timep.modtime = statb->st_mtim.tv_sec;
#line 4476
  tmp___1 = utime((char const   *)name, (struct utimbuf  const  *)(& timep));
#line 4476
  if (tmp___1 != 0) {
#line 4476
    if ((statb->st_mode & 61440U) != 16384U) {
#line 4477
      tmp = __errno_location();
#line 4477
      e = *tmp;
#line 4478
      if (quiet == 0) {
#line 4478
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ",
                progname);
      } else {

      }
#line 4478
      if (exit_code == 0) {
#line 4478
        exit_code = 2;
      } else {

      }
#line 4479
      if (quiet == 0) {
#line 4480
        tmp___0 = __errno_location();
#line 4480
        *tmp___0 = e;
#line 4481
        perror((char const   *)(ofname));
      } else {

      }
    } else {

    }
  } else {

  }

#line 4465
  return;
}
}
#line 4492 "gzip.c"
static void copy_stat(struct stat *ifstat ) 
{ 
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int e___0 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 4496
  if (decompress != 0) {
#line 4496
    if (time_stamp != 0L) {
#line 4496
      if (ifstat->st_mtim.tv_sec != time_stamp) {
#line 4497
        ifstat->st_mtim.tv_sec = time_stamp;
#line 4498
        if (verbose > 1) {
#line 4499
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: time stamp restored\n",
                  ofname);
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 4502
  reset_times(ofname, ifstat);
#line 4505
  tmp___1 = fchmod(ofd, ifstat->st_mode & 4095U);
#line 4505
  if (tmp___1 != 0) {
#line 4506
    tmp = __errno_location();
#line 4506
    e = *tmp;
#line 4507
    if (quiet == 0) {
#line 4507
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", progname);
    } else {

    }
#line 4507
    if (exit_code == 0) {
#line 4507
      exit_code = 2;
    } else {

    }
#line 4508
    if (quiet == 0) {
#line 4509
      tmp___0 = __errno_location();
#line 4509
      *tmp___0 = e;
#line 4510
      perror((char const   *)(ofname));
    } else {

    }
  } else {

  }
#line 4514
  fchown(ofd, ifstat->st_uid, ifstat->st_gid);
#line 4516
  remove_ofname = 0;
#line 4518
  tmp___4 = xunlink(ifname);
#line 4518
  if (tmp___4 != 0) {
#line 4519
    tmp___2 = __errno_location();
#line 4519
    e___0 = *tmp___2;
#line 4520
    if (quiet == 0) {
#line 4520
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", progname);
    } else {

    }
#line 4520
    if (exit_code == 0) {
#line 4520
      exit_code = 2;
    } else {

    }
#line 4521
    if (quiet == 0) {
#line 4522
      tmp___3 = __errno_location();
#line 4522
      *tmp___3 = e___0;
#line 4523
      perror((char const   *)(ifname));
    } else {

    }
  } else {

  }

#line 4492
  return;
}
}
#line 4533 "gzip.c"
static void treat_dir(char *dir ) 
{ 
  struct dirent *dp ;
  DIR *dirp ;
  char nbuf[1024] ;
  int len ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 4541
  dirp = opendir((char const   *)dir);
#line 4543
  if ((unsigned int )dirp == (unsigned int )((void *)0)) {
#line 4544
    progerror(dir);

#line 4545
    goto return_label;
  } else {

  }
  {
#line 4563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4563
    tmp___4 = __errno_location();
#line 4563
    *tmp___4 = 0;
#line 4563
    dp = readdir(dirp);
#line 4563
    if ((unsigned int )dp != (unsigned int )((void *)0)) {

    } else {
#line 4563
      goto while_break;
    }
#line 4565
    tmp = strcmp((char const   *)(dp->d_name), ".");
#line 4565
    if (tmp == 0) {
#line 4566
      goto while_continue;
    } else {
#line 4565
      tmp___0 = strcmp((char const   *)(dp->d_name), "..");
#line 4565
      if (tmp___0 == 0) {
#line 4566
        goto while_continue;
      } else {

      }
    }
#line 4568
    tmp___1 = strlen((char const   *)dir);
#line 4568
    len = (int )tmp___1;
#line 4569
    tmp___3 = strlen((char const   *)(dp->d_name));
#line 4569
    if (((size_t )len + tmp___3) + 1U < 1023U) {
#line 4570
      strcpy((char * __restrict  )(nbuf), (char const   * __restrict  )dir);
#line 4571
      if (len != 0) {
#line 4579
        tmp___2 = len;
#line 4579
        len ++;
#line 4579
        nbuf[tmp___2] = (char )'/';
      } else {

      }
#line 4581
      strcpy((char * __restrict  )(nbuf + len), (char const   * __restrict  )(dp->d_name));
#line 4582
      treat_file(nbuf);
    } else {
#line 4584
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s/%s: pathname too long\n",
              progname, dir, dp->d_name);
#line 4586
      exit_code = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4589
  tmp___5 = __errno_location();
#line 4589
  if (*tmp___5 != 0) {
#line 4590
    progerror(dir);
  } else {

  }
#line 4591
  tmp___6 = closedir(dirp);
#line 4591
  if (tmp___6 != 0) {
#line 4592
    progerror(dir);
  } else {

  }

  return_label: /* CIL Label */ 
#line 4533
  return;
}
}
#line 4602
static void do_exit(int exitcode ) ;
#line 4602 "gzip.c"
static int in_exit  =    0;
#line 4599 "gzip.c"
static void do_exit(int exitcode ) 
{ 


  {
#line 4604
  if (in_exit != 0) {
#line 4604
    exit(exitcode);
  } else {

  }
#line 4605
  in_exit = 1;
#line 4606
  if ((unsigned int )env != (unsigned int )((void *)0)) {
#line 4606
    free((void *)env);
#line 4606
    env = (char *)((void *)0);
  } else {

  }
#line 4607
  if ((unsigned int )args != (unsigned int )((void *)0)) {
#line 4607
    free((void *)((char *)args));
#line 4607
    args = (char **)((void *)0);
  } else {

  }
#line 4618
  exit(exitcode);
#line 4599
  return;
}
}
#line 4625 "gzip.c"
static void do_remove(void) 
{ 


  {
#line 4626
  if (remove_ofname != 0) {
#line 4627
    close(ofd);
#line 4628
    xunlink(ofname);
  } else {

  }

#line 4625
  return;
}
}
#line 4635 "gzip.c"
void abort_gzip(void) 
{ 


  {
#line 4637
  do_remove();
#line 4638
  do_exit(1);

#line 4635
  return;
}
}
#line 4644 "gzip.c"
void abort_gzip_signal(void) 
{ 


  {
#line 4646
  do_remove();
#line 4647
  _exit(1);
#line 4644
  return;
}
}
#line 4791
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
               struct huft **t , int *m ) ;
#line 4793
int huft_free(struct huft *t ) ;
#line 4794
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) ;
#line 4795
int inflate_stored(void) ;
#line 4796
int inflate_fixed(void) ;
#line 4797
int inflate_dynamic(void) ;
#line 4798
int inflate_block(int *e ) ;
#line 4815 "gzip.c"
static unsigned int border[19]  = 
#line 4815
  {      16U,      17U,      18U,      0U, 
        8U,      7U,      9U,      6U, 
        10U,      5U,      11U,      4U, 
        12U,      3U,      13U,      2U, 
        14U,      1U,      15U};
#line 4817 "gzip.c"
static ush cplens[31]  = 
#line 4817
  {      (ush )3,      (ush )4,      (ush )5,      (ush )6, 
        (ush )7,      (ush )8,      (ush )9,      (ush )10, 
        (ush )11,      (ush )13,      (ush )15,      (ush )17, 
        (ush )19,      (ush )23,      (ush )27,      (ush )31, 
        (ush )35,      (ush )43,      (ush )51,      (ush )59, 
        (ush )67,      (ush )83,      (ush )99,      (ush )115, 
        (ush )131,      (ush )163,      (ush )195,      (ush )227, 
        (ush )258,      (ush )0,      (ush )0};
#line 4821 "gzip.c"
static ush cplext[31]  = 
#line 4821
  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )1,      (ush )1,      (ush )1,      (ush )1, 
        (ush )2,      (ush )2,      (ush )2,      (ush )2, 
        (ush )3,      (ush )3,      (ush )3,      (ush )3, 
        (ush )4,      (ush )4,      (ush )4,      (ush )4, 
        (ush )5,      (ush )5,      (ush )5,      (ush )5, 
        (ush )0,      (ush )99,      (ush )99};
#line 4824 "gzip.c"
static ush cpdist[30]  = 
#line 4824
  {      (ush )1,      (ush )2,      (ush )3,      (ush )4, 
        (ush )5,      (ush )7,      (ush )9,      (ush )13, 
        (ush )17,      (ush )25,      (ush )33,      (ush )49, 
        (ush )65,      (ush )97,      (ush )129,      (ush )193, 
        (ush )257,      (ush )385,      (ush )513,      (ush )769, 
        (ush )1025,      (ush )1537,      (ush )2049,      (ush )3073, 
        (ush )4097,      (ush )6145,      (ush )8193,      (ush )12289, 
        (ush )16385,      (ush )24577};
#line 4828 "gzip.c"
static ush cpdext[30]  = 
#line 4828
  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )1,      (ush )1,      (ush )2,      (ush )2, 
        (ush )3,      (ush )3,      (ush )4,      (ush )4, 
        (ush )5,      (ush )5,      (ush )6,      (ush )6, 
        (ush )7,      (ush )7,      (ush )8,      (ush )8, 
        (ush )9,      (ush )9,      (ush )10,      (ush )10, 
        (ush )11,      (ush )11,      (ush )12,      (ush )12, 
        (ush )13,      (ush )13};
#line 4866 "gzip.c"
ulg bb  ;
#line 4867 "gzip.c"
unsigned int bk  ;
#line 4869 "gzip.c"
ush mask_bits[17]  = 
#line 4869
  {      (ush )0,      (ush )1,      (ush )3,      (ush )7, 
        (ush )15,      (ush )31,      (ush )63,      (ush )127, 
        (ush )255,      (ush )511,      (ush )1023,      (ush )2047, 
        (ush )4095,      (ush )8191,      (ush )16383,      (ush )32767, 
        (ush )65535};
#line 4921 "gzip.c"
int lbits  =    9;
#line 4922 "gzip.c"
int dbits  =    6;
#line 4930 "gzip.c"
unsigned int hufts  ;
#line 4933 "gzip.c"
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
               struct huft **t , int *m ) 
{ 
  unsigned int a ;
  unsigned int c[17] ;
  unsigned int f ;
  int g ;
  int h ;
  register unsigned int i ;
  register unsigned int j ;
  register int k ;
  int l ;
  register unsigned int *p ;
  register struct huft *q ;
  struct huft r ;
  struct huft *u[16] ;
  unsigned int v[288] ;
  register int w ;
  unsigned int x[17] ;
  unsigned int *xp ;
  int y ;
  unsigned int z ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  struct huft *mem_36 ;
  ush *mem_37 ;
  ush *mem_38 ;
  struct huft *mem_39 ;
  int __retres40 ;

  {
#line 4969
  memset((voidp )(c), 0, sizeof(c));
#line 4970
  p = b;
#line 4970
  i = n;
  {
#line 4971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4974
    (c[*p]) ++;
#line 4975
    p ++;
#line 4971
    i --;
#line 4971
    if (i != 0) {

    } else {
#line 4971
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4977
  if (c[0] == n) {
#line 4979
    *t = (struct huft *)((void *)0);
#line 4980
    *m = 0;
#line 4981
    __retres40 = 0;
#line 4981
    goto return_label;
  } else {

  }
#line 4986
  l = *m;
#line 4987
  j = 1U;
  {
#line 4987
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4987
    if (j <= 16U) {

    } else {
#line 4987
      goto while_break___0;
    }
#line 4988
    if (c[j] != 0) {
#line 4989
      goto while_break___0;
    } else {

    }
#line 4987
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4990
  k = (int )j;
#line 4991
  if ((unsigned int )l < j) {
#line 4992
    l = (int )j;
  } else {

  }
#line 4993
  i = 16U;
  {
#line 4993
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4993
    if (i != 0) {

    } else {
#line 4993
      goto while_break___1;
    }
#line 4994
    if (c[i] != 0) {
#line 4995
      goto while_break___1;
    } else {

    }
#line 4993
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4996
  g = (int )i;
#line 4997
  if ((unsigned int )l > i) {
#line 4998
    l = (int )i;
  } else {

  }
#line 4999
  *m = l;
#line 5003
  y = 1 << j;
  {
#line 5003
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5003
    if (j < i) {

    } else {
#line 5003
      goto while_break___2;
    }
#line 5004
    y = (int )((unsigned int )y - c[j]);
#line 5004
    if (y < 0) {
#line 5005
      __retres40 = 2;
#line 5005
      goto return_label;
    } else {

    }
#line 5003
    j ++;
#line 5003
    y <<= 1;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5006
  y = (int )((unsigned int )y - c[i]);
#line 5006
  if (y < 0) {
#line 5007
    __retres40 = 2;
#line 5007
    goto return_label;
  } else {

  }
#line 5008
  c[i] += (unsigned int )y;
#line 5012
  j = 0U;
#line 5012
  x[1] = j;
#line 5013
  p = c + 1;
#line 5013
  xp = x + 2;
  {
#line 5014
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5014
    i --;
#line 5014
    if (i != 0) {

    } else {
#line 5014
      goto while_break___3;
    }
#line 5015
    tmp = xp;
#line 5015
    xp ++;
#line 5015
    tmp___0 = p;
#line 5015
    p ++;
#line 5015
    j += *tmp___0;
#line 5015
    *tmp = j;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5020
  p = b;
#line 5020
  i = 0U;
  {
#line 5021
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 5022
    tmp___2 = p;
#line 5022
    p ++;
#line 5022
    j = *tmp___2;
#line 5022
    if (j != 0U) {
#line 5023
      tmp___1 = x[j];
#line 5023
      (x[j]) ++;
#line 5023
      v[tmp___1] = i;
    } else {

    }
#line 5021
    i ++;
#line 5021
    if (i < n) {

    } else {
#line 5021
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 5025
  n = x[g];
#line 5029
  i = 0U;
#line 5029
  x[0] = i;
#line 5030
  p = v;
#line 5031
  h = -1;
#line 5032
  w = - l;
#line 5033
  u[0] = (struct huft *)((void *)0);
#line 5034
  q = (struct huft *)((void *)0);
#line 5035
  z = 0U;
  {
#line 5038
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 5038
    if (k <= g) {

    } else {
#line 5038
      goto while_break___5;
    }
#line 5040
    a = c[k];
    {
#line 5041
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 5041
      tmp___6 = a;
#line 5041
      a --;
#line 5041
      if (tmp___6 != 0) {

      } else {
#line 5041
        goto while_break___6;
      }
      {
#line 5045
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 5045
        if (k > w + l) {

        } else {
#line 5045
          goto while_break___7;
        }
#line 5047
        h ++;
#line 5048
        w += l;
#line 5051
        z = (unsigned int )(g - w);
#line 5051
        if (z > (unsigned int )l) {
#line 5051
          z = (unsigned int )l;
        } else {
#line 5051
          z = z;
        }
#line 5052
        j = (unsigned int )(k - w);
#line 5052
        f = (unsigned int )(1 << j);
#line 5052
        if (f > a + 1U) {
#line 5054
          f -= a + 1U;
#line 5055
          xp = c + k;
#line 5056
          if (j < z) {
            {
#line 5057
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 5057
              j ++;
#line 5057
              if (j < z) {

              } else {
#line 5057
                goto while_break___8;
              }
#line 5059
              f <<= 1;
#line 5059
              xp ++;
#line 5059
              if (f <= *xp) {
#line 5060
                goto while_break___8;
              } else {

              }
#line 5061
              f -= *xp;
            }
            while_break___8: /* CIL Label */ ;
            }
          } else {

          }
        } else {

        }
#line 5064
        z = (unsigned int )(1 << j);
#line 5067
        tmp___3 = malloc((z + 1U) * sizeof(struct huft ));
#line 5067
        q = (struct huft *)tmp___3;
#line 5067
        if ((unsigned int )q == (unsigned int )((struct huft *)((void *)0))) {
#line 5070
          if (h != 0) {
#line 5071
            huft_free(u[0]);
          } else {

          }
#line 5072
          __retres40 = 3;
#line 5072
          goto return_label;
        } else {

        }
#line 5074
        hufts += z + 1U;
#line 5075
        *t = q + 1;
#line 5076
        t = & q->v.t;
#line 5076
        *t = (struct huft *)((void *)0);
#line 5077
        q ++;
#line 5077
        u[h] = q;
#line 5080
        if (h != 0) {
#line 5082
          x[h] = i;
#line 5083
          r.b = (uch )l;
#line 5084
          r.e = (uch )(16U + j);
#line 5085
          r.v.t = q;
#line 5086
          j = i >> (w - l);
#line 5087
          mem_36 = u[h - 1] + j;
#line 5087
          *mem_36 = r;
        } else {

        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 5092
      r.b = (uch )(k - w);
#line 5093
      if ((unsigned int )p >= (unsigned int )(v + n)) {
#line 5094
        r.e = (uch )99;
      } else
#line 5095
      if (*p < s) {
#line 5097
        if (*p < 256U) {
#line 5097
          tmp___4 = 16;
        } else {
#line 5097
          tmp___4 = 15;
        }
#line 5097
        r.e = (uch )tmp___4;
#line 5098
        r.v.n = (ush )*p;
#line 5099
        p ++;
      } else {
#line 5103
        mem_37 = e + (*p - s);
#line 5103
        r.e = (uch )*mem_37;
#line 5104
        tmp___5 = p;
#line 5104
        p ++;
#line 5104
        mem_38 = d + (*tmp___5 - s);
#line 5104
        r.v.n = *mem_38;
      }
#line 5108
      f = (unsigned int )(1 << (k - w));
#line 5109
      j = i >> w;
      {
#line 5109
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 5109
        if (j < z) {

        } else {
#line 5109
          goto while_break___9;
        }
#line 5110
        mem_39 = q + j;
#line 5110
        *mem_39 = r;
#line 5109
        j += f;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 5113
      j = (unsigned int )(1 << (k - 1));
      {
#line 5113
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 5113
        if ((i & j) != 0) {

        } else {
#line 5113
          goto while_break___10;
        }
#line 5114
        i ^= j;
#line 5113
        j >>= 1;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 5115
      i ^= j;
      {
#line 5118
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 5118
        if ((i & (unsigned int )((1 << w) - 1)) != x[h]) {

        } else {
#line 5118
          goto while_break___11;
        }
#line 5120
        h --;
#line 5121
        w -= l;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 5038
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 5128
  if (y != 0) {
#line 5128
    if (g != 1) {
#line 5128
      tmp___7 = 1;
    } else {
#line 5128
      tmp___7 = 0;
    }
  } else {
#line 5128
    tmp___7 = 0;
  }
#line 5128
  __retres40 = tmp___7;
  return_label: /* CIL Label */ 
#line 4933
  return (__retres40);
}
}
#line 5133 "gzip.c"
int huft_free(struct huft *t ) 
{ 
  register struct huft *p ;
  register struct huft *q ;
  int __retres4 ;

  {
#line 5143
  p = t;
  {
#line 5144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5144
    if ((unsigned int )p != (unsigned int )((struct huft *)((void *)0))) {

    } else {
#line 5144
      goto while_break;
    }
#line 5146
    p --;
#line 5146
    q = p->v.t;
#line 5147
    free((void *)((char *)p));
#line 5148
    p = q;
  }
  while_break: /* CIL Label */ ;
  }
#line 5150
  __retres4 = 0;
#line 5133
  return (__retres4);
}
}
#line 5154 "gzip.c"
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) 
{ 
  register unsigned int e ;
  unsigned int n ;
  unsigned int d ;
  unsigned int w ;
  struct huft *t ;
  unsigned int ml ;
  unsigned int md ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  int __retres37 ;

  {
#line 5170
  b = bb;
#line 5171
  k = bk;
#line 5172
  w = outcnt;
#line 5175
  ml = (unsigned int )mask_bits[bl];
#line 5176
  md = (unsigned int )mask_bits[bd];
  {
#line 5177
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5179
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5179
      if (k < (unsigned int )bl) {

      } else {
#line 5179
        goto while_break___0;
      }
#line 5179
      if (inptr < insize) {
#line 5179
        tmp = inptr;
#line 5179
        inptr ++;
#line 5179
        tmp___1 = (int )inbuf[tmp];
      } else {
#line 5179
        outcnt = w;
#line 5179
        tmp___0 = fill_inbuf(0);
#line 5179
        tmp___1 = tmp___0;
      }
#line 5179
      b |= (ulg )((uch )tmp___1) << k;
#line 5179
      k += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5180
    t = tl + ((unsigned int )b & ml);
#line 5180
    e = (unsigned int )t->e;
#line 5180
    if (e > 16U) {
      {
#line 5181
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5182
        if (e == 99U) {
#line 5183
          __retres37 = 1;
#line 5183
          goto return_label;
        } else {

        }
#line 5184
        b >>= (int )t->b;
#line 5184
        k -= (unsigned int )t->b;
#line 5185
        e -= 16U;
        {
#line 5186
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 5186
          if (k < e) {

          } else {
#line 5186
            goto while_break___2;
          }
#line 5186
          if (inptr < insize) {
#line 5186
            tmp___2 = inptr;
#line 5186
            inptr ++;
#line 5186
            tmp___4 = (int )inbuf[tmp___2];
          } else {
#line 5186
            outcnt = w;
#line 5186
            tmp___3 = fill_inbuf(0);
#line 5186
            tmp___4 = tmp___3;
          }
#line 5186
          b |= (ulg )((uch )tmp___4) << k;
#line 5186
          k += 8U;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 5181
        t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 5181
        e = (unsigned int )t->e;
#line 5181
        if (e > 16U) {

        } else {
#line 5181
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {

    }
#line 5188
    b >>= (int )t->b;
#line 5188
    k -= (unsigned int )t->b;
#line 5189
    if (e == 16U) {
#line 5191
      tmp___5 = w;
#line 5191
      w ++;
#line 5191
      window[tmp___5] = (uch )t->v.n;
#line 5193
      if (w == 32768U) {
#line 5195
        outcnt = w;
#line 5195
        flush_window();
#line 5196
        w = 0U;
      } else {

      }
    } else {
#line 5202
      if (e == 15U) {
#line 5203
        goto while_break;
      } else {

      }
      {
#line 5206
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 5206
        if (k < e) {

        } else {
#line 5206
          goto while_break___3;
        }
#line 5206
        if (inptr < insize) {
#line 5206
          tmp___6 = inptr;
#line 5206
          inptr ++;
#line 5206
          tmp___8 = (int )inbuf[tmp___6];
        } else {
#line 5206
          outcnt = w;
#line 5206
          tmp___7 = fill_inbuf(0);
#line 5206
          tmp___8 = tmp___7;
        }
#line 5206
        b |= (ulg )((uch )tmp___8) << k;
#line 5206
        k += 8U;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 5207
      n = (unsigned int )t->v.n + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 5208
      b >>= e;
#line 5208
      k -= e;
      {
#line 5211
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 5211
        if (k < (unsigned int )bd) {

        } else {
#line 5211
          goto while_break___4;
        }
#line 5211
        if (inptr < insize) {
#line 5211
          tmp___9 = inptr;
#line 5211
          inptr ++;
#line 5211
          tmp___11 = (int )inbuf[tmp___9];
        } else {
#line 5211
          outcnt = w;
#line 5211
          tmp___10 = fill_inbuf(0);
#line 5211
          tmp___11 = tmp___10;
        }
#line 5211
        b |= (ulg )((uch )tmp___11) << k;
#line 5211
        k += 8U;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 5212
      t = td + ((unsigned int )b & md);
#line 5212
      e = (unsigned int )t->e;
#line 5212
      if (e > 16U) {
        {
#line 5213
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 5214
          if (e == 99U) {
#line 5215
            __retres37 = 1;
#line 5215
            goto return_label;
          } else {

          }
#line 5216
          b >>= (int )t->b;
#line 5216
          k -= (unsigned int )t->b;
#line 5217
          e -= 16U;
          {
#line 5218
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 5218
            if (k < e) {

            } else {
#line 5218
              goto while_break___6;
            }
#line 5218
            if (inptr < insize) {
#line 5218
              tmp___12 = inptr;
#line 5218
              inptr ++;
#line 5218
              tmp___14 = (int )inbuf[tmp___12];
            } else {
#line 5218
              outcnt = w;
#line 5218
              tmp___13 = fill_inbuf(0);
#line 5218
              tmp___14 = tmp___13;
            }
#line 5218
            b |= (ulg )((uch )tmp___14) << k;
#line 5218
            k += 8U;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 5213
          t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 5213
          e = (unsigned int )t->e;
#line 5213
          if (e > 16U) {

          } else {
#line 5213
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {

      }
#line 5220
      b >>= (int )t->b;
#line 5220
      k -= (unsigned int )t->b;
      {
#line 5221
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 5221
        if (k < e) {

        } else {
#line 5221
          goto while_break___7;
        }
#line 5221
        if (inptr < insize) {
#line 5221
          tmp___15 = inptr;
#line 5221
          inptr ++;
#line 5221
          tmp___17 = (int )inbuf[tmp___15];
        } else {
#line 5221
          outcnt = w;
#line 5221
          tmp___16 = fill_inbuf(0);
#line 5221
          tmp___17 = tmp___16;
        }
#line 5221
        b |= (ulg )((uch )tmp___17) << k;
#line 5221
        k += 8U;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 5222
      d = (w - (unsigned int )t->v.n) - ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 5223
      b >>= e;
#line 5223
      k -= e;
      {
#line 5227
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 5228
        d &= 32767U;
#line 5228
        if (d > w) {
#line 5228
          tmp___19 = d;
        } else {
#line 5228
          tmp___19 = w;
        }
#line 5228
        e = 32768U - tmp___19;
#line 5228
        if (e > n) {
#line 5228
          e = n;
        } else {
#line 5228
          e = e;
        }
#line 5228
        n -= e;
#line 5230
        if (w - d >= e) {
#line 5232
          memcpy((void * __restrict  )(window + w), (void const   * __restrict  )(window + d),
                 e);
#line 5233
          w += e;
#line 5234
          d += e;
        } else {
          {
#line 5238
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 5239
            tmp___20 = w;
#line 5239
            w ++;
#line 5239
            tmp___21 = d;
#line 5239
            d ++;
#line 5239
            window[tmp___20] = window[tmp___21];
#line 5238
            e --;
#line 5238
            if (e != 0) {

            } else {
#line 5238
              goto while_break___9;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 5242
        if (w == 32768U) {
#line 5244
          outcnt = w;
#line 5244
          flush_window();
#line 5245
          w = 0U;
        } else {

        }
#line 5227
        if (n != 0) {

        } else {
#line 5227
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5253
  outcnt = w;
#line 5254
  bb = b;
#line 5255
  bk = k;
#line 5258
  __retres37 = 0;
  return_label: /* CIL Label */ 
#line 5154
  return (__retres37);
}
}
#line 5263 "gzip.c"
int inflate_stored(void) 
{ 
  unsigned int n ;
  unsigned int w ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  int __retres16 ;

  {
#line 5273
  b = bb;
#line 5274
  k = bk;
#line 5275
  w = outcnt;
#line 5279
  n = k & 7U;
#line 5280
  b >>= n;
#line 5280
  k -= n;
  {
#line 5284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5284
    if (k < 16U) {

    } else {
#line 5284
      goto while_break;
    }
#line 5284
    if (inptr < insize) {
#line 5284
      tmp = inptr;
#line 5284
      inptr ++;
#line 5284
      tmp___1 = (int )inbuf[tmp];
    } else {
#line 5284
      outcnt = w;
#line 5284
      tmp___0 = fill_inbuf(0);
#line 5284
      tmp___1 = tmp___0;
    }
#line 5284
    b |= (ulg )((uch )tmp___1) << k;
#line 5284
    k += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 5285
  n = (unsigned int )b & 65535U;
#line 5286
  b >>= 16;
#line 5286
  k -= 16U;
  {
#line 5287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5287
    if (k < 16U) {

    } else {
#line 5287
      goto while_break___0;
    }
#line 5287
    if (inptr < insize) {
#line 5287
      tmp___2 = inptr;
#line 5287
      inptr ++;
#line 5287
      tmp___4 = (int )inbuf[tmp___2];
    } else {
#line 5287
      outcnt = w;
#line 5287
      tmp___3 = fill_inbuf(0);
#line 5287
      tmp___4 = tmp___3;
    }
#line 5287
    b |= (ulg )((uch )tmp___4) << k;
#line 5287
    k += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5288
  if (n != (unsigned int )(~ b & 65535UL)) {
#line 5289
    __retres16 = 1;
#line 5289
    goto return_label;
  } else {

  }
#line 5290
  b >>= 16;
#line 5290
  k -= 16U;
  {
#line 5294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5294
    tmp___9 = n;
#line 5294
    n --;
#line 5294
    if (tmp___9 != 0) {

    } else {
#line 5294
      goto while_break___1;
    }
    {
#line 5296
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5296
      if (k < 8U) {

      } else {
#line 5296
        goto while_break___2;
      }
#line 5296
      if (inptr < insize) {
#line 5296
        tmp___5 = inptr;
#line 5296
        inptr ++;
#line 5296
        tmp___7 = (int )inbuf[tmp___5];
      } else {
#line 5296
        outcnt = w;
#line 5296
        tmp___6 = fill_inbuf(0);
#line 5296
        tmp___7 = tmp___6;
      }
#line 5296
      b |= (ulg )((uch )tmp___7) << k;
#line 5296
      k += 8U;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 5297
    tmp___8 = w;
#line 5297
    w ++;
#line 5297
    window[tmp___8] = (uch )b;
#line 5298
    if (w == 32768U) {
#line 5300
      outcnt = w;
#line 5300
      flush_window();
#line 5301
      w = 0U;
    } else {

    }
#line 5303
    b >>= 8;
#line 5303
    k -= 8U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5308
  outcnt = w;
#line 5309
  bb = b;
#line 5310
  bk = k;
#line 5311
  __retres16 = 0;
  return_label: /* CIL Label */ 
#line 5263
  return (__retres16);
}
}
#line 5316 "gzip.c"
int inflate_fixed(void) 
{ 
  int i ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int l[288] ;
  int tmp ;
  int __retres8 ;

  {
#line 5330
  i = 0;
  {
#line 5330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5330
    if (i < 144) {

    } else {
#line 5330
      goto while_break;
    }
#line 5331
    l[i] = 8U;
#line 5330
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5332
    if (i < 256) {

    } else {
#line 5332
      goto while_break___0;
    }
#line 5333
    l[i] = 9U;
#line 5332
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5334
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5334
    if (i < 280) {

    } else {
#line 5334
      goto while_break___1;
    }
#line 5335
    l[i] = 7U;
#line 5334
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 5336
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5336
    if (i < 288) {

    } else {
#line 5336
      goto while_break___2;
    }
#line 5337
    l[i] = 8U;
#line 5336
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5338
  bl = 7;
#line 5339
  i = huft_build(l, 288U, 257U, cplens, cplext, & tl, & bl);
#line 5339
  if (i != 0) {
#line 5340
    __retres8 = i;
#line 5340
    goto return_label;
  } else {

  }
#line 5344
  i = 0;
  {
#line 5344
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5344
    if (i < 30) {

    } else {
#line 5344
      goto while_break___3;
    }
#line 5345
    l[i] = 5U;
#line 5344
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5346
  bd = 5;
#line 5347
  i = huft_build(l, 30U, 0U, cpdist, cpdext, & td, & bd);
#line 5347
  if (i > 1) {
#line 5349
    huft_free(tl);
#line 5350
    __retres8 = i;
#line 5350
    goto return_label;
  } else {

  }
#line 5355
  tmp = inflate_codes(tl, td, bl, bd);
#line 5355
  if (tmp != 0) {
#line 5356
    __retres8 = 1;
#line 5356
    goto return_label;
  } else {

  }
#line 5360
  huft_free(tl);
#line 5361
  huft_free(td);
#line 5362
  __retres8 = 0;
  return_label: /* CIL Label */ 
#line 5316
  return (__retres8);
}
}
#line 5367 "gzip.c"
int inflate_dynamic(void) 
{ 
  int i ;
  unsigned int j ;
  unsigned int l ;
  unsigned int m ;
  unsigned int n ;
  unsigned int w ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int nb ;
  unsigned int nl ;
  unsigned int nd ;
  unsigned int ll[316] ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned int tmp___29 ;
  int tmp___30 ;
  int __retres49 ;

  {
#line 5393
  b = bb;
#line 5394
  k = bk;
#line 5395
  w = outcnt;
  {
#line 5399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5399
    if (k < 5U) {

    } else {
#line 5399
      goto while_break;
    }
#line 5399
    if (inptr < insize) {
#line 5399
      tmp = inptr;
#line 5399
      inptr ++;
#line 5399
      tmp___1 = (int )inbuf[tmp];
    } else {
#line 5399
      outcnt = w;
#line 5399
      tmp___0 = fill_inbuf(0);
#line 5399
      tmp___1 = tmp___0;
    }
#line 5399
    b |= (ulg )((uch )tmp___1) << k;
#line 5399
    k += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 5400
  nl = 257U + ((unsigned int )b & 31U);
#line 5401
  b >>= 5;
#line 5401
  k -= 5U;
  {
#line 5402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5402
    if (k < 5U) {

    } else {
#line 5402
      goto while_break___0;
    }
#line 5402
    if (inptr < insize) {
#line 5402
      tmp___2 = inptr;
#line 5402
      inptr ++;
#line 5402
      tmp___4 = (int )inbuf[tmp___2];
    } else {
#line 5402
      outcnt = w;
#line 5402
      tmp___3 = fill_inbuf(0);
#line 5402
      tmp___4 = tmp___3;
    }
#line 5402
    b |= (ulg )((uch )tmp___4) << k;
#line 5402
    k += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5403
  nd = 1U + ((unsigned int )b & 31U);
#line 5404
  b >>= 5;
#line 5404
  k -= 5U;
  {
#line 5405
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5405
    if (k < 4U) {

    } else {
#line 5405
      goto while_break___1;
    }
#line 5405
    if (inptr < insize) {
#line 5405
      tmp___5 = inptr;
#line 5405
      inptr ++;
#line 5405
      tmp___7 = (int )inbuf[tmp___5];
    } else {
#line 5405
      outcnt = w;
#line 5405
      tmp___6 = fill_inbuf(0);
#line 5405
      tmp___7 = tmp___6;
    }
#line 5405
    b |= (ulg )((uch )tmp___7) << k;
#line 5405
    k += 8U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5406
  nb = 4U + ((unsigned int )b & 15U);
#line 5407
  b >>= 4;
#line 5407
  k -= 4U;
#line 5411
  if (nl > 286U) {
#line 5413
    __retres49 = 1;
#line 5413
    goto return_label;
  } else
#line 5411
  if (nd > 30U) {
#line 5413
    __retres49 = 1;
#line 5413
    goto return_label;
  } else {

  }
#line 5417
  j = 0U;
  {
#line 5417
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5417
    if (j < nb) {

    } else {
#line 5417
      goto while_break___2;
    }
    {
#line 5419
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 5419
      if (k < 3U) {

      } else {
#line 5419
        goto while_break___3;
      }
#line 5419
      if (inptr < insize) {
#line 5419
        tmp___8 = inptr;
#line 5419
        inptr ++;
#line 5419
        tmp___10 = (int )inbuf[tmp___8];
      } else {
#line 5419
        outcnt = w;
#line 5419
        tmp___9 = fill_inbuf(0);
#line 5419
        tmp___10 = tmp___9;
      }
#line 5419
      b |= (ulg )((uch )tmp___10) << k;
#line 5419
      k += 8U;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 5420
    ll[border[j]] = (unsigned int )b & 7U;
#line 5421
    b >>= 3;
#line 5421
    k -= 3U;
#line 5417
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 5423
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 5423
    if (j < 19U) {

    } else {
#line 5423
      goto while_break___4;
    }
#line 5424
    ll[border[j]] = 0U;
#line 5423
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 5428
  bl = 7;
#line 5429
  i = huft_build(ll, 19U, 19U, (ush *)((void *)0), (ush *)((void *)0), & tl, & bl);
#line 5429
  if (i != 0) {
#line 5431
    if (i == 1) {
#line 5432
      huft_free(tl);
    } else {

    }
#line 5433
    __retres49 = i;
#line 5433
    goto return_label;
  } else {

  }
#line 5436
  if ((unsigned int )tl == (unsigned int )((void *)0)) {
#line 5437
    __retres49 = 2;
#line 5437
    goto return_label;
  } else {

  }
#line 5440
  n = nl + nd;
#line 5441
  m = (unsigned int )mask_bits[bl];
#line 5442
  l = 0U;
#line 5442
  i = (int )l;
  {
#line 5443
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 5443
    if ((unsigned int )i < n) {

    } else {
#line 5443
      goto while_break___5;
    }
    {
#line 5445
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 5445
      if (k < (unsigned int )bl) {

      } else {
#line 5445
        goto while_break___6;
      }
#line 5445
      if (inptr < insize) {
#line 5445
        tmp___11 = inptr;
#line 5445
        inptr ++;
#line 5445
        tmp___13 = (int )inbuf[tmp___11];
      } else {
#line 5445
        outcnt = w;
#line 5445
        tmp___12 = fill_inbuf(0);
#line 5445
        tmp___13 = tmp___12;
      }
#line 5445
      b |= (ulg )((uch )tmp___13) << k;
#line 5445
      k += 8U;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 5446
    td = tl + ((unsigned int )b & m);
#line 5446
    j = (unsigned int )td->b;
#line 5447
    b >>= j;
#line 5447
    k -= j;
#line 5448
    j = (unsigned int )td->v.n;
#line 5449
    if (j < 16U) {
#line 5450
      tmp___14 = i;
#line 5450
      i ++;
#line 5450
      l = j;
#line 5450
      ll[tmp___14] = l;
    } else
#line 5451
    if (j == 16U) {
      {
#line 5453
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 5453
        if (k < 2U) {

        } else {
#line 5453
          goto while_break___7;
        }
#line 5453
        if (inptr < insize) {
#line 5453
          tmp___15 = inptr;
#line 5453
          inptr ++;
#line 5453
          tmp___17 = (int )inbuf[tmp___15];
        } else {
#line 5453
          outcnt = w;
#line 5453
          tmp___16 = fill_inbuf(0);
#line 5453
          tmp___17 = tmp___16;
        }
#line 5453
        b |= (ulg )((uch )tmp___17) << k;
#line 5453
        k += 8U;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 5454
      j = 3U + ((unsigned int )b & 3U);
#line 5455
      b >>= 2;
#line 5455
      k -= 2U;
#line 5456
      if ((unsigned int )i + j > n) {
#line 5457
        __retres49 = 1;
#line 5457
        goto return_label;
      } else {

      }
      {
#line 5458
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 5458
        tmp___19 = j;
#line 5458
        j --;
#line 5458
        if (tmp___19 != 0) {

        } else {
#line 5458
          goto while_break___8;
        }
#line 5459
        tmp___18 = i;
#line 5459
        i ++;
#line 5459
        ll[tmp___18] = l;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 5461
    if (j == 17U) {
      {
#line 5463
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 5463
        if (k < 3U) {

        } else {
#line 5463
          goto while_break___9;
        }
#line 5463
        if (inptr < insize) {
#line 5463
          tmp___20 = inptr;
#line 5463
          inptr ++;
#line 5463
          tmp___22 = (int )inbuf[tmp___20];
        } else {
#line 5463
          outcnt = w;
#line 5463
          tmp___21 = fill_inbuf(0);
#line 5463
          tmp___22 = tmp___21;
        }
#line 5463
        b |= (ulg )((uch )tmp___22) << k;
#line 5463
        k += 8U;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 5464
      j = 3U + ((unsigned int )b & 7U);
#line 5465
      b >>= 3;
#line 5465
      k -= 3U;
#line 5466
      if ((unsigned int )i + j > n) {
#line 5467
        __retres49 = 1;
#line 5467
        goto return_label;
      } else {

      }
      {
#line 5468
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 5468
        tmp___24 = j;
#line 5468
        j --;
#line 5468
        if (tmp___24 != 0) {

        } else {
#line 5468
          goto while_break___10;
        }
#line 5469
        tmp___23 = i;
#line 5469
        i ++;
#line 5469
        ll[tmp___23] = 0U;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 5470
      l = 0U;
    } else {
      {
#line 5474
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 5474
        if (k < 7U) {

        } else {
#line 5474
          goto while_break___11;
        }
#line 5474
        if (inptr < insize) {
#line 5474
          tmp___25 = inptr;
#line 5474
          inptr ++;
#line 5474
          tmp___27 = (int )inbuf[tmp___25];
        } else {
#line 5474
          outcnt = w;
#line 5474
          tmp___26 = fill_inbuf(0);
#line 5474
          tmp___27 = tmp___26;
        }
#line 5474
        b |= (ulg )((uch )tmp___27) << k;
#line 5474
        k += 8U;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 5475
      j = 11U + ((unsigned int )b & 127U);
#line 5476
      b >>= 7;
#line 5476
      k -= 7U;
#line 5477
      if ((unsigned int )i + j > n) {
#line 5478
        __retres49 = 1;
#line 5478
        goto return_label;
      } else {

      }
      {
#line 5479
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 5479
        tmp___29 = j;
#line 5479
        j --;
#line 5479
        if (tmp___29 != 0) {

        } else {
#line 5479
          goto while_break___12;
        }
#line 5480
        tmp___28 = i;
#line 5480
        i ++;
#line 5480
        ll[tmp___28] = 0U;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 5481
      l = 0U;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 5487
  huft_free(tl);
#line 5491
  bb = b;
#line 5492
  bk = k;
#line 5496
  bl = lbits;
#line 5497
  i = huft_build(ll, nl, 257U, cplens, cplext, & tl, & bl);
#line 5497
  if (i != 0) {
#line 5499
    if (i == 1) {
#line 5500
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" incomplete literal tree\n");
#line 5501
      huft_free(tl);
    } else {

    }
#line 5503
    __retres49 = i;
#line 5503
    goto return_label;
  } else {

  }
#line 5505
  bd = dbits;
#line 5506
  i = huft_build(ll + nl, nd, 0U, cpdist, cpdext, & td, & bd);
#line 5506
  if (i != 0) {
#line 5508
    if (i == 1) {
#line 5509
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" incomplete distance tree\n");
#line 5514
      huft_free(td);
    } else {

    }
#line 5516
    huft_free(tl);
#line 5517
    __retres49 = i;
#line 5517
    goto return_label;
  } else {

  }
#line 5523
  tmp___30 = inflate_codes(tl, td, bl, bd);
#line 5523
  if (tmp___30 != 0) {
#line 5524
    __retres49 = 1;
#line 5524
    goto return_label;
  } else {

  }
#line 5528
  huft_free(tl);
#line 5529
  huft_free(td);
#line 5530
  __retres49 = 0;
  return_label: /* CIL Label */ 
#line 5367
  return (__retres49);
}
}
#line 5535 "gzip.c"
int inflate_block(int *e ) 
{ 
  unsigned int t ;
  unsigned int w ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int __retres15 ;

  {
#line 5546
  b = bb;
#line 5547
  k = bk;
#line 5548
  w = outcnt;
  {
#line 5552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5552
    if (k < 1U) {

    } else {
#line 5552
      goto while_break;
    }
#line 5552
    if (inptr < insize) {
#line 5552
      tmp = inptr;
#line 5552
      inptr ++;
#line 5552
      tmp___1 = (int )inbuf[tmp];
    } else {
#line 5552
      outcnt = w;
#line 5552
      tmp___0 = fill_inbuf(0);
#line 5552
      tmp___1 = tmp___0;
    }
#line 5552
    b |= (ulg )((uch )tmp___1) << k;
#line 5552
    k += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 5553
  *e = (int )b & 1;
#line 5554
  b >>= 1;
#line 5554
  k --;
  {
#line 5558
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5558
    if (k < 2U) {

    } else {
#line 5558
      goto while_break___0;
    }
#line 5558
    if (inptr < insize) {
#line 5558
      tmp___2 = inptr;
#line 5558
      inptr ++;
#line 5558
      tmp___4 = (int )inbuf[tmp___2];
    } else {
#line 5558
      outcnt = w;
#line 5558
      tmp___3 = fill_inbuf(0);
#line 5558
      tmp___4 = tmp___3;
    }
#line 5558
    b |= (ulg )((uch )tmp___4) << k;
#line 5558
    k += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5559
  t = (unsigned int )b & 3U;
#line 5560
  b >>= 2;
#line 5560
  k -= 2U;
#line 5564
  bb = b;
#line 5565
  bk = k;
#line 5569
  if (t == 2U) {
#line 5570
    tmp___5 = inflate_dynamic();
#line 5570
    __retres15 = tmp___5;
#line 5570
    goto return_label;
  } else {

  }
#line 5571
  if (t == 0U) {
#line 5572
    tmp___6 = inflate_stored();
#line 5572
    __retres15 = tmp___6;
#line 5572
    goto return_label;
  } else {

  }
#line 5573
  if (t == 1U) {
#line 5574
    tmp___7 = inflate_fixed();
#line 5574
    __retres15 = tmp___7;
#line 5574
    goto return_label;
  } else {

  }
#line 5578
  __retres15 = 2;
  return_label: /* CIL Label */ 
#line 5535
  return (__retres15);
}
}
#line 5583 "gzip.c"
int inflate(void) 
{ 
  int e ;
  int r ;
  unsigned int h ;
  int __retres4 ;

  {
#line 5592
  outcnt = 0U;
#line 5593
  bk = 0U;
#line 5594
  bb = (ulg )0;
#line 5598
  h = 0U;
  {
#line 5599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5600
    hufts = 0U;
#line 5601
    r = inflate_block(& e);
#line 5601
    if (r != 0) {
#line 5602
      __retres4 = r;
#line 5602
      goto return_label;
    } else {

    }
#line 5603
    if (hufts > h) {
#line 5604
      h = hufts;
    } else {

    }
#line 5599
    if (e == 0) {

    } else {
#line 5599
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5610
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5610
    if (bk >= 8U) {

    } else {
#line 5610
      goto while_break___0;
    }
#line 5611
    bk -= 8U;
#line 5612
    inptr --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5616
  outcnt = outcnt;
#line 5616
  flush_window();
#line 5623
  __retres4 = 0;
  return_label: /* CIL Label */ 
#line 5583
  return (__retres4);
}
}
#line 5633 "gzip.c"
static int msg_done  =    0;
#line 5636 "gzip.c"
int lzw(int in , int out ) 
{ 
  int __retres3 ;

  {
#line 5639
  if (msg_done != 0) {
#line 5639
    __retres3 = 1;
#line 5639
    goto return_label;
  } else {

  }
#line 5640
  msg_done = 1;
#line 5641
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"output in compress .Z format not supported\n");
#line 5642
  if (in != out) {
#line 5643
    exit_code = 1;
  } else {

  }
#line 5645
  __retres3 = 1;
  return_label: /* CIL Label */ 
#line 5636
  return (__retres3);
}
}
#line 5736 "gzip.c"
static int extra_lbits[29]  = 
#line 5736
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        1,      1,      1,      1, 
        2,      2,      2,      2, 
        3,      3,      3,      3, 
        4,      4,      4,      4, 
        5,      5,      5,      5, 
        0};
#line 5739 "gzip.c"
static int extra_dbits[30]  = 
#line 5739
  {      0,      0,      0,      0, 
        1,      1,      2,      2, 
        3,      3,      4,      4, 
        5,      5,      6,      6, 
        7,      7,      8,      8, 
        9,      9,      10,      10, 
        11,      11,      12,      12, 
        13,      13};
#line 5742 "gzip.c"
static int extra_blbits[19]  = 
#line 5742
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        2,      3,      7};
#line 5821 "gzip.c"
static ct_data dyn_ltree[573]  ;
#line 5822 "gzip.c"
static ct_data dyn_dtree[61]  ;
#line 5824 "gzip.c"
static ct_data static_ltree[288]  ;
#line 5831 "gzip.c"
static ct_data static_dtree[30]  ;
#line 5836 "gzip.c"
static ct_data bl_tree[39]  ;
#line 5849 "gzip.c"
static tree_desc l_desc  =    {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15, 0};
#line 5852 "gzip.c"
static tree_desc d_desc  =    {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
#line 5855 "gzip.c"
static tree_desc bl_desc  =    {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
#line 5859 "gzip.c"
static ush bl_count[16]  ;
#line 5862 "gzip.c"
static uch bl_order[19]  = 
#line 5862
  {      (uch )16,      (uch )17,      (uch )18,      (uch )0, 
        (uch )8,      (uch )7,      (uch )9,      (uch )6, 
        (uch )10,      (uch )5,      (uch )11,      (uch )4, 
        (uch )12,      (uch )3,      (uch )13,      (uch )2, 
        (uch )14,      (uch )1,      (uch )15};
#line 5868 "gzip.c"
static int heap[573]  ;
#line 5869 "gzip.c"
static int heap_len  ;
#line 5870 "gzip.c"
static int heap_max  ;
#line 5875 "gzip.c"
static uch depth[573]  ;
#line 5878 "gzip.c"
static uch length_code[256]  ;
#line 5881 "gzip.c"
static uch dist_code[512]  ;
#line 5887 "gzip.c"
static int base_length[29]  ;
#line 5890 "gzip.c"
static int base_dist[30]  ;
#line 5898 "gzip.c"
static uch flag_buf[4096]  ;
#line 5903 "gzip.c"
static unsigned int last_lit  ;
#line 5904 "gzip.c"
static unsigned int last_dist  ;
#line 5905 "gzip.c"
static unsigned int last_flags  ;
#line 5906 "gzip.c"
static uch flags  ;
#line 5907 "gzip.c"
static uch flag_bit  ;
#line 5913 "gzip.c"
static ulg opt_len  ;
#line 5914 "gzip.c"
static ulg static_len  ;
#line 5916 "gzip.c"
static off_t compressed_len  ;
#line 5918 "gzip.c"
static off_t input_len  ;
#line 5921 "gzip.c"
ush *file_type  ;
#line 5922 "gzip.c"
int *file_method  ;
#line 5935
static void init_block(void) ;
#line 5936
static void pqdownheap(ct_data *tree , int k ) ;
#line 5937
static void gen_bitlen(tree_desc *desc ) ;
#line 5938
static void gen_codes(ct_data *tree , int max_code ) ;
#line 5939
static void build_tree_1(tree_desc *desc ) ;
#line 5940
static void scan_tree(ct_data *tree , int max_code ) ;
#line 5941
static void send_tree(ct_data *tree , int max_code ) ;
#line 5942
static int build_bl_tree(void) ;
#line 5943
static void send_all_trees(int lcodes , int dcodes , int blcodes ) ;
#line 5944
static void compress_block(ct_data *ltree , ct_data *dtree ) ;
#line 5945
static void set_file_type(void) ;
#line 5973 "gzip.c"
void ct_init(ush *attr , int *methodp ) 
{ 
  int n ;
  int bits ;
  int length ;
  int code ;
  int dist ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 5983
  file_type = attr;
#line 5984
  file_method = methodp;
#line 5985
  input_len = 0L;
#line 5985
  compressed_len = input_len;
#line 5987
  if ((int )static_dtree[0].dl.len != 0) {

#line 5987
    goto return_label;
  } else {

  }
#line 5990
  length = 0;
#line 5991
  code = 0;
  {
#line 5991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5991
    if (code < 28) {

    } else {
#line 5991
      goto while_break;
    }
#line 5992
    base_length[code] = length;
#line 5993
    n = 0;
    {
#line 5993
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5993
      if (n < 1 << extra_lbits[code]) {

      } else {
#line 5993
        goto while_break___0;
      }
#line 5994
      tmp = length;
#line 5994
      length ++;
#line 5994
      length_code[tmp] = (uch )code;
#line 5993
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5991
    code ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6002
  length_code[length - 1] = (uch )code;
#line 6005
  dist = 0;
#line 6006
  code = 0;
  {
#line 6006
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6006
    if (code < 16) {

    } else {
#line 6006
      goto while_break___1;
    }
#line 6007
    base_dist[code] = dist;
#line 6008
    n = 0;
    {
#line 6008
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6008
      if (n < 1 << extra_dbits[code]) {

      } else {
#line 6008
        goto while_break___2;
      }
#line 6009
      tmp___0 = dist;
#line 6009
      dist ++;
#line 6009
      dist_code[tmp___0] = (uch )code;
#line 6008
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 6006
    code ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6013
  dist >>= 7;
  {
#line 6014
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 6014
    if (code < 30) {

    } else {
#line 6014
      goto while_break___3;
    }
#line 6015
    base_dist[code] = dist << 7;
#line 6016
    n = 0;
    {
#line 6016
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 6016
      if (n < 1 << (extra_dbits[code] - 7)) {

      } else {
#line 6016
        goto while_break___4;
      }
#line 6017
      tmp___1 = dist;
#line 6017
      dist ++;
#line 6017
      dist_code[256 + tmp___1] = (uch )code;
#line 6016
      n ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 6014
    code ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 6023
  bits = 0;
  {
#line 6023
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 6023
    if (bits <= 15) {

    } else {
#line 6023
      goto while_break___5;
    }
#line 6023
    bl_count[bits] = (ush )0;
#line 6023
    bits ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 6024
  n = 0;
  {
#line 6025
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 6025
    if (n <= 143) {

    } else {
#line 6025
      goto while_break___6;
    }
#line 6025
    tmp___2 = n;
#line 6025
    n ++;
#line 6025
    static_ltree[tmp___2].dl.len = (ush )8;
#line 6025
    bl_count[8] = (ush )((int )bl_count[8] + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 6026
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 6026
    if (n <= 255) {

    } else {
#line 6026
      goto while_break___7;
    }
#line 6026
    tmp___3 = n;
#line 6026
    n ++;
#line 6026
    static_ltree[tmp___3].dl.len = (ush )9;
#line 6026
    bl_count[9] = (ush )((int )bl_count[9] + 1);
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 6027
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 6027
    if (n <= 279) {

    } else {
#line 6027
      goto while_break___8;
    }
#line 6027
    tmp___4 = n;
#line 6027
    n ++;
#line 6027
    static_ltree[tmp___4].dl.len = (ush )7;
#line 6027
    bl_count[7] = (ush )((int )bl_count[7] + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 6028
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 6028
    if (n <= 287) {

    } else {
#line 6028
      goto while_break___9;
    }
#line 6028
    tmp___5 = n;
#line 6028
    n ++;
#line 6028
    static_ltree[tmp___5].dl.len = (ush )8;
#line 6028
    bl_count[8] = (ush )((int )bl_count[8] + 1);
  }
  while_break___9: /* CIL Label */ ;
  }
#line 6033
  gen_codes(static_ltree, 287);
#line 6036
  n = 0;
  {
#line 6036
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 6036
    if (n < 30) {

    } else {
#line 6036
      goto while_break___10;
    }
#line 6037
    static_dtree[n].dl.len = (ush )5;
#line 6038
    tmp___6 = bi_reverse((unsigned int )n, 5);
#line 6038
    static_dtree[n].fc.code = (ush )tmp___6;
#line 6036
    n ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 6042
  init_block();

  return_label: /* CIL Label */ 
#line 5973
  return;
}
}
#line 6048 "gzip.c"
static void init_block(void) 
{ 
  int n ;

  {
#line 6053
  n = 0;
  {
#line 6053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6053
    if (n < 286) {

    } else {
#line 6053
      goto while_break;
    }
#line 6053
    dyn_ltree[n].fc.freq = (ush )0;
#line 6053
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6054
  n = 0;
  {
#line 6054
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6054
    if (n < 30) {

    } else {
#line 6054
      goto while_break___0;
    }
#line 6054
    dyn_dtree[n].fc.freq = (ush )0;
#line 6054
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6055
  n = 0;
  {
#line 6055
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6055
    if (n < 19) {

    } else {
#line 6055
      goto while_break___1;
    }
#line 6055
    bl_tree[n].fc.freq = (ush )0;
#line 6055
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6057
  dyn_ltree[256].fc.freq = (ush )1;
#line 6058
  static_len = (ulg )0L;
#line 6058
  opt_len = static_len;
#line 6059
  last_flags = 0U;
#line 6059
  last_dist = last_flags;
#line 6059
  last_lit = last_dist;
#line 6060
  flags = (uch )0;
#line 6060
  flag_bit = (uch )1;

#line 6048
  return;
}
}
#line 6092 "gzip.c"
static void pqdownheap(ct_data *tree , int k ) 
{ 
  int v ;
  int j ;
  ct_data *mem_5 ;
  ct_data *mem_6 ;
  ct_data *mem_7 ;
  ct_data *mem_8 ;
  ct_data *mem_9 ;
  ct_data *mem_10 ;
  ct_data *mem_11 ;
  ct_data *mem_12 ;

  {
#line 6096
  v = heap[k];
#line 6097
  j = k << 1;
  {
#line 6098
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6098
    if (j <= heap_len) {

    } else {
#line 6098
      goto while_break;
    }
#line 6100
    if (j < heap_len) {
      {
#line 6100
      mem_5 = tree + heap[j + 1];
#line 6100
      mem_6 = tree + heap[j];
#line 6100
      if ((int )mem_5->fc.freq < (int )mem_6->fc.freq) {
#line 6100
        j ++;
      } else {
        {
#line 6100
        mem_7 = tree + heap[j + 1];
#line 6100
        mem_8 = tree + heap[j];
#line 6100
        if ((int )mem_7->fc.freq == (int )mem_8->fc.freq) {
#line 6100
          if ((int )depth[heap[j + 1]] <= (int )depth[heap[j]]) {
#line 6100
            j ++;
          } else {

          }
        } else {

        }
        }
      }
      }
    } else {

    }
    {
#line 6103
    mem_9 = tree + v;
#line 6103
    mem_10 = tree + heap[j];
#line 6103
    if ((int )mem_9->fc.freq < (int )mem_10->fc.freq) {
#line 6103
      goto while_break;
    } else {
      {
#line 6103
      mem_11 = tree + v;
#line 6103
      mem_12 = tree + heap[j];
#line 6103
      if ((int )mem_11->fc.freq == (int )mem_12->fc.freq) {
#line 6103
        if ((int )depth[v] <= (int )depth[heap[j]]) {
#line 6103
          goto while_break;
        } else {

        }
      } else {

      }
      }
    }
    }
#line 6106
    heap[k] = heap[j];
#line 6106
    k = j;
#line 6109
    j <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 6111
  heap[k] = v;

#line 6092
  return;
}
}
#line 6124 "gzip.c"
static void gen_bitlen(tree_desc *desc ) 
{ 
  ct_data *tree ;
  int *extra ;
  int base ;
  int max_code ;
  int max_length ;
  ct_data *stree ;
  int h ;
  int n ;
  int m ;
  int bits ;
  int xbits ;
  ush f ;
  int overflow ;
  ct_data *mem_15 ;
  ct_data *mem_16 ;
  ct_data *mem_17 ;
  ct_data *mem_18 ;
  int *mem_19 ;
  ct_data *mem_20 ;
  ct_data *mem_21 ;
  ct_data *mem_22 ;
  ct_data *mem_23 ;
  ct_data *mem_24 ;
  ct_data *mem_25 ;

  {
#line 6127
  tree = desc->dyn_tree;
#line 6128
  extra = desc->extra_bits;
#line 6129
  base = desc->extra_base;
#line 6130
  max_code = desc->max_code;
#line 6131
  max_length = desc->max_length;
#line 6132
  stree = desc->static_tree;
#line 6138
  overflow = 0;
#line 6140
  bits = 0;
  {
#line 6140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6140
    if (bits <= 15) {

    } else {
#line 6140
      goto while_break;
    }
#line 6140
    bl_count[bits] = (ush )0;
#line 6140
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6145
  mem_15 = tree + heap[heap_max];
#line 6145
  mem_15->dl.len = (ush )0;
#line 6147
  h = heap_max + 1;
  {
#line 6147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6147
    if (h < 573) {

    } else {
#line 6147
      goto while_break___0;
    }
#line 6148
    n = heap[h];
#line 6149
    mem_16 = tree + n;
#line 6149
    mem_17 = tree + mem_16->dl.dad;
#line 6149
    bits = (int )mem_17->dl.len + 1;
#line 6150
    if (bits > max_length) {
#line 6150
      bits = max_length;
#line 6150
      overflow ++;
    } else {

    }
#line 6151
    mem_18 = tree + n;
#line 6151
    mem_18->dl.len = (ush )bits;
#line 6154
    if (n > max_code) {
#line 6154
      goto __Cont;
    } else {

    }
#line 6156
    bl_count[bits] = (ush )((int )bl_count[bits] + 1);
#line 6157
    xbits = 0;
#line 6158
    if (n >= base) {
#line 6158
      mem_19 = extra + (n - base);
#line 6158
      xbits = *mem_19;
    } else {

    }
#line 6159
    mem_20 = tree + n;
#line 6159
    f = mem_20->fc.freq;
#line 6160
    opt_len += (ulg )f * (ulg )(bits + xbits);
#line 6161
    if (stree != 0) {
#line 6161
      mem_21 = stree + n;
#line 6161
      static_len += (ulg )f * (ulg )((int )mem_21->dl.len + xbits);
    } else {

    }
    __Cont: /* CIL Label */ 
#line 6147
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6163
  if (overflow == 0) {

#line 6163
    goto return_label;
  } else {

  }
  {
#line 6169
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6170
    bits = max_length - 1;
    {
#line 6171
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6171
      if ((int )bl_count[bits] == 0) {

      } else {
#line 6171
        goto while_break___2;
      }
#line 6171
      bits --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 6172
    bl_count[bits] = (ush )((int )bl_count[bits] - 1);
#line 6173
    bl_count[bits + 1] = (ush )((int )bl_count[bits + 1] + 2);
#line 6174
    bl_count[max_length] = (ush )((int )bl_count[max_length] - 1);
#line 6178
    overflow -= 2;
#line 6169
    if (overflow > 0) {

    } else {
#line 6169
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6186
  bits = max_length;
  {
#line 6186
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 6186
    if (bits != 0) {

    } else {
#line 6186
      goto while_break___3;
    }
#line 6187
    n = (int )bl_count[bits];
    {
#line 6188
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 6188
      if (n != 0) {

      } else {
#line 6188
        goto while_break___4;
      }
#line 6189
      h --;
#line 6189
      m = heap[h];
#line 6190
      if (m > max_code) {
#line 6190
        goto while_continue___4;
      } else {

      }
      {
#line 6191
      mem_22 = tree + m;
#line 6191
      if ((unsigned int )mem_22->dl.len != (unsigned int )bits) {
#line 6193
        mem_23 = tree + m;
#line 6193
        mem_24 = tree + m;
#line 6193
        opt_len += (ulg )(((long )bits - (long )mem_23->dl.len) * (long )mem_24->fc.freq);
#line 6194
        mem_25 = tree + m;
#line 6194
        mem_25->dl.len = (ush )bits;
      } else {

      }
      }
#line 6196
      n --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 6186
    bits --;
  }
  while_break___3: /* CIL Label */ ;
  }

  return_label: /* CIL Label */ 
#line 6124
  return;
}
}
#line 6209 "gzip.c"
static void gen_codes(ct_data *tree , int max_code ) 
{ 
  ush next_code[16] ;
  ush code ;
  int bits ;
  int n ;
  int len ;
  ush tmp ;
  unsigned int tmp___0 ;
  ct_data *mem_10 ;
  ct_data *mem_11 ;

  {
#line 6214
  code = (ush )0;
#line 6221
  bits = 1;
  {
#line 6221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6221
    if (bits <= 15) {

    } else {
#line 6221
      goto while_break;
    }
#line 6222
    code = (ush )(((int )code + (int )bl_count[bits - 1]) << 1);
#line 6222
    next_code[bits] = code;
#line 6221
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6231
  n = 0;
  {
#line 6231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6231
    if (n <= max_code) {

    } else {
#line 6231
      goto while_break___0;
    }
#line 6232
    mem_10 = tree + n;
#line 6232
    len = (int )mem_10->dl.len;
#line 6233
    if (len == 0) {
#line 6233
      goto __Cont;
    } else {

    }
#line 6235
    tmp = next_code[len];
#line 6235
    next_code[len] = (ush )((int )next_code[len] + 1);
#line 6235
    tmp___0 = bi_reverse((unsigned int )tmp, len);
#line 6235
    mem_11 = tree + n;
#line 6235
    mem_11->fc.code = (ush )tmp___0;
    __Cont: /* CIL Label */ 
#line 6231
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }

#line 6209
  return;
}
}
#line 6250 "gzip.c"
static void build_tree_1(tree_desc *desc ) 
{ 
  ct_data *tree ;
  ct_data *stree ;
  int elems ;
  int n ;
  int m ;
  int max_code ;
  int node ;
  int new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ush tmp___2 ;
  int tmp___3 ;
  ct_data *mem_15 ;
  ct_data *mem_16 ;
  ct_data *mem_17 ;
  ct_data *mem_18 ;
  ct_data *mem_19 ;
  ct_data *mem_20 ;
  ct_data *mem_21 ;
  ct_data *mem_22 ;
  ct_data *mem_23 ;

  {
#line 6253
  tree = desc->dyn_tree;
#line 6254
  stree = desc->static_tree;
#line 6255
  elems = desc->elems;
#line 6257
  max_code = -1;
#line 6258
  node = elems;
#line 6264
  heap_len = 0;
#line 6264
  heap_max = 573;
#line 6266
  n = 0;
  {
#line 6266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6266
    if (n < elems) {

    } else {
#line 6266
      goto while_break;
    }
    {
#line 6267
    mem_15 = tree + n;
#line 6267
    if ((int )mem_15->fc.freq != 0) {
#line 6268
      heap_len ++;
#line 6268
      max_code = n;
#line 6268
      heap[heap_len] = max_code;
#line 6269
      depth[n] = (uch )0;
    } else {
#line 6271
      mem_16 = tree + n;
#line 6271
      mem_16->dl.len = (ush )0;
    }
    }
#line 6266
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6280
    if (heap_len < 2) {

    } else {
#line 6280
      goto while_break___0;
    }
#line 6281
    heap_len ++;
#line 6281
    if (max_code < 2) {
#line 6281
      max_code ++;
#line 6281
      tmp = max_code;
    } else {
#line 6281
      tmp = 0;
    }
#line 6281
    heap[heap_len] = tmp;
#line 6281
    new = tmp;
#line 6282
    mem_17 = tree + new;
#line 6282
    mem_17->fc.freq = (ush )1;
#line 6283
    depth[new] = (uch )0;
#line 6284
    opt_len --;
#line 6284
    if (stree != 0) {
#line 6284
      mem_18 = stree + new;
#line 6284
      static_len -= (ulg )mem_18->dl.len;
    } else {

    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6287
  desc->max_code = max_code;
#line 6292
  n = heap_len / 2;
  {
#line 6292
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6292
    if (n >= 1) {

    } else {
#line 6292
      goto while_break___1;
    }
#line 6292
    pqdownheap(tree, n);
#line 6292
    n --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 6297
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 6298
    n = heap[1];
#line 6298
    tmp___0 = heap_len;
#line 6298
    heap_len --;
#line 6298
    heap[1] = heap[tmp___0];
#line 6298
    pqdownheap(tree, 1);
#line 6299
    m = heap[1];
#line 6301
    heap_max --;
#line 6301
    heap[heap_max] = n;
#line 6302
    heap_max --;
#line 6302
    heap[heap_max] = m;
#line 6305
    mem_19 = tree + node;
#line 6305
    mem_20 = tree + n;
#line 6305
    mem_21 = tree + m;
#line 6305
    mem_19->fc.freq = (ush )((int )mem_20->fc.freq + (int )mem_21->fc.freq);
#line 6306
    if ((int )depth[n] >= (int )depth[m]) {
#line 6306
      tmp___1 = (int )depth[n];
    } else {
#line 6306
      tmp___1 = (int )depth[m];
    }
#line 6306
    depth[node] = (uch )(tmp___1 + 1);
#line 6307
    tmp___2 = (ush )node;
#line 6307
    mem_22 = tree + m;
#line 6307
    mem_22->dl.dad = tmp___2;
#line 6307
    mem_23 = tree + n;
#line 6307
    mem_23->dl.dad = tmp___2;
#line 6315
    tmp___3 = node;
#line 6315
    node ++;
#line 6315
    heap[1] = tmp___3;
#line 6316
    pqdownheap(tree, 1);
#line 6297
    if (heap_len >= 2) {

    } else {
#line 6297
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 6320
  heap_max --;
#line 6320
  heap[heap_max] = heap[1];
#line 6325
  gen_bitlen(desc);
#line 6328
  gen_codes(tree, max_code);

#line 6250
  return;
}
}
#line 6337 "gzip.c"
static void scan_tree(ct_data *tree , int max_code ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;
  ct_data *mem_10 ;
  ct_data *mem_11 ;
  ct_data *mem_12 ;

  {
#line 6342
  prevlen = -1;
#line 6344
  mem_10 = tree + 0;
#line 6344
  nextlen = (int )mem_10->dl.len;
#line 6345
  count = 0;
#line 6346
  max_count = 7;
#line 6347
  min_count = 4;
#line 6349
  if (nextlen == 0) {
#line 6349
    max_count = 138;
#line 6349
    min_count = 3;
  } else {

  }
#line 6350
  mem_11 = tree + (max_code + 1);
#line 6350
  mem_11->dl.len = (ush )65535;
#line 6352
  n = 0;
  {
#line 6352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6352
    if (n <= max_code) {

    } else {
#line 6352
      goto while_break;
    }
#line 6353
    curlen = nextlen;
#line 6353
    mem_12 = tree + (n + 1);
#line 6353
    nextlen = (int )mem_12->dl.len;
#line 6354
    count ++;
#line 6354
    if (count < max_count) {
#line 6354
      if (curlen == nextlen) {
#line 6355
        goto __Cont;
      } else {
#line 6354
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 6356
    if (count < min_count) {
#line 6357
      bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + count);
    } else
#line 6358
    if (curlen != 0) {
#line 6359
      if (curlen != prevlen) {
#line 6359
        bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + 1);
      } else {

      }
#line 6360
      bl_tree[16].fc.freq = (ush )((int )bl_tree[16].fc.freq + 1);
    } else
#line 6361
    if (count <= 10) {
#line 6362
      bl_tree[17].fc.freq = (ush )((int )bl_tree[17].fc.freq + 1);
    } else {
#line 6364
      bl_tree[18].fc.freq = (ush )((int )bl_tree[18].fc.freq + 1);
    }
#line 6366
    count = 0;
#line 6366
    prevlen = curlen;
#line 6367
    if (nextlen == 0) {
#line 6368
      max_count = 138;
#line 6368
      min_count = 3;
    } else
#line 6369
    if (curlen == nextlen) {
#line 6370
      max_count = 6;
#line 6370
      min_count = 3;
    } else {
#line 6372
      max_count = 7;
#line 6372
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 6352
    n ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 6337
  return;
}
}
#line 6381 "gzip.c"
static void send_tree(ct_data *tree , int max_code ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;
  ct_data *mem_10 ;
  ct_data *mem_11 ;

  {
#line 6386
  prevlen = -1;
#line 6388
  mem_10 = tree + 0;
#line 6388
  nextlen = (int )mem_10->dl.len;
#line 6389
  count = 0;
#line 6390
  max_count = 7;
#line 6391
  min_count = 4;
#line 6394
  if (nextlen == 0) {
#line 6394
    max_count = 138;
#line 6394
    min_count = 3;
  } else {

  }
#line 6396
  n = 0;
  {
#line 6396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6396
    if (n <= max_code) {

    } else {
#line 6396
      goto while_break;
    }
#line 6397
    curlen = nextlen;
#line 6397
    mem_11 = tree + (n + 1);
#line 6397
    nextlen = (int )mem_11->dl.len;
#line 6398
    count ++;
#line 6398
    if (count < max_count) {
#line 6398
      if (curlen == nextlen) {
#line 6399
        goto __Cont;
      } else {
#line 6398
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 6400
    if (count < min_count) {
      {
#line 6401
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 6401
        send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
#line 6401
        count --;
#line 6401
        if (count != 0) {

        } else {
#line 6401
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 6403
    if (curlen != 0) {
#line 6404
      if (curlen != prevlen) {
#line 6405
        send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
#line 6405
        count --;
      } else {

      }
#line 6408
      send_bits((int )bl_tree[16].fc.code, (int )bl_tree[16].dl.len);
#line 6408
      send_bits(count - 3, 2);
    } else
#line 6410
    if (count <= 10) {
#line 6411
      send_bits((int )bl_tree[17].fc.code, (int )bl_tree[17].dl.len);
#line 6411
      send_bits(count - 3, 3);
    } else {
#line 6414
      send_bits((int )bl_tree[18].fc.code, (int )bl_tree[18].dl.len);
#line 6414
      send_bits(count - 11, 7);
    }
#line 6416
    count = 0;
#line 6416
    prevlen = curlen;
#line 6417
    if (nextlen == 0) {
#line 6418
      max_count = 138;
#line 6418
      min_count = 3;
    } else
#line 6419
    if (curlen == nextlen) {
#line 6420
      max_count = 6;
#line 6420
      min_count = 3;
    } else {
#line 6422
      max_count = 7;
#line 6422
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 6396
    n ++;
  }
  while_break: /* CIL Label */ ;
  }

#line 6381
  return;
}
}
#line 6431 "gzip.c"
static int build_bl_tree(void) 
{ 
  int max_blindex ;

  {
#line 6436
  scan_tree(dyn_ltree, l_desc.max_code);
#line 6437
  scan_tree(dyn_dtree, d_desc.max_code);
#line 6440
  build_tree_1(& bl_desc);
#line 6449
  max_blindex = 18;
  {
#line 6449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6449
    if (max_blindex >= 3) {

    } else {
#line 6449
      goto while_break;
    }
#line 6450
    if ((int )bl_tree[bl_order[max_blindex]].dl.len != 0) {
#line 6450
      goto while_break;
    } else {

    }
#line 6449
    max_blindex --;
  }
  while_break: /* CIL Label */ ;
  }
#line 6453
  opt_len += (ulg )(((3 * (max_blindex + 1) + 5) + 5) + 4);
#line 6456
  return (max_blindex);
}
}
#line 6464 "gzip.c"
static void send_all_trees(int lcodes , int dcodes , int blcodes ) 
{ 
  int rank ;

  {
#line 6473
  send_bits(lcodes - 257, 5);
#line 6474
  send_bits(dcodes - 1, 5);
#line 6475
  send_bits(blcodes - 4, 4);
#line 6476
  rank = 0;
  {
#line 6476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6476
    if (rank < blcodes) {

    } else {
#line 6476
      goto while_break;
    }
#line 6478
    send_bits((int )bl_tree[bl_order[rank]].dl.len, 3);
#line 6476
    rank ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6481
  send_tree(dyn_ltree, lcodes - 1);
#line 6483
  send_tree(dyn_dtree, dcodes - 1);

#line 6464
  return;
}
}
#line 6491 "gzip.c"
off_t flush_block(char *buf , ulg stored_len , int pad , int eof ) 
{ 
  ulg opt_lenb ;
  ulg static_lenb ;
  int max_blindex ;
  off_t __retres8 ;

  {
#line 6500
  flag_buf[last_flags] = flags;
#line 6503
  if ((int )*file_type == 65535) {
#line 6503
    set_file_type();
  } else {

  }
#line 6506
  build_tree_1(& l_desc);
#line 6509
  build_tree_1(& d_desc);
#line 6518
  max_blindex = build_bl_tree();
#line 6521
  opt_lenb = ((opt_len + 3UL) + 7UL) >> 3;
#line 6522
  static_lenb = ((static_len + 3UL) + 7UL) >> 3;
#line 6523
  input_len = (off_t )((ulg )input_len + stored_len);
#line 6529
  if (static_lenb <= opt_lenb) {
#line 6529
    opt_lenb = static_lenb;
  } else {

  }
#line 6538
  if (stored_len <= opt_lenb) {
#line 6538
    if (eof != 0) {
#line 6538
      if (compressed_len == 0L) {
#line 6538
        goto _L___2;
      } else {
#line 6538
        goto _L___2;
      }
    } else {
#line 6538
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 6550
  if (stored_len + 4UL <= opt_lenb) {
#line 6550
    if ((unsigned int )buf != (unsigned int )((char *)0)) {
#line 6559
      send_bits(eof, 3);
#line 6560
      compressed_len = ((compressed_len + 3L) + 7L) & -8L;
#line 6561
      compressed_len = (off_t )((ulg )compressed_len + ((stored_len + 4UL) << 3));
#line 6563
      copy_block(buf, (unsigned int )stored_len, 1);
    } else {
#line 6550
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 6568
  if (static_lenb == opt_lenb) {
#line 6570
    send_bits((1 << 1) + eof, 3);
#line 6571
    compress_block(static_ltree, static_dtree);
#line 6572
    compressed_len = (off_t )((ulg )compressed_len + (3UL + static_len));
  } else {
#line 6574
    send_bits((2 << 1) + eof, 3);
#line 6575
    send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
#line 6576
    compress_block(dyn_ltree, dyn_dtree);
#line 6577
    compressed_len = (off_t )((ulg )compressed_len + (3UL + opt_len));
  }
#line 6580
  init_block();
#line 6582
  if (eof != 0) {
#line 6584
    bi_windup();
#line 6585
    compressed_len += 7L;
  } else
#line 6586
  if (pad != 0) {
#line 6586
    if (compressed_len % 8L != 0L) {
#line 6587
      send_bits(eof, 3);
#line 6588
      compressed_len = ((compressed_len + 3L) + 7L) & -8L;
#line 6589
      copy_block(buf, 0U, 1);
    } else {

    }
  } else {

  }
#line 6592
  __retres8 = compressed_len >> 3;
#line 6491
  return (__retres8);
}
}
#line 6599 "gzip.c"
int ct_tally(int dist , int lc ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  ulg out_length ;
  ulg in_length ;
  int dcode ;
  int tmp___3 ;
  int __retres11 ;

  {
#line 6603
  tmp = last_lit;
#line 6603
  last_lit ++;
#line 6603
  inbuf[tmp] = (uch )lc;
#line 6604
  if (dist == 0) {
#line 6606
    dyn_ltree[lc].fc.freq = (ush )((int )dyn_ltree[lc].fc.freq + 1);
  } else {
#line 6609
    dist --;
#line 6614
    dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq = (ush )((int )dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq + 1);
#line 6615
    if (dist < 256) {
#line 6615
      tmp___0 = (int )dist_code[dist];
    } else {
#line 6615
      tmp___0 = (int )dist_code[256 + (dist >> 7)];
    }
#line 6615
    dyn_dtree[tmp___0].fc.freq = (ush )((int )dyn_dtree[tmp___0].fc.freq + 1);
#line 6617
    tmp___1 = last_dist;
#line 6617
    last_dist ++;
#line 6617
    d_buf[tmp___1] = (ush )dist;
#line 6618
    flags = (uch )((int )flags | (int )flag_bit);
  }
#line 6620
  flag_bit = (uch )((int )flag_bit << 1);
#line 6623
  if ((last_lit & 7U) == 0U) {
#line 6624
    tmp___2 = last_flags;
#line 6624
    last_flags ++;
#line 6624
    flag_buf[tmp___2] = flags;
#line 6625
    flags = (uch )0;
#line 6625
    flag_bit = (uch )1;
  } else {

  }
#line 6628
  if (level > 2) {
#line 6628
    if ((last_lit & 4095U) == 0U) {
#line 6630
      out_length = (ulg )last_lit * 8UL;
#line 6631
      in_length = (ulg )strstart - (ulg )block_start;
#line 6633
      dcode = 0;
      {
#line 6633
      while (1) {
        while_continue: /* CIL Label */ ;
#line 6633
        if (dcode < 30) {

        } else {
#line 6633
          goto while_break;
        }
#line 6634
        out_length += (ulg )dyn_dtree[dcode].fc.freq * (ulg )(5L + (long )extra_dbits[dcode]);
#line 6633
        dcode ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 6636
      out_length >>= 3;
#line 6640
      if (last_dist < last_lit / 2U) {
#line 6640
        if (out_length < in_length / 2UL) {
#line 6640
          __retres11 = 1;
#line 6640
          goto return_label;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 6642
  if (last_lit == 32767U) {
#line 6642
    tmp___3 = 1;
  } else
#line 6642
  if (last_dist == 32768U) {
#line 6642
    tmp___3 = 1;
  } else {
#line 6642
    tmp___3 = 0;
  }
#line 6642
  __retres11 = tmp___3;
  return_label: /* CIL Label */ 
#line 6599
  return (__retres11);
}
}
#line 6652 "gzip.c"
static void compress_block(ct_data *ltree , ct_data *dtree ) 
{ 
  unsigned int dist ;
  int lc ;
  unsigned int lx ;
  unsigned int dx ;
  unsigned int fx ;
  uch flag ;
  unsigned int code ;
  int extra ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  ct_data *mem_14 ;
  ct_data *mem_15 ;
  ct_data *mem_16 ;
  ct_data *mem_17 ;
  ct_data *mem_18 ;
  ct_data *mem_19 ;
  ct_data *mem_20 ;
  ct_data *mem_21 ;

  {
#line 6658
  lx = 0U;
#line 6659
  dx = 0U;
#line 6660
  fx = 0U;
#line 6661
  flag = (uch )0;
#line 6665
  if (last_lit != 0U) {
    {
#line 6665
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6666
      if ((lx & 7U) == 0U) {
#line 6666
        tmp = fx;
#line 6666
        fx ++;
#line 6666
        flag = flag_buf[tmp];
      } else {

      }
#line 6667
      tmp___0 = lx;
#line 6667
      lx ++;
#line 6667
      lc = (int )inbuf[tmp___0];
#line 6668
      if (((int )flag & 1) == 0) {
#line 6669
        mem_14 = ltree + lc;
#line 6669
        mem_15 = ltree + lc;
#line 6669
        send_bits((int )mem_14->fc.code, (int )mem_15->dl.len);
      } else {
#line 6673
        code = (unsigned int )length_code[lc];
#line 6674
        mem_16 = ltree + ((code + 256U) + 1U);
#line 6674
        mem_17 = ltree + ((code + 256U) + 1U);
#line 6674
        send_bits((int )mem_16->fc.code, (int )mem_17->dl.len);
#line 6675
        extra = extra_lbits[code];
#line 6676
        if (extra != 0) {
#line 6677
          lc -= base_length[code];
#line 6678
          send_bits(lc, extra);
        } else {

        }
#line 6680
        tmp___1 = dx;
#line 6680
        dx ++;
#line 6680
        dist = (unsigned int )d_buf[tmp___1];
#line 6682
        if (dist < 256U) {
#line 6682
          code = (unsigned int )dist_code[dist];
        } else {
#line 6682
          code = (unsigned int )dist_code[256U + (dist >> 7)];
        }
#line 6685
        mem_18 = dtree + code;
#line 6685
        mem_19 = dtree + code;
#line 6685
        send_bits((int )mem_18->fc.code, (int )mem_19->dl.len);
#line 6686
        extra = extra_dbits[code];
#line 6687
        if (extra != 0) {
#line 6688
          dist -= (unsigned int )base_dist[code];
#line 6689
          send_bits((int )dist, extra);
        } else {

        }
      }
#line 6692
      flag = (uch )((int )flag >> 1);
#line 6665
      if (lx < last_lit) {

      } else {
#line 6665
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {

  }
#line 6695
  mem_20 = ltree + 256;
#line 6695
  mem_21 = ltree + 256;
#line 6695
  send_bits((int )mem_20->fc.code, (int )mem_21->dl.len);

#line 6652
  return;
}
}
#line 6704 "gzip.c"
static void set_file_type(void) 
{ 
  int n ;
  unsigned int ascii_freq ;
  unsigned int bin_freq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6706
  n = 0;
#line 6707
  ascii_freq = 0U;
#line 6708
  bin_freq = 0U;
  {
#line 6709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6709
    if (n < 7) {

    } else {
#line 6709
      goto while_break;
    }
#line 6709
    tmp = n;
#line 6709
    n ++;
#line 6709
    bin_freq += (unsigned int )dyn_ltree[tmp].fc.freq;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6710
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6710
    if (n < 128) {

    } else {
#line 6710
      goto while_break___0;
    }
#line 6710
    tmp___0 = n;
#line 6710
    n ++;
#line 6710
    ascii_freq += (unsigned int )dyn_ltree[tmp___0].fc.freq;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6711
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6711
    if (n < 256) {

    } else {
#line 6711
      goto while_break___1;
    }
#line 6711
    tmp___1 = n;
#line 6711
    n ++;
#line 6711
    bin_freq += (unsigned int )dyn_ltree[tmp___1].fc.freq;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6712
  if (bin_freq > ascii_freq >> 2) {
#line 6712
    *file_type = (ush )0;
  } else {
#line 6712
    *file_type = (ush )1;
  }
#line 6713
  if ((int )*file_type == 0) {

  } else {

  }

#line 6704
  return;
}
}
#line 6728
static unsigned int decode(unsigned int count , uch *buffer ) ;
#line 6729
static void decode_start(void) ;
#line 6732
static void huf_decode_start(void) ;
#line 6733
static unsigned int decode_c(void) ;
#line 6734
static unsigned int decode_p(void) ;
#line 6735
static void read_pt_len(int nn , int nbit , int i_special ) ;
#line 6736
static void read_c_len(void) ;
#line 6739
static void fillbuf(int n ) ;
#line 6740
static unsigned int getbits(int n ) ;
#line 6741
static void init_getbits(void) ;
#line 6745
static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) ;
#line 6801 "gzip.c"
static uch pt_len[19]  ;
#line 6802 "gzip.c"
static unsigned int blocksize  ;
#line 6803 "gzip.c"
static ush pt_table[256]  ;
#line 6815 "gzip.c"
static ush io_bitbuf  ;
#line 6816 "gzip.c"
static unsigned int subbitbuf  ;
#line 6817 "gzip.c"
static int bitcount  ;
#line 6819 "gzip.c"
static void fillbuf(int n ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6822
  io_bitbuf = (ush )((int )io_bitbuf << n);
  {
#line 6823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6823
    if (n > bitcount) {

    } else {
#line 6823
      goto while_break;
    }
#line 6824
    n -= bitcount;
#line 6824
    io_bitbuf = (ush )((unsigned int )io_bitbuf | (subbitbuf << n));
#line 6825
    if (inptr < insize) {
#line 6825
      tmp = inptr;
#line 6825
      inptr ++;
#line 6825
      tmp___1 = (int )inbuf[tmp];
    } else {
#line 6825
      tmp___0 = fill_inbuf(1);
#line 6825
      tmp___1 = tmp___0;
    }
#line 6825
    subbitbuf = (unsigned int )tmp___1;
#line 6826
    if ((int )subbitbuf == -1) {
#line 6826
      subbitbuf = 0U;
    } else {

    }
#line 6827
    bitcount = 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 6829
  bitcount -= n;
#line 6829
  io_bitbuf = (ush )((unsigned int )io_bitbuf | (subbitbuf >> bitcount));

#line 6819
  return;
}
}
#line 6832 "gzip.c"
static unsigned int getbits(int n ) 
{ 
  unsigned int x ;

  {
#line 6837
  x = (unsigned int )((int )io_bitbuf >> (16U * sizeof(char ) - (unsigned int )n));
#line 6837
  fillbuf(n);
#line 6838
  return (x);
}
}
#line 6841 "gzip.c"
static void init_getbits(void) 
{ 


  {
#line 6843
  io_bitbuf = (ush )0;
#line 6843
  subbitbuf = 0U;
#line 6843
  bitcount = 0;
#line 6844
  fillbuf((int )(16U * sizeof(char )));

#line 6841
  return;
}
}
#line 6851 "gzip.c"
static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) 
{ 
  ush count[17] ;
  ush weight[17] ;
  ush start[18] ;
  ush *p ;
  unsigned int i ;
  unsigned int k ;
  unsigned int len ;
  unsigned int ch ;
  unsigned int jutbits ;
  unsigned int avail ;
  unsigned int nextcode ;
  unsigned int mask ;
  unsigned int tmp ;
  ush tmp___0 ;
  unsigned int tmp___1 ;
  uch *mem_20 ;
  uch *mem_21 ;
  ush *mem_22 ;
  uch *mem_23 ;
  ush *mem_24 ;
  ush *mem_25 ;

  {
#line 6860
  i = 1U;
  {
#line 6860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6860
    if (i <= 16U) {

    } else {
#line 6860
      goto while_break;
    }
#line 6860
    count[i] = (ush )0;
#line 6860
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6861
  i = 0U;
  {
#line 6861
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6861
    if (i < (unsigned int )nchar) {

    } else {
#line 6861
      goto while_break___0;
    }
#line 6861
    mem_20 = bitlen + i;
#line 6861
    mem_21 = bitlen + i;
#line 6861
    count[*mem_20] = (ush )((int )count[*mem_21] + 1);
#line 6861
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6863
  start[1] = (ush )0;
#line 6864
  i = 1U;
  {
#line 6864
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6864
    if (i <= 16U) {

    } else {
#line 6864
      goto while_break___1;
    }
#line 6865
    start[i + 1U] = (ush )((int )start[i] + ((int )count[i] << (16U - i)));
#line 6864
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6866
  if (((int )start[17] & 65535) != 0) {
#line 6867
    error((char *)"Bad table\n");
  } else {

  }
#line 6869
  jutbits = (unsigned int )(16 - tablebits);
#line 6870
  i = 1U;
  {
#line 6870
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 6870
    if (i <= (unsigned int )tablebits) {

    } else {
#line 6870
      goto while_break___2;
    }
#line 6871
    start[i] = (ush )((int )start[i] >> jutbits);
#line 6872
    weight[i] = (ush )(1U << ((unsigned int )tablebits - i));
#line 6870
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 6874
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 6874
    if (i <= 16U) {

    } else {
#line 6874
      goto while_break___3;
    }
#line 6875
    weight[i] = (ush )(1U << (16U - i));
#line 6876
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 6879
  i = (unsigned int )((int )start[tablebits + 1] >> jutbits);
#line 6880
  if (i != 0U) {
#line 6881
    k = (unsigned int )(1 << tablebits);
    {
#line 6882
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 6882
      if (i != k) {

      } else {
#line 6882
        goto while_break___4;
      }
#line 6882
      tmp = i;
#line 6882
      i ++;
#line 6882
      mem_22 = table + tmp;
#line 6882
      *mem_22 = (ush )0;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {

  }
#line 6885
  avail = (unsigned int )nchar;
#line 6886
  mask = 1U << (15 - tablebits);
#line 6887
  ch = 0U;
  {
#line 6887
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 6887
    if (ch < (unsigned int )nchar) {

    } else {
#line 6887
      goto while_break___5;
    }
#line 6888
    mem_23 = bitlen + ch;
#line 6888
    len = (unsigned int )*mem_23;
#line 6888
    if (len == 0U) {
#line 6888
      goto __Cont;
    } else {

    }
#line 6889
    nextcode = (unsigned int )((int )start[len] + (int )weight[len]);
#line 6890
    if (len <= (unsigned int )tablebits) {
#line 6891
      i = (unsigned int )start[len];
      {
#line 6891
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 6891
        if (i < nextcode) {

        } else {
#line 6891
          goto while_break___6;
        }
#line 6891
        mem_24 = table + i;
#line 6891
        *mem_24 = (ush )ch;
#line 6891
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
#line 6893
      k = (unsigned int )start[len];
#line 6894
      p = table + (k >> jutbits);
#line 6895
      i = len - (unsigned int )tablebits;
      {
#line 6896
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 6896
        if (i != 0U) {

        } else {
#line 6896
          goto while_break___7;
        }
#line 6897
        if ((int )*p == 0) {
#line 6898
          tmp___0 = (ush )0;
#line 6898
          prev[avail] = tmp___0;
#line 6898
          mem_25 = (prev + 32768) + avail;
#line 6898
          *mem_25 = tmp___0;
#line 6899
          tmp___1 = avail;
#line 6899
          avail ++;
#line 6899
          *p = (ush )tmp___1;
        } else {

        }
#line 6901
        if ((k & mask) != 0) {
#line 6901
          p = (prev + 32768) + *p;
        } else {
#line 6902
          p = & prev[*p];
        }
#line 6903
        k <<= 1;
#line 6903
        i --;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 6905
      *p = (ush )ch;
    }
#line 6907
    start[len] = (ush )nextcode;
    __Cont: /* CIL Label */ 
#line 6887
    ch ++;
  }
  while_break___5: /* CIL Label */ ;
  }

#line 6851
  return;
}
}
#line 6915 "gzip.c"
static void read_pt_len(int nn , int nbit , int i_special ) 
{ 
  int i ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6923
  tmp = getbits(nbit);
#line 6923
  n = (int )tmp;
#line 6924
  if (n == 0) {
#line 6925
    tmp___0 = getbits(nbit);
#line 6925
    c = (int )tmp___0;
#line 6926
    i = 0;
    {
#line 6926
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6926
      if (i < nn) {

      } else {
#line 6926
        goto while_break;
      }
#line 6926
      pt_len[i] = (uch )0;
#line 6926
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6927
    i = 0;
    {
#line 6927
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6927
      if (i < 256) {

      } else {
#line 6927
        goto while_break___0;
      }
#line 6927
      pt_table[i] = (ush )c;
#line 6927
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 6929
    i = 0;
    {
#line 6930
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6930
      if (i < n) {

      } else {
#line 6930
        goto while_break___1;
      }
#line 6931
      c = (int )io_bitbuf >> (16U * sizeof(char ) - 3U);
#line 6932
      if (c == 7) {
#line 6933
        mask = 1U << ((16U * sizeof(char ) - 1U) - 3U);
        {
#line 6934
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 6934
          if ((mask & (unsigned int )io_bitbuf) != 0) {

          } else {
#line 6934
            goto while_break___2;
          }
#line 6934
          mask >>= 1;
#line 6934
          c ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {

      }
#line 6936
      if (c < 7) {
#line 6936
        tmp___1 = 3;
      } else {
#line 6936
        tmp___1 = c - 3;
      }
#line 6936
      fillbuf(tmp___1);
#line 6937
      tmp___2 = i;
#line 6937
      i ++;
#line 6937
      pt_len[tmp___2] = (uch )c;
#line 6938
      if (i == i_special) {
#line 6939
        tmp___3 = getbits(2);
#line 6939
        c = (int )tmp___3;
        {
#line 6940
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 6940
          c --;
#line 6940
          if (c >= 0) {

          } else {
#line 6940
            goto while_break___3;
          }
#line 6940
          tmp___4 = i;
#line 6940
          i ++;
#line 6940
          pt_len[tmp___4] = (uch )0;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {

      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 6943
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 6943
      if (i < nn) {

      } else {
#line 6943
        goto while_break___4;
      }
#line 6943
      tmp___5 = i;
#line 6943
      i ++;
#line 6943
      pt_len[tmp___5] = (uch )0;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 6944
    make_table(nn, pt_len, 8, pt_table);
  }

#line 6915
  return;
}
}
#line 6948 "gzip.c"
static void read_c_len(void) 
{ 
  int i ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ush *mem_12 ;

  {
#line 6953
  tmp = getbits(9);
#line 6953
  n = (int )tmp;
#line 6954
  if (n == 0) {
#line 6955
    tmp___0 = getbits(9);
#line 6955
    c = (int )tmp___0;
#line 6956
    i = 0;
    {
#line 6956
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6956
      if (i < 510) {

      } else {
#line 6956
        goto while_break;
      }
#line 6956
      outbuf[i] = (uch )0;
#line 6956
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6957
    i = 0;
    {
#line 6957
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6957
      if (i < 4096) {

      } else {
#line 6957
        goto while_break___0;
      }
#line 6957
      d_buf[i] = (ush )c;
#line 6957
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 6959
    i = 0;
    {
#line 6960
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6960
      if (i < n) {

      } else {
#line 6960
        goto while_break___1;
      }
#line 6961
      c = (int )pt_table[(int )io_bitbuf >> (16U * sizeof(char ) - 8U)];
#line 6962
      if (c >= 19) {
#line 6963
        mask = 1U << ((16U * sizeof(char ) - 1U) - 8U);
        {
#line 6964
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 6965
          if (((unsigned int )io_bitbuf & mask) != 0) {
#line 6965
            mem_12 = (prev + 32768) + c;
#line 6965
            c = (int )*mem_12;
          } else {
#line 6966
            c = (int )prev[c];
          }
#line 6967
          mask >>= 1;
#line 6964
          if (c >= 19) {

          } else {
#line 6964
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {

      }
#line 6970
      fillbuf((int )pt_len[c]);
#line 6971
      if (c <= 2) {
#line 6972
        if (c == 0) {
#line 6972
          c = 1;
        } else
#line 6973
        if (c == 1) {
#line 6973
          tmp___1 = getbits(4);
#line 6973
          c = (int )(tmp___1 + 3U);
        } else {
#line 6974
          tmp___2 = getbits(9);
#line 6974
          c = (int )(tmp___2 + 20U);
        }
        {
#line 6975
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 6975
          c --;
#line 6975
          if (c >= 0) {

          } else {
#line 6975
            goto while_break___3;
          }
#line 6975
          tmp___3 = i;
#line 6975
          i ++;
#line 6975
          outbuf[tmp___3] = (uch )0;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 6976
        tmp___4 = i;
#line 6976
        i ++;
#line 6976
        outbuf[tmp___4] = (uch )(c - 2);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 6978
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 6978
      if (i < 510) {

      } else {
#line 6978
        goto while_break___4;
      }
#line 6978
      tmp___5 = i;
#line 6978
      i ++;
#line 6978
      outbuf[tmp___5] = (uch )0;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 6979
    make_table(510, outbuf, 12, d_buf);
  }

#line 6948
  return;
}
}
#line 6983 "gzip.c"
static unsigned int decode_c(void) 
{ 
  unsigned int j ;
  unsigned int mask ;
  ush *mem_3 ;
  unsigned int __retres4 ;

  {
#line 6987
  if (blocksize == 0U) {
#line 6988
    blocksize = getbits(16);
#line 6989
    if (blocksize == 0U) {
#line 6990
      __retres4 = 510U;
#line 6990
      goto return_label;
    } else {

    }
#line 6992
    read_pt_len(19, 5, 3);
#line 6993
    read_c_len();
#line 6994
    read_pt_len(14, 4, -1);
  } else {

  }
#line 6996
  blocksize --;
#line 6997
  j = (unsigned int )d_buf[(int )io_bitbuf >> (16U * sizeof(char ) - 12U)];
#line 6998
  if (j >= 510U) {
#line 6999
    mask = 1U << ((16U * sizeof(char ) - 1U) - 12U);
    {
#line 7000
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7001
      if (((unsigned int )io_bitbuf & mask) != 0) {
#line 7001
        mem_3 = (prev + 32768) + j;
#line 7001
        j = (unsigned int )*mem_3;
      } else {
#line 7002
        j = (unsigned int )prev[j];
      }
#line 7003
      mask >>= 1;
#line 7000
      if (j >= 510U) {

      } else {
#line 7000
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {

  }
#line 7006
  fillbuf((int )outbuf[j]);
#line 7007
  __retres4 = j;
  return_label: /* CIL Label */ 
#line 6983
  return (__retres4);
}
}
#line 7010 "gzip.c"
static unsigned int decode_p(void) 
{ 
  unsigned int j ;
  unsigned int mask ;
  unsigned int tmp ;
  ush *mem_4 ;

  {
#line 7014
  j = (unsigned int )pt_table[(int )io_bitbuf >> (16U * sizeof(char ) - 8U)];
#line 7015
  if (j >= 14U) {
#line 7016
    mask = 1U << ((16U * sizeof(char ) - 1U) - 8U);
    {
#line 7017
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7018
      if (((unsigned int )io_bitbuf & mask) != 0) {
#line 7018
        mem_4 = (prev + 32768) + j;
#line 7018
        j = (unsigned int )*mem_4;
      } else {
#line 7019
        j = (unsigned int )prev[j];
      }
#line 7020
      mask >>= 1;
#line 7017
      if (j >= 14U) {

      } else {
#line 7017
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {

  }
#line 7023
  fillbuf((int )pt_len[j]);
#line 7024
  if (j != 0U) {
#line 7024
    tmp = getbits((int )(j - 1U));
#line 7024
    j = (1U << (j - 1U)) + tmp;
  } else {

  }
#line 7025
  return (j);
}
}
#line 7028 "gzip.c"
static void huf_decode_start(void) 
{ 


  {
#line 7030
  init_getbits();
#line 7030
  blocksize = 0U;

#line 7028
  return;
}
}
#line 7037 "gzip.c"
static int j  ;
#line 7038 "gzip.c"
static int done  ;
#line 7040 "gzip.c"
static void decode_start(void) 
{ 


  {
#line 7042
  huf_decode_start();
#line 7043
  j = 0;
#line 7044
  done = 0;

#line 7040
  return;
}
}
#line 7061 "gzip.c"
static unsigned int i  ;
#line 7049 "gzip.c"
static unsigned int decode(unsigned int count , uch *buffer ) 
{ 
  unsigned int r ;
  unsigned int c ;
  unsigned int tmp ;
  uch *mem_6 ;
  uch *mem_7 ;
  uch *mem_8 ;
  uch *mem_9 ;
  uch *mem_10 ;
  unsigned int __retres11 ;

  {
#line 7064
  r = 0U;
  {
#line 7065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7065
    j --;
#line 7065
    if (j >= 0) {

    } else {
#line 7065
      goto while_break;
    }
#line 7066
    mem_6 = buffer + r;
#line 7066
    mem_7 = buffer + i;
#line 7066
    *mem_6 = *mem_7;
#line 7067
    i = (i + 1U) & ((1U << 13) - 1U);
#line 7068
    r ++;
#line 7068
    if (r == count) {
#line 7068
      __retres11 = r;
#line 7068
      goto return_label;
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7070
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7071
    c = decode_c();
#line 7072
    if (c == 510U) {
#line 7073
      done = 1;
#line 7074
      __retres11 = r;
#line 7074
      goto return_label;
    } else {

    }
#line 7076
    if (c <= 255U) {
#line 7077
      mem_8 = buffer + r;
#line 7077
      *mem_8 = (uch )c;
#line 7078
      r ++;
#line 7078
      if (r == count) {
#line 7078
        __retres11 = r;
#line 7078
        goto return_label;
      } else {

      }
    } else {
#line 7080
      j = (int )(c - 253U);
#line 7081
      tmp = decode_p();
#line 7081
      i = ((r - tmp) - 1U) & ((1U << 13) - 1U);
      {
#line 7082
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 7082
        j --;
#line 7082
        if (j >= 0) {

        } else {
#line 7082
          goto while_break___1;
        }
#line 7083
        mem_9 = buffer + r;
#line 7083
        mem_10 = buffer + i;
#line 7083
        *mem_9 = *mem_10;
#line 7084
        i = (i + 1U) & ((1U << 13) - 1U);
#line 7085
        r ++;
#line 7085
        if (r == count) {
#line 7085
          __retres11 = r;
#line 7085
          goto return_label;
        } else {

        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return_label: /* CIL Label */ 
#line 7049
  return (__retres11);
}
}
#line 7095 "gzip.c"
int unlzh(int in , int out ) 
{ 
  unsigned int n ;
  int __retres4 ;

  {
#line 7100
  ifd = in;
#line 7101
  ofd = out;
#line 7103
  decode_start();
  {
#line 7104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7104
    if (done == 0) {

    } else {
#line 7104
      goto while_break;
    }
#line 7105
    n = decode(1U << 13, window);
#line 7106
    if (test == 0) {
#line 7106
      if (n > 0U) {
#line 7107
        write_buf(out, (voidp )((char *)(window)), n);
      } else {

      }
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7110
  __retres4 = 0;
#line 7095
  return (__retres4);
}
}
#line 7278 "gzip.c"
int block_mode  =    128;
#line 7289 "gzip.c"
int unlzw(int in , int out ) 
{ 
  register char_type *stackp ;
  code_int code ;
  int finchar ;
  code_int oldcode ;
  code_int incode ;
  long inbits ;
  long posbits ;
  int outpos ;
  unsigned int bitmask ;
  code_int free_ent ;
  code_int maxcode ;
  code_int maxmaxcode ;
  int n_bits ;
  int rsize ;
  unsigned int tmp ;
  int tmp___0 ;
  register int i___0 ;
  int e ;
  int o ;
  register char_type *p ;
  int tmp___1 ;
  char const   *tmp___2 ;
  register int i___1 ;
  char_type *mem_26 ;
  char_type *mem_27 ;
  char_type *mem_28 ;
  int __retres29 ;

  {
#line 7312
  if (inptr < insize) {
#line 7312
    tmp = inptr;
#line 7312
    inptr ++;
#line 7312
    maxbits = (int )inbuf[tmp];
  } else {
#line 7312
    tmp___0 = fill_inbuf(0);
#line 7312
    maxbits = tmp___0;
  }
#line 7313
  block_mode = maxbits & 128;
#line 7314
  if ((maxbits & 96) != 0) {
#line 7315
    if (quiet == 0) {
#line 7315
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: warning, unknown flags 0x%x\n",
              progname, ifname, maxbits & 96);
    } else {

    }
#line 7315
    if (exit_code == 0) {
#line 7315
      exit_code = 2;
    } else {

    }
  } else {

  }
#line 7318
  maxbits &= 31;
#line 7319
  maxmaxcode = 1L << maxbits;
#line 7321
  if (maxbits > 16) {
#line 7322
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: compressed with %d bits, can only handle %d bits\n",
            progname, ifname, maxbits, 16);
#line 7325
    exit_code = 1;
#line 7326
    __retres29 = 1;
#line 7326
    goto return_label;
  } else {

  }
#line 7328
  rsize = (int )insize;
#line 7329
  n_bits = 9;
#line 7329
  maxcode = (1L << n_bits) - 1L;
#line 7330
  bitmask = (unsigned int )((1 << n_bits) - 1);
#line 7331
  oldcode = (code_int )-1;
#line 7332
  finchar = 0;
#line 7333
  outpos = 0;
#line 7334
  posbits = (long )(inptr << 3);
#line 7336
  if (block_mode != 0) {
#line 7336
    free_ent = (code_int )257;
  } else {
#line 7336
    free_ent = (code_int )256;
  }
#line 7338
  memset((voidp )(prev), 0, (size_t )256);
#line 7340
  code = (code_int )255;
  {
#line 7340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7340
    if (code >= 0L) {

    } else {
#line 7340
      goto while_break;
    }
#line 7341
    window[code] = (char_type )code;
#line 7340
    code --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7343
  while (1) {
    while_continue___0: /* CIL Label */ ;
    resetbuf: 
#line 7349
    o = (int )(posbits >> 3);
#line 7349
    e = (int )(insize - (unsigned int )o);
#line 7351
    i___0 = 0;
    {
#line 7351
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7351
      if (i___0 < e) {

      } else {
#line 7351
        goto while_break___1;
      }
#line 7352
      inbuf[i___0] = inbuf[i___0 + o];
#line 7351
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7354
    insize = (unsigned int )e;
#line 7355
    posbits = 0L;
#line 7357
    if (insize < 64U) {
#line 7358
      rsize = read(in, (void *)((char *)(inbuf) + insize), (size_t )32768);
#line 7358
      if (rsize == -1) {
#line 7359
        read_error();
      } else {

      }
#line 7361
      insize += (unsigned int )rsize;
#line 7362
      bytes_in += (off_t )rsize;
    } else {

    }
#line 7364
    if (rsize != 0) {
#line 7364
      inbits = (long )(((unsigned long )((long )insize) - (unsigned long )(insize % (unsigned int )n_bits)) << 3);
    } else {
#line 7364
      inbits = ((long )insize << 3) - (long )(n_bits - 1);
    }
    {
#line 7367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 7367
      if (inbits > posbits) {

      } else {
#line 7367
        goto while_break___2;
      }
#line 7368
      if (free_ent > maxcode) {
#line 7369
        posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 7371
        n_bits ++;
#line 7372
        if (n_bits == maxbits) {
#line 7373
          maxcode = maxmaxcode;
        } else {
#line 7375
          maxcode = (1L << n_bits) - 1L;
        }
#line 7377
        bitmask = (unsigned int )((1 << n_bits) - 1);
#line 7378
        goto resetbuf;
      } else {

      }
#line 7380
      p = & inbuf[posbits >> 3];
#line 7380
      mem_26 = p + 0;
#line 7380
      mem_27 = p + 1;
#line 7380
      mem_28 = p + 2;
#line 7380
      code = (code_int )((unsigned long )((((long )*mem_26 | ((long )*mem_27 << 8)) | ((long )*mem_28 << 16)) >> (posbits & 7L)) & (unsigned long )bitmask);
#line 7380
      posbits += (long )n_bits;
#line 7383
      if (oldcode == -1L) {
#line 7384
        if (code >= 256L) {
#line 7384
          error((char *)"corrupt input.");
        } else {

        }
#line 7385
        tmp___1 = outpos;
#line 7385
        outpos ++;
#line 7385
        oldcode = code;
#line 7385
        finchar = (int )oldcode;
#line 7385
        outbuf[tmp___1] = (char_type )finchar;
#line 7386
        goto while_continue___2;
      } else {

      }
#line 7388
      if (code == 256L) {
#line 7388
        if (block_mode != 0) {
#line 7389
          memset((voidp )(prev), 0, (size_t )256);
#line 7390
          free_ent = (code_int )256;
#line 7391
          posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 7393
          n_bits = 9;
#line 7393
          maxcode = (1L << n_bits) - 1L;
#line 7394
          bitmask = (unsigned int )((1 << n_bits) - 1);
#line 7395
          goto resetbuf;
        } else {

        }
      } else {

      }
#line 7397
      incode = code;
#line 7398
      stackp = (char_type *)(& d_buf[32767]);
#line 7400
      if (code >= free_ent) {
#line 7401
        if (code > free_ent) {
#line 7414
          if (test == 0) {
#line 7414
            if (outpos > 0) {
#line 7415
              write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
#line 7416
              bytes_out += (off_t )outpos;
            } else {

            }
          } else {

          }
#line 7418
          if (to_stdout != 0) {
#line 7418
            tmp___2 = "corrupt input.";
          } else {
#line 7418
            tmp___2 = "corrupt input. Use zcat to recover some data.";
          }
#line 7418
          error((char *)tmp___2);
        } else {

        }
#line 7421
        stackp --;
#line 7421
        *stackp = (char_type )finchar;
#line 7422
        code = oldcode;
      } else {

      }
      {
#line 7425
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 7425
        if ((cmp_code_int )code >= 256UL) {

        } else {
#line 7425
          goto while_break___3;
        }
#line 7427
        stackp --;
#line 7427
        *stackp = window[code];
#line 7428
        code = (code_int )prev[code];
      }
      while_break___3: /* CIL Label */ ;
      }
#line 7430
      stackp --;
#line 7430
      finchar = (int )window[code];
#line 7430
      *stackp = (char_type )finchar;
#line 7436
      i___1 = (char_type *)(& d_buf[32767]) - stackp;
#line 7436
      if (outpos + i___1 >= 16384) {
        {
#line 7437
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 7438
          if (i___1 > 16384 - outpos) {
#line 7438
            i___1 = 16384 - outpos;
          } else {

          }
#line 7440
          if (i___1 > 0) {
#line 7441
            memcpy((void * __restrict  )(outbuf + outpos), (void const   * __restrict  )stackp,
                   (size_t )i___1);
#line 7442
            outpos += i___1;
          } else {

          }
#line 7444
          if (outpos >= 16384) {
#line 7445
            if (test == 0) {
#line 7446
              write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
#line 7447
              bytes_out += (off_t )outpos;
            } else {

            }
#line 7449
            outpos = 0;
          } else {

          }
#line 7451
          stackp += i___1;
#line 7437
          i___1 = (char_type *)(& d_buf[32767]) - stackp;
#line 7437
          if (i___1 > 0) {

          } else {
#line 7437
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 7454
        memcpy((void * __restrict  )(outbuf + outpos), (void const   * __restrict  )stackp,
               (size_t )i___1);
#line 7455
        outpos += i___1;
      }
#line 7459
      code = free_ent;
#line 7459
      if (code < maxmaxcode) {
#line 7461
        prev[code] = (unsigned short )oldcode;
#line 7462
        window[code] = (char_type )finchar;
#line 7463
        free_ent = code + 1L;
      } else {

      }
#line 7465
      oldcode = incode;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 7343
    if (rsize != 0) {

    } else {
#line 7343
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 7469
  if (test == 0) {
#line 7469
    if (outpos > 0) {
#line 7470
      write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
#line 7471
      bytes_out += (off_t )outpos;
    } else {

    }
  } else {

  }
#line 7473
  __retres29 = 0;
  return_label: /* CIL Label */ 
#line 7289
  return (__retres29);
}
}
#line 7502 "gzip.c"
static ulg orig_len  ;
#line 7503 "gzip.c"
static int max_len  ;
#line 7505 "gzip.c"
static uch literal[256]  ;
#line 7510 "gzip.c"
static int lit_base[26]  ;
#line 7516 "gzip.c"
static int leaves[26]  ;
#line 7517 "gzip.c"
static int parents[26]  ;
#line 7519 "gzip.c"
static int peek_bits  ;
#line 7534 "gzip.c"
static ulg bitbuf  ;
#line 7537 "gzip.c"
static int valid  ;
#line 7558
static void read_tree(void) ;
#line 7559
static void build_tree(void) ;
#line 7564 "gzip.c"
static void read_tree(void) 
{ 
  int len ;
  int base ;
  int n ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 7571
  orig_len = (ulg )0;
#line 7572
  n = 1;
  {
#line 7572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7572
    if (n <= 4) {

    } else {
#line 7572
      goto while_break;
    }
#line 7572
    if (inptr < insize) {
#line 7572
      tmp = inptr;
#line 7572
      inptr ++;
#line 7572
      tmp___1 = (int )inbuf[tmp];
    } else {
#line 7572
      tmp___0 = fill_inbuf(0);
#line 7572
      tmp___1 = tmp___0;
    }
#line 7572
    orig_len = (orig_len << 8) | (ulg )tmp___1;
#line 7572
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7574
  if (inptr < insize) {
#line 7574
    tmp___2 = inptr;
#line 7574
    inptr ++;
#line 7574
    tmp___4 = (int )inbuf[tmp___2];
  } else {
#line 7574
    tmp___3 = fill_inbuf(0);
#line 7574
    tmp___4 = tmp___3;
  }
#line 7574
  max_len = tmp___4;
#line 7575
  if (max_len > 25) {
#line 7576
    error((char *)"invalid compressed data -- Huffman code > 32 bits");
  } else {

  }
#line 7580
  n = 0;
#line 7581
  len = 1;
  {
#line 7581
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7581
    if (len <= max_len) {

    } else {
#line 7581
      goto while_break___0;
    }
#line 7582
    if (inptr < insize) {
#line 7582
      tmp___5 = inptr;
#line 7582
      inptr ++;
#line 7582
      tmp___7 = (int )inbuf[tmp___5];
    } else {
#line 7582
      tmp___6 = fill_inbuf(0);
#line 7582
      tmp___7 = tmp___6;
    }
#line 7582
    leaves[len] = tmp___7;
#line 7583
    n += leaves[len];
#line 7581
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 7585
  if (n > 256) {
#line 7586
    error((char *)"too many leaves in Huffman tree");
  } else {

  }
#line 7597
  (leaves[max_len]) ++;
#line 7600
  base = 0;
#line 7601
  len = 1;
  {
#line 7601
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 7601
    if (len <= max_len) {

    } else {
#line 7601
      goto while_break___1;
    }
#line 7603
    lit_base[len] = base;
#line 7605
    n = leaves[len];
    {
#line 7605
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 7605
      if (n > 0) {

      } else {
#line 7605
        goto while_break___2;
      }
#line 7606
      tmp___8 = base;
#line 7606
      base ++;
#line 7606
      if (inptr < insize) {
#line 7606
        tmp___9 = inptr;
#line 7606
        inptr ++;
#line 7606
        tmp___11 = (int )inbuf[tmp___9];
      } else {
#line 7606
        tmp___10 = fill_inbuf(0);
#line 7606
        tmp___11 = tmp___10;
      }
#line 7606
      literal[tmp___8] = (uch )tmp___11;
#line 7605
      n --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 7601
    len ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 7609
  (leaves[max_len]) ++;

#line 7564
  return;
}
}
#line 7615 "gzip.c"
static void build_tree(void) 
{ 
  int nodes ;
  int len ;
  uch *prefixp ;
  int prefixes ;
  int tmp ;

  {
#line 7617
  nodes = 0;
#line 7621
  len = max_len;
  {
#line 7621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7621
    if (len >= 1) {

    } else {
#line 7621
      goto while_break;
    }
#line 7625
    nodes >>= 1;
#line 7626
    parents[len] = nodes;
#line 7630
    lit_base[len] -= nodes;
#line 7632
    nodes += leaves[len];
#line 7621
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 7637
  if (max_len <= 12) {
#line 7637
    peek_bits = max_len;
  } else {
#line 7637
    peek_bits = 12;
  }
#line 7638
  prefixp = & outbuf[1 << peek_bits];
#line 7639
  len = 1;
  {
#line 7639
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7639
    if (len <= peek_bits) {

    } else {
#line 7639
      goto while_break___0;
    }
#line 7640
    prefixes = leaves[len] << (peek_bits - len);
    {
#line 7641
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7641
      tmp = prefixes;
#line 7641
      prefixes --;
#line 7641
      if (tmp != 0) {

      } else {
#line 7641
        goto while_break___1;
      }
#line 7641
      prefixp --;
#line 7641
      *prefixp = (uch )len;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7639
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7644
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 7644
    if ((unsigned int )prefixp > (unsigned int )(outbuf)) {

    } else {
#line 7644
      goto while_break___2;
    }
#line 7644
    prefixp --;
#line 7644
    *prefixp = (uch )0;
  }
  while_break___2: /* CIL Label */ ;
  }

#line 7615
  return;
}
}
#line 7655 "gzip.c"
int unpack(int in , int out ) 
{ 
  int len ;
  unsigned int eob ;
  register unsigned int peek ;
  unsigned int peek_mask ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ulg mask ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int __retres15 ;

  {
#line 7663
  ifd = in;
#line 7664
  ofd = out;
#line 7666
  read_tree();
#line 7667
  build_tree();
#line 7668
  valid = 0;
#line 7668
  bitbuf = (ulg )0;
#line 7669
  peek_mask = (unsigned int )((1 << peek_bits) - 1);
#line 7672
  eob = (unsigned int )(leaves[max_len] - 1);
  {
#line 7676
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 7681
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7681
      if (valid < peek_bits) {

      } else {
#line 7681
        goto while_break___0;
      }
#line 7681
      if (inptr < insize) {
#line 7681
        tmp = inptr;
#line 7681
        inptr ++;
#line 7681
        tmp___1 = (int )inbuf[tmp];
      } else {
#line 7681
        tmp___0 = fill_inbuf(0);
#line 7681
        tmp___1 = tmp___0;
      }
#line 7681
      bitbuf = (bitbuf << 8) | (ulg )tmp___1;
#line 7681
      valid += 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 7681
    peek = (unsigned int )((bitbuf >> (valid - peek_bits)) & (unsigned long )peek_mask);
#line 7682
    len = (int )outbuf[peek];
#line 7683
    if (len > 0) {
#line 7684
      peek >>= peek_bits - len;
    } else {
#line 7687
      mask = (ulg )peek_mask;
#line 7688
      len = peek_bits;
      {
#line 7689
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 7690
        len ++;
#line 7690
        mask = (mask << 1) + 1UL;
        {
#line 7691
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 7691
          if (valid < len) {

          } else {
#line 7691
            goto while_break___2;
          }
#line 7691
          if (inptr < insize) {
#line 7691
            tmp___2 = inptr;
#line 7691
            inptr ++;
#line 7691
            tmp___4 = (int )inbuf[tmp___2];
          } else {
#line 7691
            tmp___3 = fill_inbuf(0);
#line 7691
            tmp___4 = tmp___3;
          }
#line 7691
          bitbuf = (bitbuf << 8) | (ulg )tmp___4;
#line 7691
          valid += 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 7691
        peek = (unsigned int )((bitbuf >> (valid - len)) & mask);
#line 7689
        if (peek < (unsigned int )parents[len]) {

        } else {
#line 7689
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 7696
    if (peek == eob) {
#line 7696
      if (len == max_len) {
#line 7696
        goto while_break;
      } else {

      }
    } else {

    }
#line 7697
    tmp___5 = outcnt;
#line 7697
    outcnt ++;
#line 7697
    window[tmp___5] = literal[peek + (unsigned int )lit_base[len]];
#line 7697
    if (outcnt == 32768U) {
#line 7697
      flush_window();
    } else {

    }
#line 7700
    valid -= len;
  }
  while_break: /* CIL Label */ ;
  }
#line 7703
  flush_window();
#line 7704
  if (orig_len != ((unsigned long )bytes_out & 4294967295UL)) {
#line 7705
    error((char *)"invalid compressed data--length error");
  } else {

  }
#line 7707
  __retres15 = 0;
#line 7655
  return (__retres15);
}
}
#line 7748 "gzip.c"
char *key  ;
#line 7749 "gzip.c"
int pkzip  =    0;
#line 7750 "gzip.c"
int ext_header  =    0;
#line 7756 "gzip.c"
int check_zipfile(int in ) 
{ 
  uch *h ;
  uch *mem_3 ;
  uch *mem_4 ;
  uch *mem_5 ;
  uch *mem_6 ;
  uch *mem_7 ;
  uch *mem_8 ;
  uch *mem_9 ;
  uch *mem_10 ;
  uch *mem_11 ;
  uch *mem_12 ;
  uch *mem_13 ;
  int __retres14 ;

  {
#line 7759
  h = inbuf + inptr;
#line 7761
  ifd = in;
#line 7764
  mem_3 = (h + 26) + 0;
#line 7764
  mem_4 = (h + 26) + 1;
#line 7764
  mem_5 = (h + 28) + 0;
#line 7764
  mem_6 = (h + 28) + 1;
#line 7764
  inptr += (unsigned int )((30 + ((int )((ush )*mem_3) | ((int )((ush )*mem_4) << 8))) + ((int )((ush )*mem_5) | ((int )((ush )*mem_6) << 8)));
#line 7766
  if (inptr > insize) {
#line 7767
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: not a valid zip file\n",
            progname, ifname);
#line 7769
    exit_code = 1;
#line 7770
    __retres14 = 1;
#line 7770
    goto return_label;
  } else {
    {
#line 7766
    mem_7 = h + 0;
#line 7766
    mem_8 = h + 1;
#line 7766
    mem_9 = (h + 2) + 0;
#line 7766
    mem_10 = (h + 2) + 1;
#line 7766
    if (((ulg )((int )((ush )*mem_7) | ((int )((ush )*mem_8) << 8)) | ((ulg )((int )((ush )*mem_9) | ((int )((ush )*mem_10) << 8)) << 16)) != 67324752UL) {
#line 7767
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: not a valid zip file\n",
              progname, ifname);
#line 7769
      exit_code = 1;
#line 7770
      __retres14 = 1;
#line 7770
      goto return_label;
    } else {

    }
    }
  }
#line 7772
  mem_11 = h + 8;
#line 7772
  method = (int )*mem_11;
#line 7773
  if (method != 0) {
#line 7773
    if (method != 8) {
#line 7774
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: first entry not deflated or stored -- use unzip\n",
              progname, ifname);
#line 7777
      exit_code = 1;
#line 7778
      __retres14 = 1;
#line 7778
      goto return_label;
    } else {

    }
  } else {

  }
#line 7782
  mem_12 = h + 6;
#line 7782
  decrypt = (int )*mem_12 & 1;
#line 7782
  if (decrypt != 0) {
#line 7783
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: encrypted file -- use unzip\n",
            progname, ifname);
#line 7785
    exit_code = 1;
#line 7786
    __retres14 = 1;
#line 7786
    goto return_label;
  } else {

  }
#line 7790
  mem_13 = h + 6;
#line 7790
  ext_header = ((int )*mem_13 & 8) != 0;
#line 7791
  pkzip = 1;
#line 7794
  __retres14 = 0;
  return_label: /* CIL Label */ 
#line 7756
  return (__retres14);
}
}
#line 7804 "gzip.c"
int unzip(int in , int out ) 
{ 
  ulg orig_crc ;
  ulg orig_len___0 ;
  int n ;
  uch buf[16] ;
  int err ;
  int res ;
  int tmp ;
  register ulg n___0 ;
  int tmp___0 ;
  uch c ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  ulg tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  ulg tmp___12 ;
  uch *mem_25 ;
  uch *mem_26 ;
  uch *mem_27 ;
  uch *mem_28 ;
  uch *mem_29 ;
  uch *mem_30 ;
  uch *mem_31 ;
  uch *mem_32 ;
  uch *mem_33 ;
  uch *mem_34 ;
  uch *mem_35 ;
  uch *mem_36 ;
  uch *mem_37 ;
  uch *mem_38 ;
  uch *mem_39 ;
  uch *mem_40 ;
  uch *mem_41 ;
  uch *mem_42 ;
  uch *mem_43 ;
  uch *mem_44 ;
  uch *mem_45 ;
  uch *mem_46 ;
  uch *mem_47 ;
  uch *mem_48 ;
  uch *mem_49 ;
  uch *mem_50 ;
  uch *mem_51 ;
  uch *mem_52 ;
  uch *mem_53 ;
  uch *mem_54 ;
  uch *mem_55 ;
  uch *mem_56 ;
  uch *mem_57 ;
  uch *mem_58 ;
  uch *mem_59 ;
  uch *mem_60 ;
  uch *mem_61 ;
  uch *mem_62 ;
  int __retres63 ;

  {
#line 7807
  orig_crc = (ulg )0;
#line 7808
  orig_len___0 = (ulg )0;
#line 7811
  err = 0;
#line 7813
  ifd = in;
#line 7814
  ofd = out;
#line 7816
  updcrc((uch *)((void *)0), 0U);
#line 7818
  if (pkzip != 0) {
#line 7818
    if (ext_header == 0) {
#line 7819
      mem_25 = (inbuf + 14) + 0;
#line 7819
      mem_26 = (inbuf + 14) + 1;
#line 7819
      mem_27 = ((inbuf + 14) + 2) + 0;
#line 7819
      mem_28 = ((inbuf + 14) + 2) + 1;
#line 7819
      orig_crc = (ulg )((int )((ush )*mem_25) | ((int )((ush )*mem_26) << 8)) | ((ulg )((int )((ush )*mem_27) | ((int )((ush )*mem_28) << 8)) << 16);
#line 7820
      mem_29 = (inbuf + 22) + 0;
#line 7820
      mem_30 = (inbuf + 22) + 1;
#line 7820
      mem_31 = ((inbuf + 22) + 2) + 0;
#line 7820
      mem_32 = ((inbuf + 22) + 2) + 1;
#line 7820
      orig_len___0 = (ulg )((int )((ush )*mem_29) | ((int )((ush )*mem_30) << 8)) | ((ulg )((int )((ush )*mem_31) | ((int )((ush )*mem_32) << 8)) << 16);
    } else {

    }
  } else {

  }
#line 7824
  if (method == 8) {
#line 7826
    tmp = inflate();
#line 7826
    res = tmp;
#line 7828
    if (res == 3) {
#line 7829
      error((char *)"out of memory");
    } else
#line 7830
    if (res != 0) {
#line 7831
      error((char *)"invalid compressed data--format violated");
    } else {

    }
  } else
#line 7834
  if (pkzip != 0) {
#line 7834
    if (method == 0) {
#line 7836
      mem_33 = (inbuf + 22) + 0;
#line 7836
      mem_34 = (inbuf + 22) + 1;
#line 7836
      mem_35 = ((inbuf + 22) + 2) + 0;
#line 7836
      mem_36 = ((inbuf + 22) + 2) + 1;
#line 7836
      n___0 = (ulg )((int )((ush )*mem_33) | ((int )((ush )*mem_34) << 8)) | ((ulg )((int )((ush )*mem_35) | ((int )((ush )*mem_36) << 8)) << 16);
#line 7838
      if (decrypt != 0) {
#line 7838
        tmp___0 = 12;
      } else {
#line 7838
        tmp___0 = 0;
      }
      {
#line 7838
      mem_37 = (inbuf + 18) + 0;
#line 7838
      mem_38 = (inbuf + 18) + 1;
#line 7838
      mem_39 = ((inbuf + 18) + 2) + 0;
#line 7838
      mem_40 = ((inbuf + 18) + 2) + 1;
#line 7838
      if (n___0 != ((ulg )((int )((ush )*mem_37) | ((int )((ush )*mem_38) << 8)) | ((ulg )((int )((ush )*mem_39) | ((int )((ush )*mem_40) << 8)) << 16)) - (unsigned long )tmp___0) {
#line 7840
        mem_41 = (inbuf + 18) + 0;
#line 7840
        mem_42 = (inbuf + 18) + 1;
#line 7840
        mem_43 = ((inbuf + 18) + 2) + 0;
#line 7840
        mem_44 = ((inbuf + 18) + 2) + 1;
#line 7840
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"len %ld, siz %ld\n",
                n___0, (ulg )((int )((ush )*mem_41) | ((int )((ush )*mem_42) << 8)) | ((ulg )((int )((ush )*mem_43) | ((int )((ush )*mem_44) << 8)) << 16));
#line 7841
        error((char *)"invalid compressed data--length mismatch");
      } else {

      }
      }
      {
#line 7843
      while (1) {
        while_continue: /* CIL Label */ ;
#line 7843
        tmp___5 = n___0;
#line 7843
        n___0 --;
#line 7843
        if (tmp___5 != 0) {

        } else {
#line 7843
          goto while_break;
        }
#line 7844
        if (inptr < insize) {
#line 7844
          tmp___1 = inptr;
#line 7844
          inptr ++;
#line 7844
          tmp___3 = (int )inbuf[tmp___1];
        } else {
#line 7844
          tmp___2 = fill_inbuf(0);
#line 7844
          tmp___3 = tmp___2;
        }
#line 7844
        c = (uch )tmp___3;
#line 7845
        tmp___4 = outcnt;
#line 7845
        outcnt ++;
#line 7845
        window[tmp___4] = c;
#line 7845
        if (outcnt == 32768U) {
#line 7845
          flush_window();
        } else {

        }
      }
      while_break: /* CIL Label */ ;
      }
#line 7847
      flush_window();
    } else {
#line 7849
      error((char *)"internal error, invalid method");
    }
  } else {
#line 7849
    error((char *)"internal error, invalid method");
  }
#line 7853
  if (pkzip == 0) {
#line 7857
    n = 0;
    {
#line 7857
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7857
      if (n < 8) {

      } else {
#line 7857
        goto while_break___0;
      }
#line 7858
      if (inptr < insize) {
#line 7858
        tmp___6 = inptr;
#line 7858
        inptr ++;
#line 7858
        tmp___8 = (int )inbuf[tmp___6];
      } else {
#line 7858
        tmp___7 = fill_inbuf(0);
#line 7858
        tmp___8 = tmp___7;
      }
#line 7858
      buf[n] = (uch )tmp___8;
#line 7857
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 7860
    mem_45 = (buf + 2) + 0;
#line 7860
    mem_46 = (buf + 2) + 1;
#line 7860
    orig_crc = (ulg )((int )((ush )buf[0]) | ((int )((ush )buf[1]) << 8)) | ((ulg )((int )((ush )*mem_45) | ((int )((ush )*mem_46) << 8)) << 16);
#line 7861
    mem_47 = (buf + 4) + 0;
#line 7861
    mem_48 = (buf + 4) + 1;
#line 7861
    mem_49 = ((buf + 4) + 2) + 0;
#line 7861
    mem_50 = ((buf + 4) + 2) + 1;
#line 7861
    orig_len___0 = (ulg )((int )((ush )*mem_47) | ((int )((ush )*mem_48) << 8)) | ((ulg )((int )((ush )*mem_49) | ((int )((ush )*mem_50) << 8)) << 16);
  } else
#line 7863
  if (ext_header != 0) {
#line 7869
    n = 0;
    {
#line 7869
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7869
      if (n < 16) {

      } else {
#line 7869
        goto while_break___1;
      }
#line 7870
      if (inptr < insize) {
#line 7870
        tmp___9 = inptr;
#line 7870
        inptr ++;
#line 7870
        tmp___11 = (int )inbuf[tmp___9];
      } else {
#line 7870
        tmp___10 = fill_inbuf(0);
#line 7870
        tmp___11 = tmp___10;
      }
#line 7870
      buf[n] = (uch )tmp___11;
#line 7869
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7872
    mem_51 = (buf + 4) + 0;
#line 7872
    mem_52 = (buf + 4) + 1;
#line 7872
    mem_53 = ((buf + 4) + 2) + 0;
#line 7872
    mem_54 = ((buf + 4) + 2) + 1;
#line 7872
    orig_crc = (ulg )((int )((ush )*mem_51) | ((int )((ush )*mem_52) << 8)) | ((ulg )((int )((ush )*mem_53) | ((int )((ush )*mem_54) << 8)) << 16);
#line 7873
    mem_55 = (buf + 12) + 0;
#line 7873
    mem_56 = (buf + 12) + 1;
#line 7873
    mem_57 = ((buf + 12) + 2) + 0;
#line 7873
    mem_58 = ((buf + 12) + 2) + 1;
#line 7873
    orig_len___0 = (ulg )((int )((ush )*mem_55) | ((int )((ush )*mem_56) << 8)) | ((ulg )((int )((ush )*mem_57) | ((int )((ush )*mem_58) << 8)) << 16);
  } else {

  }
#line 7877
  tmp___12 = updcrc(outbuf, 0U);
#line 7877
  if (orig_crc != tmp___12) {
#line 7878
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: invalid compressed data--crc error\n",
            progname, ifname);
#line 7880
    err = 1;
  } else {

  }
#line 7882
  if (orig_len___0 != ((unsigned long )bytes_out & 4294967295UL)) {
#line 7883
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: invalid compressed data--length error\n",
            progname, ifname);
#line 7885
    err = 1;
  } else {

  }
#line 7889
  if (pkzip != 0) {
#line 7889
    if (inptr + 4U < insize) {
      {
#line 7889
      mem_59 = (inbuf + inptr) + 0;
#line 7889
      mem_60 = (inbuf + inptr) + 1;
#line 7889
      mem_61 = ((inbuf + inptr) + 2) + 0;
#line 7889
      mem_62 = ((inbuf + inptr) + 2) + 1;
#line 7889
      if (((ulg )((int )((ush )*mem_59) | ((int )((ush )*mem_60) << 8)) | ((ulg )((int )((ush )*mem_61) | ((int )((ush )*mem_62) << 8)) << 16)) == 67324752UL) {
#line 7890
        if (to_stdout != 0) {
#line 7891
          if (quiet == 0) {
#line 7891
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s has more than one entry--rest ignored\n",
                    progname, ifname);
          } else {

          }
#line 7891
          if (exit_code == 0) {
#line 7891
            exit_code = 2;
          } else {

          }
        } else {
#line 7896
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s has more than one entry -- unchanged\n",
                  progname, ifname);
#line 7899
          err = 1;
        }
      } else {

      }
      }
    } else {

    }
  } else {

  }
#line 7902
  pkzip = 0;
#line 7902
  ext_header = pkzip;
#line 7903
  if (err == 0) {
#line 7903
    __retres63 = 0;
#line 7903
    goto return_label;
  } else {

  }
#line 7904
  exit_code = 1;
#line 7905
  if (test == 0) {
#line 7905
    abort_gzip();
  } else {

  }
#line 7906
  __retres63 = err;
  return_label: /* CIL Label */ 
#line 7804
  return (__retres63);
}
}
#line 7923
ulg crc_32_tab[256] ;
#line 7929 "gzip.c"
int copy(int in , int out ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;
  int __retres5 ;

  {
#line 7932
  tmp = __errno_location();
#line 7932
  *tmp = 0;
  {
#line 7933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7933
    if (insize != 0U) {
#line 7933
      if ((int )insize != -1) {

      } else {
#line 7933
        goto while_break;
      }
    } else {
#line 7933
      goto while_break;
    }
#line 7934
    write_buf(out, (voidp )((char *)(inbuf)), insize);
#line 7935
    bytes_out = (off_t )((unsigned long )bytes_out + (unsigned long )insize);
#line 7936
    tmp___0 = read(in, (void *)((char *)(inbuf)), (size_t )32768);
#line 7936
    insize = (unsigned int )tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 7938
  if ((int )insize == -1) {
#line 7939
    read_error();
  } else {

  }
#line 7941
  bytes_in = bytes_out;
#line 7942
  __retres5 = 0;
#line 7929
  return (__retres5);
}
}
#line 7956
ulg updcrc(uch *s , unsigned int n ) ;
#line 7956 "gzip.c"
static ulg crc___0  =    4294967295UL;
#line 7950 "gzip.c"
ulg updcrc(uch *s , unsigned int n ) 
{ 
  register ulg c ;
  uch *tmp ;
  ulg __retres5 ;

  {
#line 7958
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 7959
    c = 4294967295UL;
  } else {
#line 7961
    c = crc___0;
#line 7962
    if (n != 0) {
      {
#line 7962
      while (1) {
        while_continue: /* CIL Label */ ;
#line 7963
        tmp = s;
#line 7963
        s ++;
#line 7963
        c = crc_32_tab[((int )c ^ (int )*tmp) & 255] ^ (c >> 8);
#line 7962
        n --;
#line 7962
        if (n != 0) {

        } else {
#line 7962
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {

    }
  }
#line 7966
  crc___0 = c;
#line 7967
  __retres5 = c ^ 4294967295UL;
#line 7950
  return (__retres5);
}
}
#line 7973 "gzip.c"

void clear_bufsWrapper(void)
{
    {
  printf("%s\n","aaaaaaaaaaaaaaaaaaaaa");
//generate a return value if a function is not void,partial routine code, no need for this function

//rountine code
  int func;
  PlTerm arg[10];
  PlBool res;

//routine code, register a predicate,clear_bufs is not routine
  func = Pl_Find_Atom("clear_bufs");
  //printf("func is %d\n", func);

//routine code 
  Pl_Query_Begin(PL_FALSE);

//prepare parameters
//partial routine code, pass in parameter
  arg[0] = Pl_Mk_Float((unsigned int)(&outcnt));
  arg[1] = Pl_Mk_Float((unsigned int)(&inptr));
  arg[2] = Pl_Mk_Float((unsigned int)(&insize));
  arg[3] = Pl_Mk_Float((unsigned int)(&bytes_out));
  arg[4] = Pl_Mk_Float((unsigned int)(&bytes_in));

//routine code, reserve a place for return value, NO
//NEED HERE

//partial routine code, 5 is not routine.
  res = Pl_Query_Call(func, 5, arg);  

//get return value, partial routine code, 1 is not routine NO NEED HERE

//routine code
  Pl_Query_End(PL_KEEP_FOR_PROLOG);

return;

/*
#line 7975
  outcnt = 0U;
#line 7976
  inptr = 0U;
#line 7976
  insize = inptr;
#line 7977
  bytes_out = 0L;
#line 7977
  bytes_in = bytes_out;

#line 7973
  return;*/
}

}


void clear_bufs(void) 
{ 
  clear_bufsWrapper();
}
#line 7983 "gzip.c"
int fill_inbuf(int eof_ok ) 
{ 
  int len ;
  int *tmp ;
  int __retres4 ;

  {
#line 7989
  insize = 0U;
  {
#line 7990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7991
    len = read(ifd, (void *)((char *)(inbuf) + insize), 32768U - insize);
#line 7992
    if (len == 0) {
#line 7992
      goto while_break;
    } else {

    }
#line 7993
    if (len == -1) {
#line 7994
      read_error();
#line 7995
      goto while_break;
    } else {

    }
#line 7997
    insize += (unsigned int )len;
#line 7990
    if (insize < 32768U) {

    } else {
#line 7990
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 8000
  if (insize == 0U) {
#line 8001
    if (eof_ok != 0) {
#line 8001
      __retres4 = -1;
#line 8001
      goto return_label;
    } else {

    }
#line 8002
    flush_window();
#line 8003
    tmp = __errno_location();
#line 8003
    *tmp = 0;
#line 8004
    read_error();
  } else {

  }
#line 8006
  bytes_in += (off_t )insize;
#line 8007
  inptr = 1U;
#line 8008
  __retres4 = (int )inbuf[0];
  return_label: /* CIL Label */ 
#line 7983
  return (__retres4);
}
}
#line 8015 "gzip.c"
void flush_outbuf(void) 
{ 


  {
#line 8017
  if (outcnt == 0U) {

#line 8017
    goto return_label;
  } else {

  }
#line 8019
  write_buf(ofd, (voidp )((char *)(outbuf)), outcnt);
#line 8020
  bytes_out += (off_t )outcnt;
#line 8021
  outcnt = 0U;

  return_label: /* CIL Label */ 
#line 8015
  return;
}
}
#line 8028 "gzip.c"
void flush_window(void) 
{ 


  {
#line 8030
  if (outcnt == 0U) {

#line 8030
    goto return_label;
  } else {

  }
#line 8031
  updcrc(window, outcnt);
#line 8033
  if (test == 0) {
#line 8034
    write_buf(ofd, (voidp )((char *)(window)), outcnt);
  } else {

  }
#line 8036
  bytes_out += (off_t )outcnt;
#line 8037
  outcnt = 0U;

  return_label: /* CIL Label */ 
#line 8028
  return;
}
}
#line 8044 "gzip.c"
void write_buf(int fd , voidp buf , unsigned int cnt ) 
{ 
  unsigned int n ;
  ssize_t tmp ;

  {
  {
#line 8051
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8051
    tmp = write(fd, (void const   *)buf, cnt);
#line 8051
    n = (unsigned int )tmp;
#line 8051
    if (n != cnt) {

    } else {
#line 8051
      goto while_break;
    }
#line 8052
    if (n == 4294967295U) {
#line 8053
      write_error();
    } else {

    }
#line 8055
    cnt -= n;
#line 8056
    buf = (voidp )((char *)buf + n);
  }
  while_break: /* CIL Label */ ;
  }

#line 8044
  return;
}
}
#line 8063 "gzip.c"
char *strlwr(char *s ) 
{ 
  char *t ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   *mem_6 ;

  {
#line 8067
  t = s;
  {
#line 8067
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8067
    if (*t != 0) {

    } else {
#line 8067
      goto while_break;
    }
#line 8068
    tmp___1 = __ctype_b_loc();
    {
#line 8068
    mem_6 = *tmp___1 + (int )((unsigned char )*t);
#line 8068
    if (((int const   )*mem_6 & 256) != 0) {
#line 8068
      tmp___0 = tolower((int )((unsigned char )*t));
#line 8068
      *t = (char )tmp___0;
    } else {
#line 8068
      *t = (char )((unsigned char )*t);
    }
    }
#line 8067
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 8069
  return (s);
}
}
#line 8077 "gzip.c"
char *base_name(char *fname ) 
{ 
  char *p ;

  {
#line 8082
  p = strrchr((char const   *)fname, '/');
#line 8082
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 8082
    fname = p + 1;
  } else {

  }
#line 8093
  return (fname);
}
}
#line 8099 "gzip.c"
int xunlink(char *filename ) 
{ 
  int r ;
  int tmp ;

  {
#line 8102
  tmp = unlink((char const   *)filename);
#line 8102
  r = tmp;
#line 8118
  return (r);
}
}
#line 8129 "gzip.c"
void make_simple_name(char *name ) 
{ 
  char *p ;
  char *tmp ;

  {
#line 8132
  tmp = strrchr((char const   *)name, '.');
#line 8132
  p = tmp;
#line 8133
  if ((unsigned int )p == (unsigned int )((void *)0)) {

#line 8133
    goto return_label;
  } else {

  }
#line 8134
  if ((unsigned int )p == (unsigned int )name) {
#line 8134
    p ++;
  } else {

  }
  {
#line 8135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8136
    p --;
#line 8136
    if ((int )*p == 46) {
#line 8136
      *p = (char )'_';
    } else {

    }
#line 8135
    if ((unsigned int )p != (unsigned int )name) {

    } else {
#line 8135
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }

  return_label: /* CIL Label */ 
#line 8129
  return;
}
}
#line 8200 "gzip.c"
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) 
{ 
  char *p ;
  char **oargv ;
  char **nargv ;
  int oargc ;
  int nargc ;
  char *tmp ;
  size_t tmp___0 ;
  voidp tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char **tmp___8 ;
  size_t tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  char **tmp___12 ;
  char **tmp___13 ;
  int tmp___14 ;
  char *__retres25 ;

  {
#line 8208
  oargc = *argcp;
#line 8209
  nargc = 0;
#line 8211
  tmp = getenv((char const   *)env___0);
#line 8211
  env___0 = tmp;
#line 8212
  if ((unsigned int )env___0 == (unsigned int )((void *)0)) {
#line 8212
    __retres25 = (char *)((void *)0);
#line 8212
    goto return_label;
  } else {

  }
#line 8214
  tmp___0 = strlen((char const   *)env___0);
#line 8214
  tmp___1 = xmalloc(tmp___0 + 1U);
#line 8214
  p = (char *)tmp___1;
#line 8215
  env___0 = strcpy((char * __restrict  )p, (char const   * __restrict  )env___0);
#line 8217
  p = env___0;
  {
#line 8217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8217
    if (*p != 0) {

    } else {
#line 8217
      goto while_break;
    }
#line 8218
    tmp___2 = strspn((char const   *)p, " \t");
#line 8218
    p += tmp___2;
#line 8219
    if ((int )*p == 0) {
#line 8219
      goto while_break;
    } else {

    }
#line 8221
    tmp___3 = strcspn((char const   *)p, " \t");
#line 8221
    p += tmp___3;
#line 8222
    if (*p != 0) {
#line 8222
      tmp___4 = p;
#line 8222
      p ++;
#line 8222
      *tmp___4 = (char )'\000';
    } else {

    }
#line 8217
    nargc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 8224
  if (nargc == 0) {
#line 8225
    free((void *)env___0);
#line 8226
    __retres25 = (char *)((void *)0);
#line 8226
    goto return_label;
  } else {

  }
#line 8228
  *argcp += nargc;
#line 8232
  tmp___5 = calloc((size_t )(*argcp + 1), sizeof(char *));
#line 8232
  nargv = (char **)tmp___5;
#line 8233
  if ((unsigned int )nargv == (unsigned int )((void *)0)) {
#line 8233
    error((char *)"out of memory");
  } else {

  }
#line 8234
  oargv = *argvp;
#line 8235
  *argvp = nargv;
#line 8238
  tmp___6 = oargc;
#line 8238
  oargc --;
#line 8238
  if (tmp___6 < 0) {
#line 8238
    error((char *)"argc<=0");
  } else {

  }
#line 8239
  tmp___7 = nargv;
#line 8239
  nargv ++;
#line 8239
  tmp___8 = oargv;
#line 8239
  oargv ++;
#line 8239
  *tmp___7 = *tmp___8;
#line 8242
  p = env___0;
  {
#line 8242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 8242
    if (nargc > 0) {

    } else {
#line 8242
      goto while_break___0;
    }
#line 8243
    tmp___9 = strspn((char const   *)p, " \t");
#line 8243
    p += tmp___9;
#line 8244
    tmp___10 = nargv;
#line 8244
    nargv ++;
#line 8244
    *tmp___10 = p;
    {
#line 8245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 8245
      tmp___11 = p;
#line 8245
      p ++;
#line 8245
      if (*tmp___11 != 0) {

      } else {
#line 8245
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 8242
    nargc --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 8249
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 8249
    tmp___14 = oargc;
#line 8249
    oargc --;
#line 8249
    if (tmp___14 != 0) {

    } else {
#line 8249
      goto while_break___2;
    }
#line 8249
    tmp___12 = nargv;
#line 8249
    nargv ++;
#line 8249
    tmp___13 = oargv;
#line 8249
    oargv ++;
#line 8249
    *tmp___12 = *tmp___13;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 8250
  *nargv = (char *)((void *)0);
#line 8251
  __retres25 = env___0;
  return_label: /* CIL Label */ 
#line 8200
  return (__retres25);
}
}
#line 8257 "gzip.c"
void error(char *m ) 
{ 


  {
#line 8260
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: %s: %s\n",
          progname, ifname, m);
#line 8261
  abort_gzip();

#line 8257
  return;
}
}
#line 8264 "gzip.c"
void warning(char *m ) 
{ 


  {
#line 8267
  if (quiet == 0) {
#line 8267
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s: warning: %s\n",
            progname, ifname, m);
  } else {

  }
#line 8267
  if (exit_code == 0) {
#line 8267
    exit_code = 2;
  } else {

  }

#line 8264
  return;
}
}
#line 8270 "gzip.c"
void read_error(void) 
{ 
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 8272
  tmp = __errno_location();
#line 8272
  e = *tmp;
#line 8273
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: ", progname);
#line 8274
  if (e != 0) {
#line 8275
    tmp___0 = __errno_location();
#line 8275
    *tmp___0 = e;
#line 8276
    perror((char const   *)(ifname));
  } else {
#line 8278
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: unexpected end of file\n",
            ifname);
  }
#line 8280
  abort_gzip();

#line 8270
  return;
}
}
#line 8283 "gzip.c"
void write_error(void) 
{ 
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 8285
  tmp = __errno_location();
#line 8285
  e = *tmp;
#line 8286
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n%s: ", progname);
#line 8287
  tmp___0 = __errno_location();
#line 8287
  *tmp___0 = e;
#line 8288
  perror((char const   *)(ofname));
#line 8289
  abort_gzip();

#line 8283
  return;
}
}
#line 8295 "gzip.c"
void display_ratio(off_t num , off_t den , FILE *file ) 
{ 
  double tmp ;

  {
#line 8300
  if (den == 0L) {
#line 8300
    tmp = (double )0;
  } else {
#line 8300
    tmp = (100.0 * (double )num) / (double )den;
  }
#line 8300
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"%5.1f%%", tmp);

#line 8295
  return;
}
}
#line 8307 "gzip.c"
void fprint_off(FILE *file , off_t offset , int width ) 
{ 
  char buf[8U * sizeof(off_t )] ;
  char *p ;
  int tmp ;

  {
#line 8313
  p = buf + sizeof(buf);
#line 8316
  if (offset < 0L) {
    {
#line 8317
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8318
      p --;
#line 8318
      *p = (char )(48L - offset % 10L);
#line 8317
      offset /= 10L;
#line 8317
      if (offset != 0L) {

      } else {
#line 8317
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 8321
    p --;
#line 8321
    *p = (char )'-';
  } else {
    {
#line 8323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 8324
      p --;
#line 8324
      *p = (char )(48L + offset % 10L);
#line 8323
      offset /= 10L;
#line 8323
      if (offset != 0L) {

      } else {
#line 8323
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 8328
  width -= (buf + sizeof(buf)) - p;
  {
#line 8329
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 8329
    tmp = width;
#line 8329
    width --;
#line 8329
    if (0 < tmp) {

    } else {
#line 8329
      goto while_break___1;
    }
#line 8330
    _IO_putc(' ', file);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 8332
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 8332
    if ((unsigned int )p < (unsigned int )(buf + sizeof(buf))) {

    } else {
#line 8332
      goto while_break___2;
    }
#line 8333
    _IO_putc((int )*p, file);
#line 8332
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }

#line 8307
  return;
}
}
#line 8339 "gzip.c"
voidp xmalloc(unsigned int size ) 
{ 
  voidp cp ;
  void *tmp ;

  {
#line 8342
  tmp = malloc(size);
#line 8342
  cp = tmp;
#line 8344
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 8344
    error((char *)"out of memory");
  } else {

  }
#line 8345
  return (cp);
}
}
#line 8351 "gzip.c"
ulg crc_32_tab[256]  = 
#line 8351
  {      (ulg )0L,      (ulg )1996959894L,      3993919788UL,      2567524794UL, 
        (ulg )124634137L,      (ulg )1886057615L,      3915621685UL,      2657392035UL, 
        (ulg )249268274L,      (ulg )2044508324L,      3772115230UL,      2547177864UL, 
        (ulg )162941995L,      (ulg )2125561021L,      3887607047UL,      2428444049UL, 
        (ulg )498536548L,      (ulg )1789927666L,      4089016648UL,      2227061214UL, 
        (ulg )450548861L,      (ulg )1843258603L,      4107580753UL,      2211677639UL, 
        (ulg )325883990L,      (ulg )1684777152L,      4251122042UL,      2321926636UL, 
        (ulg )335633487L,      (ulg )1661365465L,      4195302755UL,      2366115317UL, 
        (ulg )997073096L,      (ulg )1281953886L,      3579855332UL,      2724688242UL, 
        (ulg )1006888145L,      (ulg )1258607687L,      3524101629UL,      2768942443UL, 
        (ulg )901097722L,      (ulg )1119000684L,      3686517206UL,      2898065728UL, 
        (ulg )853044451L,      (ulg )1172266101L,      3705015759UL,      2882616665UL, 
        (ulg )651767980L,      (ulg )1373503546L,      3369554304UL,      3218104598UL, 
        (ulg )565507253L,      (ulg )1454621731L,      3485111705UL,      3099436303UL, 
        (ulg )671266974L,      (ulg )1594198024L,      3322730930UL,      2970347812UL, 
        (ulg )795835527L,      (ulg )1483230225L,      3244367275UL,      3060149565UL, 
        (ulg )1994146192L,      (ulg )31158534L,      2563907772UL,      4023717930UL, 
        (ulg )1907459465L,      (ulg )112637215L,      2680153253UL,      3904427059UL, 
        (ulg )2013776290L,      (ulg )251722036L,      2517215374UL,      3775830040UL, 
        (ulg )2137656763L,      (ulg )141376813L,      2439277719UL,      3865271297UL, 
        (ulg )1802195444L,      (ulg )476864866L,      2238001368UL,      4066508878UL, 
        (ulg )1812370925L,      (ulg )453092731L,      2181625025UL,      4111451223UL, 
        (ulg )1706088902L,      (ulg )314042704L,      2344532202UL,      4240017532UL, 
        (ulg )1658658271L,      (ulg )366619977L,      2362670323UL,      4224994405UL, 
        (ulg )1303535960L,      (ulg )984961486L,      2747007092UL,      3569037538UL, 
        (ulg )1256170817L,      (ulg )1037604311L,      2765210733UL,      3554079995UL, 
        (ulg )1131014506L,      (ulg )879679996L,      2909243462UL,      3663771856UL, 
        (ulg )1141124467L,      (ulg )855842277L,      2852801631UL,      3708648649UL, 
        (ulg )1342533948L,      (ulg )654459306L,      3188396048UL,      3373015174UL, 
        (ulg )1466479909L,      (ulg )544179635L,      3110523913UL,      3462522015UL, 
        (ulg )1591671054L,      (ulg )702138776L,      2966460450UL,      3352799412UL, 
        (ulg )1504918807L,      (ulg )783551873L,      3082640443UL,      3233442989UL, 
        3988292384UL,      2596254646UL,      (ulg )62317068L,      (ulg )1957810842L, 
        3939845945UL,      2647816111UL,      (ulg )81470997L,      (ulg )1943803523L, 
        3814918930UL,      2489596804UL,      (ulg )225274430L,      (ulg )2053790376L, 
        3826175755UL,      2466906013UL,      (ulg )167816743L,      (ulg )2097651377L, 
        4027552580UL,      2265490386UL,      (ulg )503444072L,      (ulg )1762050814L, 
        4150417245UL,      2154129355UL,      (ulg )426522225L,      (ulg )1852507879L, 
        4275313526UL,      2312317920UL,      (ulg )282753626L,      (ulg )1742555852L, 
        4189708143UL,      2394877945UL,      (ulg )397917763L,      (ulg )1622183637L, 
        3604390888UL,      2714866558UL,      (ulg )953729732L,      (ulg )1340076626L, 
        3518719985UL,      2797360999UL,      (ulg )1068828381L,      (ulg )1219638859L, 
        3624741850UL,      2936675148UL,      (ulg )906185462L,      (ulg )1090812512L, 
        3747672003UL,      2825379669UL,      (ulg )829329135L,      (ulg )1181335161L, 
        3412177804UL,      3160834842UL,      (ulg )628085408L,      (ulg )1382605366L, 
        3423369109UL,      3138078467UL,      (ulg )570562233L,      (ulg )1426400815L, 
        3317316542UL,      2998733608UL,      (ulg )733239954L,      (ulg )1555261956L, 
        3268935591UL,      3050360625UL,      (ulg )752459403L,      (ulg )1541320221L, 
        2607071920UL,      3965973030UL,      (ulg )1969922972L,      (ulg )40735498L, 
        2617837225UL,      3943577151UL,      (ulg )1913087877L,      (ulg )83908371L, 
        2512341634UL,      3803740692UL,      (ulg )2075208622L,      (ulg )213261112L, 
        2463272603UL,      3855990285UL,      (ulg )2094854071L,      (ulg )198958881L, 
        2262029012UL,      4057260610UL,      (ulg )1759359992L,      (ulg )534414190L, 
        2176718541UL,      4139329115UL,      (ulg )1873836001L,      (ulg )414664567L, 
        2282248934UL,      4279200368UL,      (ulg )1711684554L,      (ulg )285281116L, 
        2405801727UL,      4167216745UL,      (ulg )1634467795L,      (ulg )376229701L, 
        2685067896UL,      3608007406UL,      (ulg )1308918612L,      (ulg )956543938L, 
        2808555105UL,      3495958263UL,      (ulg )1231636301L,      (ulg )1047427035L, 
        2932959818UL,      3654703836UL,      (ulg )1088359270L,      (ulg )936918000L, 
        2847714899UL,      3736837829UL,      (ulg )1202900863L,      (ulg )817233897L, 
        3183342108UL,      3401237130UL,      (ulg )1404277552L,      (ulg )615818150L, 
        3134207493UL,      3453421203UL,      (ulg )1423857449L,      (ulg )601450431L, 
        3009837614UL,      3294710456UL,      (ulg )1567103746L,      (ulg )711928724L, 
        3020668471UL,      3272380065UL,      (ulg )1510334235L,      (ulg )755167117L};
#line 8428 "gzip.c"
int yesno(void) 
{ 
  char buf[128] ;
  int len ;
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   *mem_7 ;
  int __retres8 ;

  {
#line 8437
  len = 0;
  {
#line 8440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8440
    c = getchar();
#line 8440
    if (c != -1) {
#line 8440
      if (c != 10) {

      } else {
#line 8440
        goto while_break;
      }
    } else {
#line 8440
      goto while_break;
    }
#line 8441
    if (len > 0) {
#line 8441
      if (len < 127) {
#line 8442
        tmp = len;
#line 8442
        len ++;
#line 8442
        buf[tmp] = (char )c;
      } else {
#line 8441
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 8441
    if (len == 0) {
#line 8441
      tmp___0 = __ctype_b_loc();
      {
#line 8441
      mem_7 = *tmp___0 + c;
#line 8441
      if (((int const   )*mem_7 & 8192) != 0) {

      } else {
#line 8442
        tmp = len;
#line 8442
        len ++;
#line 8442
        buf[tmp] = (char )c;
      }
      }
    } else {

    }
  }
  while_break: /* CIL Label */ ;
  }
#line 8443
  buf[len] = (char )'\000';
#line 8445
  tmp___1 = rpmatch((char const   *)(buf));
#line 8445
  __retres8 = tmp___1 == 1;
#line 8428
  return (__retres8);
}
}
#line 8457 "gzip.c"
static ulg crc  ;
#line 8465 "gzip.c"
int zip(int in , int out ) 
{ 
  uch flags___0 ;
  ush attr ;
  ush deflate_flags ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  ulg tmp___4 ;
  unsigned int tmp___5 ;
  ulg tmp___6 ;
  unsigned int tmp___7 ;
  ulg tmp___8 ;
  unsigned int tmp___9 ;
  ulg tmp___10 ;
  unsigned int tmp___11 ;
  ulg tmp___12 ;
  unsigned int tmp___13 ;
  ulg tmp___14 ;
  unsigned int tmp___15 ;
  ulg tmp___16 ;
  unsigned int tmp___17 ;
  ulg tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  char *p ;
  char *tmp___21 ;
  unsigned int tmp___22 ;
  char *tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  char const   *mem_48 ;
  char const   *mem_49 ;
  int __retres50 ;

  {
#line 8468
  flags___0 = (uch )0;
#line 8469
  attr = (ush )0;
#line 8470
  deflate_flags = (ush )0;
#line 8472
  ifd = in;
#line 8473
  ofd = out;
#line 8474
  outcnt = 0U;
#line 8478
  method = 8;
#line 8479
  tmp = outcnt;
#line 8479
  outcnt ++;
#line 8479
  mem_48 = "\037\213" + 0;
#line 8479
  outbuf[tmp] = (uch )*mem_48;
#line 8479
  if (outcnt == 16384U) {
#line 8479
    flush_outbuf();
  } else {

  }
#line 8480
  tmp___0 = outcnt;
#line 8480
  outcnt ++;
#line 8480
  mem_49 = "\037\213" + 1;
#line 8480
  outbuf[tmp___0] = (uch )*mem_49;
#line 8480
  if (outcnt == 16384U) {
#line 8480
    flush_outbuf();
  } else {

  }
#line 8481
  tmp___1 = outcnt;
#line 8481
  outcnt ++;
#line 8481
  outbuf[tmp___1] = (uch )8;
#line 8481
  if (outcnt == 16384U) {
#line 8481
    flush_outbuf();
  } else {

  }
#line 8483
  if (save_orig_name != 0) {
#line 8484
    flags___0 = (uch )((int )flags___0 | 8);
  } else {

  }
#line 8486
  tmp___2 = outcnt;
#line 8486
  outcnt ++;
#line 8486
  outbuf[tmp___2] = flags___0;
#line 8486
  if (outcnt == 16384U) {
#line 8486
    flush_outbuf();
  } else {

  }
#line 8487
  if (outcnt < 16382U) {
#line 8487
    tmp___3 = outcnt;
#line 8487
    outcnt ++;
#line 8487
    if ((unsigned long )time_stamp == ((unsigned long )time_stamp & 4294967295UL)) {
#line 8487
      tmp___4 = (ulg )time_stamp;
    } else {
#line 8487
      tmp___4 = (ulg )0;
    }
#line 8487
    outbuf[tmp___3] = (uch )((tmp___4 & 65535UL) & 255UL);
#line 8487
    tmp___5 = outcnt;
#line 8487
    outcnt ++;
#line 8487
    if ((unsigned long )time_stamp == ((unsigned long )time_stamp & 4294967295UL)) {
#line 8487
      tmp___6 = (ulg )time_stamp;
    } else {
#line 8487
      tmp___6 = (ulg )0;
    }
#line 8487
    outbuf[tmp___5] = (uch )((int )((ush )(tmp___6 & 65535UL)) >> 8);
  } else {
#line 8487
    tmp___7 = outcnt;
#line 8487
    outcnt ++;
#line 8487
    if ((unsigned long )time_stamp == ((unsigned long )time_stamp & 4294967295UL)) {
#line 8487
      tmp___8 = (ulg )time_stamp;
    } else {
#line 8487
      tmp___8 = (ulg )0;
    }
#line 8487
    outbuf[tmp___7] = (uch )((tmp___8 & 65535UL) & 255UL);
#line 8487
    if (outcnt == 16384U) {
#line 8487
      flush_outbuf();
    } else {

    }
#line 8487
    tmp___9 = outcnt;
#line 8487
    outcnt ++;
#line 8487
    if ((unsigned long )time_stamp == ((unsigned long )time_stamp & 4294967295UL)) {
#line 8487
      tmp___10 = (ulg )time_stamp;
    } else {
#line 8487
      tmp___10 = (ulg )0;
    }
#line 8487
    outbuf[tmp___9] = (uch )((int )((ush )(tmp___10 & 65535UL)) >> 8);
#line 8487
    if (outcnt == 16384U) {
#line 8487
      flush_outbuf();
    } else {

    }
  }
#line 8487
  if (outcnt < 16382U) {
#line 8487
    tmp___11 = outcnt;
#line 8487
    outcnt ++;
#line 8487
    if ((unsigned long )time_stamp == ((unsigned long )time_stamp & 4294967295UL)) {
#line 8487
      tmp___12 = (ulg )time_stamp;
    } else {
#line 8487
      tmp___12 = (ulg )0;
    }
#line 8487
    outbuf[tmp___11] = (uch )((tmp___12 >> 16) & 255UL);
#line 8487
    tmp___13 = outcnt;
#line 8487
    outcnt ++;
#line 8487
    if ((unsigned long )time_stamp == ((unsigned long )time_stamp & 4294967295UL)) {
#line 8487
      tmp___14 = (ulg )time_stamp;
    } else {
#line 8487
      tmp___14 = (ulg )0;
    }
#line 8487
    outbuf[tmp___13] = (uch )((int )((ush )(tmp___14 >> 16)) >> 8);
  } else {
#line 8487
    tmp___15 = outcnt;
#line 8487
    outcnt ++;
#line 8487
    if ((unsigned long )time_stamp == ((unsigned long )time_stamp & 4294967295UL)) {
#line 8487
      tmp___16 = (ulg )time_stamp;
    } else {
#line 8487
      tmp___16 = (ulg )0;
    }
#line 8487
    outbuf[tmp___15] = (uch )((tmp___16 >> 16) & 255UL);
#line 8487
    if (outcnt == 16384U) {
#line 8487
      flush_outbuf();
    } else {

    }
#line 8487
    tmp___17 = outcnt;
#line 8487
    outcnt ++;
#line 8487
    if ((unsigned long )time_stamp == ((unsigned long )time_stamp & 4294967295UL)) {
#line 8487
      tmp___18 = (ulg )time_stamp;
    } else {
#line 8487
      tmp___18 = (ulg )0;
    }
#line 8487
    outbuf[tmp___17] = (uch )((int )((ush )(tmp___18 >> 16)) >> 8);
#line 8487
    if (outcnt == 16384U) {
#line 8487
      flush_outbuf();
    } else {

    }
  }
#line 8491
  crc = updcrc((uch *)0, 0U);
#line 8493
  bi_init(out);
#line 8494
  ct_init(& attr, & method);
#line 8495
  lm_init(level, & deflate_flags);
#line 8497
  tmp___19 = outcnt;
#line 8497
  outcnt ++;
#line 8497
  outbuf[tmp___19] = (uch )deflate_flags;
#line 8497
  if (outcnt == 16384U) {
#line 8497
    flush_outbuf();
  } else {

  }
#line 8498
  tmp___20 = outcnt;
#line 8498
  outcnt ++;
#line 8498
  outbuf[tmp___20] = (uch )3;
#line 8498
  if (outcnt == 16384U) {
#line 8498
    flush_outbuf();
  } else {

  }
#line 8500
  if (save_orig_name != 0) {
#line 8501
    tmp___21 = base_name(ifname);
#line 8501
    p = tmp___21;
    {
#line 8502
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8503
      tmp___22 = outcnt;
#line 8503
      outcnt ++;
#line 8503
      outbuf[tmp___22] = (uch )*p;
#line 8503
      if (outcnt == 16384U) {
#line 8503
        flush_outbuf();
      } else {

      }
#line 8502
      tmp___23 = p;
#line 8502
      p ++;
#line 8502
      if (*tmp___23 != 0) {

      } else {
#line 8502
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {

  }
#line 8506
  header_bytes = (off_t )outcnt;
#line 8508
  deflate();
#line 8521
  if (outcnt < 16382U) {
#line 8521
    tmp___24 = outcnt;
#line 8521
    outcnt ++;
#line 8521
    outbuf[tmp___24] = (uch )((crc & 65535UL) & 255UL);
#line 8521
    tmp___25 = outcnt;
#line 8521
    outcnt ++;
#line 8521
    outbuf[tmp___25] = (uch )((int )((ush )(crc & 65535UL)) >> 8);
  } else {
#line 8521
    tmp___26 = outcnt;
#line 8521
    outcnt ++;
#line 8521
    outbuf[tmp___26] = (uch )((crc & 65535UL) & 255UL);
#line 8521
    if (outcnt == 16384U) {
#line 8521
      flush_outbuf();
    } else {

    }
#line 8521
    tmp___27 = outcnt;
#line 8521
    outcnt ++;
#line 8521
    outbuf[tmp___27] = (uch )((int )((ush )(crc & 65535UL)) >> 8);
#line 8521
    if (outcnt == 16384U) {
#line 8521
      flush_outbuf();
    } else {

    }
  }
#line 8521
  if (outcnt < 16382U) {
#line 8521
    tmp___28 = outcnt;
#line 8521
    outcnt ++;
#line 8521
    outbuf[tmp___28] = (uch )((crc >> 16) & 255UL);
#line 8521
    tmp___29 = outcnt;
#line 8521
    outcnt ++;
#line 8521
    outbuf[tmp___29] = (uch )((int )((ush )(crc >> 16)) >> 8);
  } else {
#line 8521
    tmp___30 = outcnt;
#line 8521
    outcnt ++;
#line 8521
    outbuf[tmp___30] = (uch )((crc >> 16) & 255UL);
#line 8521
    if (outcnt == 16384U) {
#line 8521
      flush_outbuf();
    } else {

    }
#line 8521
    tmp___31 = outcnt;
#line 8521
    outcnt ++;
#line 8521
    outbuf[tmp___31] = (uch )((int )((ush )(crc >> 16)) >> 8);
#line 8521
    if (outcnt == 16384U) {
#line 8521
      flush_outbuf();
    } else {

    }
  }
#line 8522
  if (outcnt < 16382U) {
#line 8522
    tmp___32 = outcnt;
#line 8522
    outcnt ++;
#line 8522
    outbuf[tmp___32] = (uch )(((ulg )bytes_in & 65535UL) & 255UL);
#line 8522
    tmp___33 = outcnt;
#line 8522
    outcnt ++;
#line 8522
    outbuf[tmp___33] = (uch )((int )((ush )((ulg )bytes_in & 65535UL)) >> 8);
  } else {
#line 8522
    tmp___34 = outcnt;
#line 8522
    outcnt ++;
#line 8522
    outbuf[tmp___34] = (uch )(((ulg )bytes_in & 65535UL) & 255UL);
#line 8522
    if (outcnt == 16384U) {
#line 8522
      flush_outbuf();
    } else {

    }
#line 8522
    tmp___35 = outcnt;
#line 8522
    outcnt ++;
#line 8522
    outbuf[tmp___35] = (uch )((int )((ush )((ulg )bytes_in & 65535UL)) >> 8);
#line 8522
    if (outcnt == 16384U) {
#line 8522
      flush_outbuf();
    } else {

    }
  }
#line 8522
  if (outcnt < 16382U) {
#line 8522
    tmp___36 = outcnt;
#line 8522
    outcnt ++;
#line 8522
    outbuf[tmp___36] = (uch )(((ulg )bytes_in >> 16) & 255UL);
#line 8522
    tmp___37 = outcnt;
#line 8522
    outcnt ++;
#line 8522
    outbuf[tmp___37] = (uch )((int )((ush )((ulg )bytes_in >> 16)) >> 8);
  } else {
#line 8522
    tmp___38 = outcnt;
#line 8522
    outcnt ++;
#line 8522
    outbuf[tmp___38] = (uch )(((ulg )bytes_in >> 16) & 255UL);
#line 8522
    if (outcnt == 16384U) {
#line 8522
      flush_outbuf();
    } else {

    }
#line 8522
    tmp___39 = outcnt;
#line 8522
    outcnt ++;
#line 8522
    outbuf[tmp___39] = (uch )((int )((ush )((ulg )bytes_in >> 16)) >> 8);
#line 8522
    if (outcnt == 16384U) {
#line 8522
      flush_outbuf();
    } else {

    }
  }
#line 8523
  header_bytes = (off_t )((unsigned long )header_bytes + (unsigned long )(2U * sizeof(long )));
#line 8525
  flush_outbuf();
#line 8526
  __retres50 = 0;
#line 8465
  return (__retres50);
}
}
#line 8535 "gzip.c"
int file_read(char *buf , unsigned int size ) 
{ 
  unsigned int len ;
  ssize_t tmp ;
  int __retres5 ;

  {
#line 8543
  tmp = read(ifd, (void *)buf, size);
#line 8543
  len = (unsigned int )tmp;
#line 8544
  if (len == 0U) {
#line 8544
    __retres5 = (int )len;
#line 8544
    goto return_label;
  } else {

  }
#line 8545
  if (len == 4294967295U) {
#line 8546
    read_error();
#line 8547
    __retres5 = -1;
#line 8547
    goto return_label;
  } else {

  }
#line 8550
  crc = updcrc((uch *)buf, len);
#line 8551
  bytes_in += (off_t )len;
#line 8552
  __retres5 = (int )len;
  return_label: /* CIL Label */ 
#line 8535
  return (__retres5);
}
}
#line 8573
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rpmatch)(char const   *response ) ;
#line 8573 "gzip.c"
int ( __attribute__((__nonnull__(1), __leaf__)) rpmatch)(char const   *response ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 8577
  if ((int const   )*response == 121) {
#line 8577
    tmp___0 = 1;
  } else
#line 8577
  if ((int const   )*response == 89) {
#line 8577
    tmp___0 = 1;
  } else {
#line 8577
    if ((int const   )*response == 110) {
#line 8577
      tmp = 0;
    } else
#line 8577
    if ((int const   )*response == 78) {
#line 8577
      tmp = 0;
    } else {
#line 8577
      tmp = -1;
    }
#line 8577
    tmp___0 = tmp;
  }
#line 8577
  return (tmp___0);
}
}
#line 8582 "gzip.c"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) 
{ 
  int tmp ;

  {
#line 8590
  tmp = _getopt_internal(argc, argv, options, long_options, opt_index, 0);
#line 8590
  return (tmp);
}
}
#line 8598 "gzip.c"
int getopt_long_only(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                     int *opt_index ) 
{ 
  int tmp ;

  {
#line 8606
  tmp = _getopt_internal(argc, argv, options, long_options, opt_index, 1);
#line 8606
  return (tmp);
}
}
